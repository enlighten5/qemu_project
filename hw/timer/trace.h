/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_TIMER_GENERATED_TRACERS_H
#define TRACE_HW_TIMER_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_SLAVIO_TIMER_GET_OUT_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_IRQ_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_READL_INVALID_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_READL_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID_EVENT;
extern TraceEvent _TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_ENABLE_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_DISABLED_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_RESTART_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_SET_SCALER_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_HIT_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_READL_EVENT;
extern TraceEvent _TRACE_GRLIB_GPTIMER_WRITEL_EVENT;
extern TraceEvent _TRACE_LM32_TIMER_MEMORY_WRITE_EVENT;
extern TraceEvent _TRACE_LM32_TIMER_MEMORY_READ_EVENT;
extern TraceEvent _TRACE_LM32_TIMER_HIT_EVENT;
extern TraceEvent _TRACE_LM32_TIMER_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_SYSCTL_MEMORY_READ_EVENT;
extern TraceEvent _TRACE_MILKYMIST_SYSCTL_MEMORY_WRITE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_SYSCTL_ICAP_WRITE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_SYSCTL_START_TIMER0_EVENT;
extern TraceEvent _TRACE_MILKYMIST_SYSCTL_STOP_TIMER0_EVENT;
extern TraceEvent _TRACE_MILKYMIST_SYSCTL_START_TIMER1_EVENT;
extern TraceEvent _TRACE_MILKYMIST_SYSCTL_STOP_TIMER1_EVENT;
extern TraceEvent _TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER0_EVENT;
extern TraceEvent _TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER1_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_CTRL_ENABLE_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_SET_CTRL2_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_SET_VALUE_EVENT;
extern TraceEvent _TRACE_ASPEED_TIMER_READ_EVENT;
extern TraceEvent _TRACE_SYSTICK_RELOAD_EVENT;
extern TraceEvent _TRACE_SYSTICK_TIMER_TICK_EVENT;
extern TraceEvent _TRACE_SYSTICK_READ_EVENT;
extern TraceEvent _TRACE_SYSTICK_WRITE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_TIMER_READ_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_TIMER_WRITE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_TIMER_RESET_EVENT;
extern uint16_t _TRACE_SLAVIO_TIMER_GET_OUT_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_IRQ_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_READL_INVALID_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_READL_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID_DSTATE;
extern uint16_t _TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_ENABLE_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_DISABLED_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_RESTART_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_SET_SCALER_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_HIT_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_READL_DSTATE;
extern uint16_t _TRACE_GRLIB_GPTIMER_WRITEL_DSTATE;
extern uint16_t _TRACE_LM32_TIMER_MEMORY_WRITE_DSTATE;
extern uint16_t _TRACE_LM32_TIMER_MEMORY_READ_DSTATE;
extern uint16_t _TRACE_LM32_TIMER_HIT_DSTATE;
extern uint16_t _TRACE_LM32_TIMER_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_SYSCTL_MEMORY_READ_DSTATE;
extern uint16_t _TRACE_MILKYMIST_SYSCTL_MEMORY_WRITE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_SYSCTL_ICAP_WRITE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_SYSCTL_START_TIMER0_DSTATE;
extern uint16_t _TRACE_MILKYMIST_SYSCTL_STOP_TIMER0_DSTATE;
extern uint16_t _TRACE_MILKYMIST_SYSCTL_START_TIMER1_DSTATE;
extern uint16_t _TRACE_MILKYMIST_SYSCTL_STOP_TIMER1_DSTATE;
extern uint16_t _TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER0_DSTATE;
extern uint16_t _TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER1_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_CTRL_ENABLE_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_SET_CTRL2_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_SET_VALUE_DSTATE;
extern uint16_t _TRACE_ASPEED_TIMER_READ_DSTATE;
extern uint16_t _TRACE_SYSTICK_RELOAD_DSTATE;
extern uint16_t _TRACE_SYSTICK_TIMER_TICK_DSTATE;
extern uint16_t _TRACE_SYSTICK_READ_DSTATE;
extern uint16_t _TRACE_SYSTICK_WRITE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_TIMER_READ_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_TIMER_WRITE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_TIMER_RESET_DSTATE;
#define TRACE_SLAVIO_TIMER_GET_OUT_ENABLED 1
#define TRACE_SLAVIO_TIMER_IRQ_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_READL_INVALID_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_READL_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID_ENABLED 1
#define TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID_ENABLED 1
#define TRACE_GRLIB_GPTIMER_ENABLE_ENABLED 1
#define TRACE_GRLIB_GPTIMER_DISABLED_ENABLED 1
#define TRACE_GRLIB_GPTIMER_RESTART_ENABLED 1
#define TRACE_GRLIB_GPTIMER_SET_SCALER_ENABLED 1
#define TRACE_GRLIB_GPTIMER_HIT_ENABLED 1
#define TRACE_GRLIB_GPTIMER_READL_ENABLED 1
#define TRACE_GRLIB_GPTIMER_WRITEL_ENABLED 1
#define TRACE_LM32_TIMER_MEMORY_WRITE_ENABLED 1
#define TRACE_LM32_TIMER_MEMORY_READ_ENABLED 1
#define TRACE_LM32_TIMER_HIT_ENABLED 1
#define TRACE_LM32_TIMER_IRQ_STATE_ENABLED 1
#define TRACE_MILKYMIST_SYSCTL_MEMORY_READ_ENABLED 1
#define TRACE_MILKYMIST_SYSCTL_MEMORY_WRITE_ENABLED 1
#define TRACE_MILKYMIST_SYSCTL_ICAP_WRITE_ENABLED 1
#define TRACE_MILKYMIST_SYSCTL_START_TIMER0_ENABLED 1
#define TRACE_MILKYMIST_SYSCTL_STOP_TIMER0_ENABLED 1
#define TRACE_MILKYMIST_SYSCTL_START_TIMER1_ENABLED 1
#define TRACE_MILKYMIST_SYSCTL_STOP_TIMER1_ENABLED 1
#define TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER0_ENABLED 1
#define TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER1_ENABLED 1
#define TRACE_ASPEED_TIMER_CTRL_ENABLE_ENABLED 1
#define TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK_ENABLED 1
#define TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT_ENABLED 1
#define TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE_ENABLED 1
#define TRACE_ASPEED_TIMER_SET_CTRL2_ENABLED 1
#define TRACE_ASPEED_TIMER_SET_VALUE_ENABLED 1
#define TRACE_ASPEED_TIMER_READ_ENABLED 1
#define TRACE_SYSTICK_RELOAD_ENABLED 1
#define TRACE_SYSTICK_TIMER_TICK_ENABLED 1
#define TRACE_SYSTICK_READ_ENABLED 1
#define TRACE_SYSTICK_WRITE_ENABLED 1
#define TRACE_CMSDK_APB_TIMER_READ_ENABLED 1
#define TRACE_CMSDK_APB_TIMER_WRITE_ENABLED 1
#define TRACE_CMSDK_APB_TIMER_RESET_ENABLED 1
#include "qemu/log.h"


#define TRACE_SLAVIO_TIMER_GET_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_GET_OUT) || \
    false)

static inline void _nocheck__trace_slavio_timer_get_out(uint64_t limit, uint32_t counthigh, uint32_t count)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_GET_OUT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_get_out " "limit 0x%"PRIx64" count 0x%x0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , limit, counthigh, count);
    }
}

static inline void trace_slavio_timer_get_out(uint64_t limit, uint32_t counthigh, uint32_t count)
{
    if (true) {
        _nocheck__trace_slavio_timer_get_out(limit, counthigh, count);
    }
}

#define TRACE_SLAVIO_TIMER_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_IRQ) || \
    false)

static inline void _nocheck__trace_slavio_timer_irq(uint32_t counthigh, uint32_t count)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_IRQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_irq " "callback: count 0x%x0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , counthigh, count);
    }
}

static inline void trace_slavio_timer_irq(uint32_t counthigh, uint32_t count)
{
    if (true) {
        _nocheck__trace_slavio_timer_irq(counthigh, count);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_READL_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_READL_INVALID) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_readl_invalid(uint64_t addr)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_READL_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_readl_invalid " "invalid read address 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_slavio_timer_mem_readl_invalid(uint64_t addr)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_readl_invalid(addr);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_READL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_READL) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_readl(uint64_t addr, uint32_t ret)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_READL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_readl " "read 0x%"PRIx64" = 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, ret);
    }
}

static inline void trace_slavio_timer_mem_readl(uint64_t addr, uint32_t ret)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_readl(addr, ret);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_writel " "write 0x%"PRIx64" = 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, val);
    }
}

static inline void trace_slavio_timer_mem_writel(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel(addr, val);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_limit(unsigned int timer_index, uint64_t count)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_writel_limit " "processor %d user timer set to 0x%016"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , timer_index, count);
    }
}

static inline void trace_slavio_timer_mem_writel_limit(unsigned int timer_index, uint64_t count)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_limit(timer_index, count);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_counter_invalid(void)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_writel_counter_invalid " "not user timer" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_slavio_timer_mem_writel_counter_invalid(void)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_counter_invalid();
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_status_start(unsigned int timer_index)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_writel_status_start " "processor %d user timer started" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , timer_index);
    }
}

static inline void trace_slavio_timer_mem_writel_status_start(unsigned int timer_index)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_status_start(timer_index);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_status_stop(unsigned int timer_index)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_writel_status_stop " "processor %d user timer stopped" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , timer_index);
    }
}

static inline void trace_slavio_timer_mem_writel_status_stop(unsigned int timer_index)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_status_stop(timer_index);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_mode_user(unsigned int timer_index)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_writel_mode_user " "processor %d changed from counter to user timer" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , timer_index);
    }
}

static inline void trace_slavio_timer_mem_writel_mode_user(unsigned int timer_index)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_mode_user(timer_index);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_mode_counter(unsigned int timer_index)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_writel_mode_counter " "processor %d changed from user timer to counter" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , timer_index);
    }
}

static inline void trace_slavio_timer_mem_writel_mode_counter(unsigned int timer_index)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_mode_counter(timer_index);
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_mode_invalid(void)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_writel_mode_invalid " "not system timer" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_slavio_timer_mem_writel_mode_invalid(void)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_mode_invalid();
    }
}

#define TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID) || \
    false)

static inline void _nocheck__trace_slavio_timer_mem_writel_invalid(uint64_t addr)
{
    if (trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:slavio_timer_mem_writel_invalid " "invalid write address 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_slavio_timer_mem_writel_invalid(uint64_t addr)
{
    if (true) {
        _nocheck__trace_slavio_timer_mem_writel_invalid(addr);
    }
}

#define TRACE_GRLIB_GPTIMER_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_ENABLE) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_enable(int id, uint32_t count)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_ENABLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:grlib_gptimer_enable " "timer:%d set count 0x%x and run" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , id, count);
    }
}

static inline void trace_grlib_gptimer_enable(int id, uint32_t count)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_enable(id, count);
    }
}

#define TRACE_GRLIB_GPTIMER_DISABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_DISABLED) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_disabled(int id, uint32_t config)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_DISABLED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:grlib_gptimer_disabled " "timer:%d Timer disable config 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , id, config);
    }
}

static inline void trace_grlib_gptimer_disabled(int id, uint32_t config)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_disabled(id, config);
    }
}

#define TRACE_GRLIB_GPTIMER_RESTART_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_RESTART) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_restart(int id, uint32_t reload)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_RESTART)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:grlib_gptimer_restart " "timer:%d reload val: 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , id, reload);
    }
}

static inline void trace_grlib_gptimer_restart(int id, uint32_t reload)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_restart(id, reload);
    }
}

#define TRACE_GRLIB_GPTIMER_SET_SCALER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_SET_SCALER) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_set_scaler(uint32_t scaler, uint32_t freq)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_SET_SCALER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:grlib_gptimer_set_scaler " "scaler:0x%x freq: 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , scaler, freq);
    }
}

static inline void trace_grlib_gptimer_set_scaler(uint32_t scaler, uint32_t freq)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_set_scaler(scaler, freq);
    }
}

#define TRACE_GRLIB_GPTIMER_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_HIT) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_hit(int id)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_HIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:grlib_gptimer_hit " "timer:%d HIT" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , id);
    }
}

static inline void trace_grlib_gptimer_hit(int id)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_hit(id);
    }
}

#define TRACE_GRLIB_GPTIMER_READL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_READL) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_readl(int id, uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_READL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:grlib_gptimer_readl " "timer:%d addr 0x%"PRIx64" 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , id, addr, val);
    }
}

static inline void trace_grlib_gptimer_readl(int id, uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_readl(id, addr, val);
    }
}

#define TRACE_GRLIB_GPTIMER_WRITEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_GPTIMER_WRITEL) || \
    false)

static inline void _nocheck__trace_grlib_gptimer_writel(int id, uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_GRLIB_GPTIMER_WRITEL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:grlib_gptimer_writel " "timer:%d addr 0x%"PRIx64" 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , id, addr, val);
    }
}

static inline void trace_grlib_gptimer_writel(int id, uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_grlib_gptimer_writel(id, addr, val);
    }
}

#define TRACE_LM32_TIMER_MEMORY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_TIMER_MEMORY_WRITE) || \
    false)

static inline void _nocheck__trace_lm32_timer_memory_write(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_TIMER_MEMORY_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_timer_memory_write " "addr 0x%08x value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_lm32_timer_memory_write(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_timer_memory_write(addr, value);
    }
}

#define TRACE_LM32_TIMER_MEMORY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_TIMER_MEMORY_READ) || \
    false)

static inline void _nocheck__trace_lm32_timer_memory_read(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_TIMER_MEMORY_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_timer_memory_read " "addr 0x%08x value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_lm32_timer_memory_read(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_timer_memory_read(addr, value);
    }
}

#define TRACE_LM32_TIMER_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_TIMER_HIT) || \
    false)

static inline void _nocheck__trace_lm32_timer_hit(void)
{
    if (trace_event_get_state(TRACE_LM32_TIMER_HIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_timer_hit " "timer hit" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_lm32_timer_hit(void)
{
    if (true) {
        _nocheck__trace_lm32_timer_hit();
    }
}

#define TRACE_LM32_TIMER_IRQ_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_TIMER_IRQ_STATE) || \
    false)

static inline void _nocheck__trace_lm32_timer_irq_state(int level)
{
    if (trace_event_get_state(TRACE_LM32_TIMER_IRQ_STATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_timer_irq_state " "irq state %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , level);
    }
}

static inline void trace_lm32_timer_irq_state(int level)
{
    if (true) {
        _nocheck__trace_lm32_timer_irq_state(level);
    }
}

#define TRACE_MILKYMIST_SYSCTL_MEMORY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_SYSCTL_MEMORY_READ) || \
    false)

static inline void _nocheck__trace_milkymist_sysctl_memory_read(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_MILKYMIST_SYSCTL_MEMORY_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_sysctl_memory_read " "addr 0x%08x value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_milkymist_sysctl_memory_read(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_milkymist_sysctl_memory_read(addr, value);
    }
}

#define TRACE_MILKYMIST_SYSCTL_MEMORY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_SYSCTL_MEMORY_WRITE) || \
    false)

static inline void _nocheck__trace_milkymist_sysctl_memory_write(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_MILKYMIST_SYSCTL_MEMORY_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_sysctl_memory_write " "addr 0x%08x value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_milkymist_sysctl_memory_write(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_milkymist_sysctl_memory_write(addr, value);
    }
}

#define TRACE_MILKYMIST_SYSCTL_ICAP_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_SYSCTL_ICAP_WRITE) || \
    false)

static inline void _nocheck__trace_milkymist_sysctl_icap_write(uint32_t value)
{
    if (trace_event_get_state(TRACE_MILKYMIST_SYSCTL_ICAP_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_sysctl_icap_write " "value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , value);
    }
}

static inline void trace_milkymist_sysctl_icap_write(uint32_t value)
{
    if (true) {
        _nocheck__trace_milkymist_sysctl_icap_write(value);
    }
}

#define TRACE_MILKYMIST_SYSCTL_START_TIMER0_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_SYSCTL_START_TIMER0) || \
    false)

static inline void _nocheck__trace_milkymist_sysctl_start_timer0(void)
{
    if (trace_event_get_state(TRACE_MILKYMIST_SYSCTL_START_TIMER0)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_sysctl_start_timer0 " "Start timer0" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_milkymist_sysctl_start_timer0(void)
{
    if (true) {
        _nocheck__trace_milkymist_sysctl_start_timer0();
    }
}

#define TRACE_MILKYMIST_SYSCTL_STOP_TIMER0_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_SYSCTL_STOP_TIMER0) || \
    false)

static inline void _nocheck__trace_milkymist_sysctl_stop_timer0(void)
{
    if (trace_event_get_state(TRACE_MILKYMIST_SYSCTL_STOP_TIMER0)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_sysctl_stop_timer0 " "Stop timer0" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_milkymist_sysctl_stop_timer0(void)
{
    if (true) {
        _nocheck__trace_milkymist_sysctl_stop_timer0();
    }
}

#define TRACE_MILKYMIST_SYSCTL_START_TIMER1_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_SYSCTL_START_TIMER1) || \
    false)

static inline void _nocheck__trace_milkymist_sysctl_start_timer1(void)
{
    if (trace_event_get_state(TRACE_MILKYMIST_SYSCTL_START_TIMER1)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_sysctl_start_timer1 " "Start timer1" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_milkymist_sysctl_start_timer1(void)
{
    if (true) {
        _nocheck__trace_milkymist_sysctl_start_timer1();
    }
}

#define TRACE_MILKYMIST_SYSCTL_STOP_TIMER1_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_SYSCTL_STOP_TIMER1) || \
    false)

static inline void _nocheck__trace_milkymist_sysctl_stop_timer1(void)
{
    if (trace_event_get_state(TRACE_MILKYMIST_SYSCTL_STOP_TIMER1)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_sysctl_stop_timer1 " "Stop timer1" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_milkymist_sysctl_stop_timer1(void)
{
    if (true) {
        _nocheck__trace_milkymist_sysctl_stop_timer1();
    }
}

#define TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER0_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER0) || \
    false)

static inline void _nocheck__trace_milkymist_sysctl_pulse_irq_timer0(void)
{
    if (trace_event_get_state(TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER0)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_sysctl_pulse_irq_timer0 " "Pulse IRQ Timer0" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_milkymist_sysctl_pulse_irq_timer0(void)
{
    if (true) {
        _nocheck__trace_milkymist_sysctl_pulse_irq_timer0();
    }
}

#define TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER1_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER1) || \
    false)

static inline void _nocheck__trace_milkymist_sysctl_pulse_irq_timer1(void)
{
    if (trace_event_get_state(TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER1)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_sysctl_pulse_irq_timer1 " "Pulse IRQ Timer1" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_milkymist_sysctl_pulse_irq_timer1(void)
{
    if (true) {
        _nocheck__trace_milkymist_sysctl_pulse_irq_timer1();
    }
}

#define TRACE_ASPEED_TIMER_CTRL_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_CTRL_ENABLE) || \
    false)

static inline void _nocheck__trace_aspeed_timer_ctrl_enable(uint8_t i, bool enable)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_CTRL_ENABLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:aspeed_timer_ctrl_enable " "Timer %" PRIu8 ": %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , i, enable);
    }
}

static inline void trace_aspeed_timer_ctrl_enable(uint8_t i, bool enable)
{
    if (true) {
        _nocheck__trace_aspeed_timer_ctrl_enable(i, enable);
    }
}

#define TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK) || \
    false)

static inline void _nocheck__trace_aspeed_timer_ctrl_external_clock(uint8_t i, bool enable)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_CTRL_EXTERNAL_CLOCK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:aspeed_timer_ctrl_external_clock " "Timer %" PRIu8 ": %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , i, enable);
    }
}

static inline void trace_aspeed_timer_ctrl_external_clock(uint8_t i, bool enable)
{
    if (true) {
        _nocheck__trace_aspeed_timer_ctrl_external_clock(i, enable);
    }
}

#define TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT) || \
    false)

static inline void _nocheck__trace_aspeed_timer_ctrl_overflow_interrupt(uint8_t i, bool enable)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_CTRL_OVERFLOW_INTERRUPT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:aspeed_timer_ctrl_overflow_interrupt " "Timer %" PRIu8 ": %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , i, enable);
    }
}

static inline void trace_aspeed_timer_ctrl_overflow_interrupt(uint8_t i, bool enable)
{
    if (true) {
        _nocheck__trace_aspeed_timer_ctrl_overflow_interrupt(i, enable);
    }
}

#define TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE) || \
    false)

static inline void _nocheck__trace_aspeed_timer_ctrl_pulse_enable(uint8_t i, bool enable)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_CTRL_PULSE_ENABLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:aspeed_timer_ctrl_pulse_enable " "Timer %" PRIu8 ": %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , i, enable);
    }
}

static inline void trace_aspeed_timer_ctrl_pulse_enable(uint8_t i, bool enable)
{
    if (true) {
        _nocheck__trace_aspeed_timer_ctrl_pulse_enable(i, enable);
    }
}

#define TRACE_ASPEED_TIMER_SET_CTRL2_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_SET_CTRL2) || \
    false)

static inline void _nocheck__trace_aspeed_timer_set_ctrl2(uint32_t value)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_SET_CTRL2)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:aspeed_timer_set_ctrl2 " "Value: 0x%" PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , value);
    }
}

static inline void trace_aspeed_timer_set_ctrl2(uint32_t value)
{
    if (true) {
        _nocheck__trace_aspeed_timer_set_ctrl2(value);
    }
}

#define TRACE_ASPEED_TIMER_SET_VALUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_SET_VALUE) || \
    false)

static inline void _nocheck__trace_aspeed_timer_set_value(int timer, int reg, uint32_t value)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_SET_VALUE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:aspeed_timer_set_value " "Timer %d register %d: 0x%" PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , timer, reg, value);
    }
}

static inline void trace_aspeed_timer_set_value(int timer, int reg, uint32_t value)
{
    if (true) {
        _nocheck__trace_aspeed_timer_set_value(timer, reg, value);
    }
}

#define TRACE_ASPEED_TIMER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ASPEED_TIMER_READ) || \
    false)

static inline void _nocheck__trace_aspeed_timer_read(uint64_t offset, unsigned size, uint64_t value)
{
    if (trace_event_get_state(TRACE_ASPEED_TIMER_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:aspeed_timer_read " "From 0x%" PRIx64 ": of size %u: 0x%" PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset, size, value);
    }
}

static inline void trace_aspeed_timer_read(uint64_t offset, unsigned size, uint64_t value)
{
    if (true) {
        _nocheck__trace_aspeed_timer_read(offset, size, value);
    }
}

#define TRACE_SYSTICK_RELOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SYSTICK_RELOAD) || \
    false)

static inline void _nocheck__trace_systick_reload(void)
{
    if (trace_event_get_state(TRACE_SYSTICK_RELOAD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:systick_reload " "systick reload" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_systick_reload(void)
{
    if (true) {
        _nocheck__trace_systick_reload();
    }
}

#define TRACE_SYSTICK_TIMER_TICK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SYSTICK_TIMER_TICK) || \
    false)

static inline void _nocheck__trace_systick_timer_tick(void)
{
    if (trace_event_get_state(TRACE_SYSTICK_TIMER_TICK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:systick_timer_tick " "systick reload" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_systick_timer_tick(void)
{
    if (true) {
        _nocheck__trace_systick_timer_tick();
    }
}

#define TRACE_SYSTICK_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SYSTICK_READ) || \
    false)

static inline void _nocheck__trace_systick_read(uint64_t addr, uint32_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_SYSTICK_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:systick_read " "systick read addr 0x%" PRIx64 " data 0x%" PRIx32 " size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value, size);
    }
}

static inline void trace_systick_read(uint64_t addr, uint32_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_systick_read(addr, value, size);
    }
}

#define TRACE_SYSTICK_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SYSTICK_WRITE) || \
    false)

static inline void _nocheck__trace_systick_write(uint64_t addr, uint32_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_SYSTICK_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:systick_write " "systick write addr 0x%" PRIx64 " data 0x%" PRIx32 " size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value, size);
    }
}

static inline void trace_systick_write(uint64_t addr, uint32_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_systick_write(addr, value, size);
    }
}

#define TRACE_CMSDK_APB_TIMER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_TIMER_READ) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_timer_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_TIMER_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cmsdk_apb_timer_read " "CMSDK APB timer read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset, data, size);
    }
}

static inline void trace_cmsdk_apb_timer_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_timer_read(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_TIMER_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_TIMER_WRITE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_timer_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_TIMER_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cmsdk_apb_timer_write " "CMSDK APB timer write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset, data, size);
    }
}

static inline void trace_cmsdk_apb_timer_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_timer_write(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_TIMER_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_TIMER_RESET) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_timer_reset(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_TIMER_RESET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cmsdk_apb_timer_reset " "CMSDK APB timer: reset" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_cmsdk_apb_timer_reset(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_timer_reset();
    }
}
#endif /* TRACE_HW_TIMER_GENERATED_TRACERS_H */
