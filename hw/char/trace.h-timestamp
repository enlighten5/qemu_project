/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_CHAR_GENERATED_TRACERS_H
#define TRACE_HW_CHAR_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_EVENT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_EVENT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_READL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_LM32_JUART_GET_JTX_EVENT;
extern TraceEvent _TRACE_LM32_JUART_SET_JTX_EVENT;
extern TraceEvent _TRACE_LM32_JUART_GET_JRX_EVENT;
extern TraceEvent _TRACE_LM32_JUART_SET_JRX_EVENT;
extern TraceEvent _TRACE_LM32_UART_MEMORY_WRITE_EVENT;
extern TraceEvent _TRACE_LM32_UART_MEMORY_READ_EVENT;
extern TraceEvent _TRACE_LM32_UART_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_MEMORY_READ_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_MEMORY_WRITE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_RAISE_IRQ_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_LOWER_IRQ_EVENT;
extern TraceEvent _TRACE_ESCC_PUT_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_GET_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_IRQ_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_SERIAL_RECEIVE_BYTE_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_IN_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_OUT_EVENT;
extern TraceEvent _TRACE_ESCC_KBD_COMMAND_EVENT;
extern TraceEvent _TRACE_ESCC_SUNMOUSE_EVENT_EVENT;
extern TraceEvent _TRACE_PL011_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_PL011_READ_EVENT;
extern TraceEvent _TRACE_PL011_READ_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_WRITE_EVENT;
extern TraceEvent _TRACE_PL011_CAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_PL011_PUT_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_PUT_FIFO_FULL_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_READ_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_WRITE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_RESET_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_RECEIVE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_TX_PENDING_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_TX_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_SET_PARAMS_EVENT;
extern uint16_t _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_EVENT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_EVENT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_READL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_LM32_JUART_GET_JTX_DSTATE;
extern uint16_t _TRACE_LM32_JUART_SET_JTX_DSTATE;
extern uint16_t _TRACE_LM32_JUART_GET_JRX_DSTATE;
extern uint16_t _TRACE_LM32_JUART_SET_JRX_DSTATE;
extern uint16_t _TRACE_LM32_UART_MEMORY_WRITE_DSTATE;
extern uint16_t _TRACE_LM32_UART_MEMORY_READ_DSTATE;
extern uint16_t _TRACE_LM32_UART_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_MEMORY_READ_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_MEMORY_WRITE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_RAISE_IRQ_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_LOWER_IRQ_DSTATE;
extern uint16_t _TRACE_ESCC_PUT_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_GET_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_IRQ_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_SERIAL_RECEIVE_BYTE_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_IN_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_OUT_DSTATE;
extern uint16_t _TRACE_ESCC_KBD_COMMAND_DSTATE;
extern uint16_t _TRACE_ESCC_SUNMOUSE_EVENT_DSTATE;
extern uint16_t _TRACE_PL011_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_PL011_READ_DSTATE;
extern uint16_t _TRACE_PL011_READ_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_WRITE_DSTATE;
extern uint16_t _TRACE_PL011_CAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_PL011_PUT_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_PUT_FIFO_FULL_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_READ_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_WRITE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_RESET_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_RECEIVE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_TX_PENDING_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_TX_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_SET_PARAMS_DSTATE;
#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_READ_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_ENABLED 1
#define TRACE_GRLIB_APBUART_EVENT_ENABLED 1
#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_ENABLED 1
#define TRACE_GRLIB_APBUART_READL_UNKNOWN_ENABLED 1
#define TRACE_LM32_JUART_GET_JTX_ENABLED 1
#define TRACE_LM32_JUART_SET_JTX_ENABLED 1
#define TRACE_LM32_JUART_GET_JRX_ENABLED 1
#define TRACE_LM32_JUART_SET_JRX_ENABLED 1
#define TRACE_LM32_UART_MEMORY_WRITE_ENABLED 1
#define TRACE_LM32_UART_MEMORY_READ_ENABLED 1
#define TRACE_LM32_UART_IRQ_STATE_ENABLED 1
#define TRACE_MILKYMIST_UART_MEMORY_READ_ENABLED 1
#define TRACE_MILKYMIST_UART_MEMORY_WRITE_ENABLED 1
#define TRACE_MILKYMIST_UART_RAISE_IRQ_ENABLED 1
#define TRACE_MILKYMIST_UART_LOWER_IRQ_ENABLED 1
#define TRACE_ESCC_PUT_QUEUE_ENABLED 1
#define TRACE_ESCC_GET_QUEUE_ENABLED 1
#define TRACE_ESCC_UPDATE_IRQ_ENABLED 1
#define TRACE_ESCC_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_DATA_ENABLED 1
#define TRACE_ESCC_MEM_READB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_READB_DATA_ENABLED 1
#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_IN_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_OUT_ENABLED 1
#define TRACE_ESCC_KBD_COMMAND_ENABLED 1
#define TRACE_ESCC_SUNMOUSE_EVENT_ENABLED 1
#define TRACE_PL011_IRQ_STATE_ENABLED 1
#define TRACE_PL011_READ_ENABLED 1
#define TRACE_PL011_READ_FIFO_ENABLED 1
#define TRACE_PL011_WRITE_ENABLED 1
#define TRACE_PL011_CAN_RECEIVE_ENABLED 1
#define TRACE_PL011_PUT_FIFO_ENABLED 1
#define TRACE_PL011_PUT_FIFO_FULL_ENABLED 1
#define TRACE_CMSDK_APB_UART_READ_ENABLED 1
#define TRACE_CMSDK_APB_UART_WRITE_ENABLED 1
#define TRACE_CMSDK_APB_UART_RESET_ENABLED 1
#define TRACE_CMSDK_APB_UART_RECEIVE_ENABLED 1
#define TRACE_CMSDK_APB_UART_TX_PENDING_ENABLED 1
#define TRACE_CMSDK_APB_UART_TX_ENABLED 1
#define TRACE_CMSDK_APB_UART_SET_PARAMS_ENABLED 1
#include "qemu/log.h"


#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_serial_send_control_event " "port %u, event %u, value %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , port, event, value);
    }
}

static inline void trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (true) {
        _nocheck__trace_virtio_serial_send_control_event(port, event, value);
    }
}

#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_THROTTLE_PORT) || \
    false)

static inline void _nocheck__trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_THROTTLE_PORT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_serial_throttle_port " "port %u, throttle %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , port, throttle);
    }
}

static inline void trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (true) {
        _nocheck__trace_virtio_serial_throttle_port(port, throttle);
    }
}

#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE) || \
    false)

static inline void _nocheck__trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_serial_handle_control_message " "event %u, value %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , event, value);
    }
}

static inline void trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (true) {
        _nocheck__trace_virtio_serial_handle_control_message(event, value);
    }
}

#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT) || \
    false)

static inline void _nocheck__trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_serial_handle_control_message_port " "port %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , port);
    }
}

static inline void trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (true) {
        _nocheck__trace_virtio_serial_handle_control_message_port(port);
    }
}

#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_FLUSH_BUF) || \
    false)

static inline void _nocheck__trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_FLUSH_BUF)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , port, len, ret);
    }
}

static inline void trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (true) {
        _nocheck__trace_virtio_console_flush_buf(port, len, ret);
    }
}

#define TRACE_VIRTIO_CONSOLE_CHR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_CHR_READ) || \
    false)

static inline void _nocheck__trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_console_chr_read " "port %u, size %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , port, size);
    }
}

static inline void trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (true) {
        _nocheck__trace_virtio_console_chr_read(port, size);
    }
}

#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_CHR_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_EVENT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_console_chr_event " "port %u, event %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , port, event);
    }
}

static inline void trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (true) {
        _nocheck__trace_virtio_console_chr_event(port, event);
    }
}

#define TRACE_GRLIB_APBUART_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_EVENT) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_event(int event)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_EVENT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:grlib_apbuart_event " "event:%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , event);
    }
}

static inline void trace_grlib_apbuart_event(int event)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_event(event);
    }
}

#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_writel_unknown(addr, value);
    }
}

#define TRACE_GRLIB_APBUART_READL_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_READL_UNKNOWN) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_READL_UNKNOWN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:grlib_apbuart_readl_unknown " "addr 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_readl_unknown(addr);
    }
}

#define TRACE_LM32_JUART_GET_JTX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_JUART_GET_JTX) || \
    false)

static inline void _nocheck__trace_lm32_juart_get_jtx(uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_JUART_GET_JTX)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_juart_get_jtx " "jtx 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , value);
    }
}

static inline void trace_lm32_juart_get_jtx(uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_juart_get_jtx(value);
    }
}

#define TRACE_LM32_JUART_SET_JTX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_JUART_SET_JTX) || \
    false)

static inline void _nocheck__trace_lm32_juart_set_jtx(uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_JUART_SET_JTX)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_juart_set_jtx " "jtx 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , value);
    }
}

static inline void trace_lm32_juart_set_jtx(uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_juart_set_jtx(value);
    }
}

#define TRACE_LM32_JUART_GET_JRX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_JUART_GET_JRX) || \
    false)

static inline void _nocheck__trace_lm32_juart_get_jrx(uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_JUART_GET_JRX)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_juart_get_jrx " "jrx 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , value);
    }
}

static inline void trace_lm32_juart_get_jrx(uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_juart_get_jrx(value);
    }
}

#define TRACE_LM32_JUART_SET_JRX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_JUART_SET_JRX) || \
    false)

static inline void _nocheck__trace_lm32_juart_set_jrx(uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_JUART_SET_JRX)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_juart_set_jrx " "jrx 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , value);
    }
}

static inline void trace_lm32_juart_set_jrx(uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_juart_set_jrx(value);
    }
}

#define TRACE_LM32_UART_MEMORY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_UART_MEMORY_WRITE) || \
    false)

static inline void _nocheck__trace_lm32_uart_memory_write(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_UART_MEMORY_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_uart_memory_write " "addr 0x%08x value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_lm32_uart_memory_write(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_uart_memory_write(addr, value);
    }
}

#define TRACE_LM32_UART_MEMORY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_UART_MEMORY_READ) || \
    false)

static inline void _nocheck__trace_lm32_uart_memory_read(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_UART_MEMORY_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_uart_memory_read " "addr 0x%08x value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_lm32_uart_memory_read(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_uart_memory_read(addr, value);
    }
}

#define TRACE_LM32_UART_IRQ_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_UART_IRQ_STATE) || \
    false)

static inline void _nocheck__trace_lm32_uart_irq_state(int level)
{
    if (trace_event_get_state(TRACE_LM32_UART_IRQ_STATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:lm32_uart_irq_state " "irq state %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , level);
    }
}

static inline void trace_lm32_uart_irq_state(int level)
{
    if (true) {
        _nocheck__trace_lm32_uart_irq_state(level);
    }
}

#define TRACE_MILKYMIST_UART_MEMORY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_UART_MEMORY_READ) || \
    false)

static inline void _nocheck__trace_milkymist_uart_memory_read(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_MILKYMIST_UART_MEMORY_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_uart_memory_read " "addr 0x%08x value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_milkymist_uart_memory_read(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_milkymist_uart_memory_read(addr, value);
    }
}

#define TRACE_MILKYMIST_UART_MEMORY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_UART_MEMORY_WRITE) || \
    false)

static inline void _nocheck__trace_milkymist_uart_memory_write(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_MILKYMIST_UART_MEMORY_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_uart_memory_write " "addr 0x%08x value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_milkymist_uart_memory_write(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_milkymist_uart_memory_write(addr, value);
    }
}

#define TRACE_MILKYMIST_UART_RAISE_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_UART_RAISE_IRQ) || \
    false)

static inline void _nocheck__trace_milkymist_uart_raise_irq(void)
{
    if (trace_event_get_state(TRACE_MILKYMIST_UART_RAISE_IRQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_uart_raise_irq " "Raise IRQ" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_milkymist_uart_raise_irq(void)
{
    if (true) {
        _nocheck__trace_milkymist_uart_raise_irq();
    }
}

#define TRACE_MILKYMIST_UART_LOWER_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_UART_LOWER_IRQ) || \
    false)

static inline void _nocheck__trace_milkymist_uart_lower_irq(void)
{
    if (trace_event_get_state(TRACE_MILKYMIST_UART_LOWER_IRQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:milkymist_uart_lower_irq " "Lower IRQ" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_milkymist_uart_lower_irq(void)
{
    if (true) {
        _nocheck__trace_milkymist_uart_lower_irq();
    }
}

#define TRACE_ESCC_PUT_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_PUT_QUEUE) || \
    false)

static inline void _nocheck__trace_escc_put_queue(char channel, int b)
{
    if (trace_event_get_state(TRACE_ESCC_PUT_QUEUE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_put_queue " "channel %c put: 0x%02x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , channel, b);
    }
}

static inline void trace_escc_put_queue(char channel, int b)
{
    if (true) {
        _nocheck__trace_escc_put_queue(channel, b);
    }
}

#define TRACE_ESCC_GET_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_GET_QUEUE) || \
    false)

static inline void _nocheck__trace_escc_get_queue(char channel, int val)
{
    if (trace_event_get_state(TRACE_ESCC_GET_QUEUE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_get_queue " "channel %c get 0x%02x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , channel, val);
    }
}

static inline void trace_escc_get_queue(char channel, int val)
{
    if (true) {
        _nocheck__trace_escc_get_queue(channel, val);
    }
}

#define TRACE_ESCC_UPDATE_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_UPDATE_IRQ) || \
    false)

static inline void _nocheck__trace_escc_update_irq(int irq)
{
    if (trace_event_get_state(TRACE_ESCC_UPDATE_IRQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_update_irq " "IRQ = %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , irq);
    }
}

static inline void trace_escc_update_irq(int irq)
{
    if (true) {
        _nocheck__trace_escc_update_irq(irq);
    }
}

#define TRACE_ESCC_UPDATE_PARAMETERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_UPDATE_PARAMETERS) || \
    false)

static inline void _nocheck__trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (trace_event_get_state(TRACE_ESCC_UPDATE_PARAMETERS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , channel, speed, parity, data_bits, stop_bits);
    }
}

static inline void trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (true) {
        _nocheck__trace_escc_update_parameters(channel, speed, parity, data_bits, stop_bits);
    }
}

#define TRACE_ESCC_MEM_WRITEB_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_WRITEB_CTRL) || \
    false)

static inline void _nocheck__trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_CTRL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = 0x%2.2x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , channel, reg, val);
    }
}

static inline void trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_writeb_ctrl(channel, reg, val);
    }
}

#define TRACE_ESCC_MEM_WRITEB_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_WRITEB_DATA) || \
    false)

static inline void _nocheck__trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_DATA)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_mem_writeb_data " "Write channel %c, ch %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , channel, val);
    }
}

static inline void trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_writeb_data(channel, val);
    }
}

#define TRACE_ESCC_MEM_READB_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_READB_CTRL) || \
    false)

static inline void _nocheck__trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_READB_CTRL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_mem_readb_ctrl " "Read channel %c, reg[%d] = 0x%2.2x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , channel, reg, val);
    }
}

static inline void trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_readb_ctrl(channel, reg, val);
    }
}

#define TRACE_ESCC_MEM_READB_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_READB_DATA) || \
    false)

static inline void _nocheck__trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_READB_DATA)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_mem_readb_data " "Read channel %c, ch %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , channel, ret);
    }
}

static inline void trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (true) {
        _nocheck__trace_escc_mem_readb_data(channel, ret);
    }
}

#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SERIAL_RECEIVE_BYTE) || \
    false)

static inline void _nocheck__trace_escc_serial_receive_byte(char channel, int ch)
{
    if (trace_event_get_state(TRACE_ESCC_SERIAL_RECEIVE_BYTE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_serial_receive_byte " "channel %c put ch %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , channel, ch);
    }
}

static inline void trace_escc_serial_receive_byte(char channel, int ch)
{
    if (true) {
        _nocheck__trace_escc_serial_receive_byte(channel, ch);
    }
}

#define TRACE_ESCC_SUNKBD_EVENT_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNKBD_EVENT_IN) || \
    false)

static inline void _nocheck__trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_IN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_sunkbd_event_in " "QKeyCode 0x%2.2x [%s], down %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ch, name, down);
    }
}

static inline void trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (true) {
        _nocheck__trace_escc_sunkbd_event_in(ch, name, down);
    }
}

#define TRACE_ESCC_SUNKBD_EVENT_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNKBD_EVENT_OUT) || \
    false)

static inline void _nocheck__trace_escc_sunkbd_event_out(int ch)
{
    if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_OUT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_sunkbd_event_out " "Translated keycode 0x%2.2x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ch);
    }
}

static inline void trace_escc_sunkbd_event_out(int ch)
{
    if (true) {
        _nocheck__trace_escc_sunkbd_event_out(ch);
    }
}

#define TRACE_ESCC_KBD_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_KBD_COMMAND) || \
    false)

static inline void _nocheck__trace_escc_kbd_command(int val)
{
    if (trace_event_get_state(TRACE_ESCC_KBD_COMMAND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_kbd_command " "Command %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , val);
    }
}

static inline void trace_escc_kbd_command(int val)
{
    if (true) {
        _nocheck__trace_escc_kbd_command(val);
    }
}

#define TRACE_ESCC_SUNMOUSE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNMOUSE_EVENT) || \
    false)

static inline void _nocheck__trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (trace_event_get_state(TRACE_ESCC_SUNMOUSE_EVENT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:escc_sunmouse_event " "dx=%d dy=%d buttons=0x%01x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , dx, dy, buttons_state);
    }
}

static inline void trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (true) {
        _nocheck__trace_escc_sunmouse_event(dx, dy, buttons_state);
    }
}

#define TRACE_PL011_IRQ_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_IRQ_STATE) || \
    false)

static inline void _nocheck__trace_pl011_irq_state(int level)
{
    if (trace_event_get_state(TRACE_PL011_IRQ_STATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:pl011_irq_state " "irq state %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , level);
    }
}

static inline void trace_pl011_irq_state(int level)
{
    if (true) {
        _nocheck__trace_pl011_irq_state(level);
    }
}

#define TRACE_PL011_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_READ) || \
    false)

static inline void _nocheck__trace_pl011_read(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_PL011_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:pl011_read " "addr 0x%08x value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_pl011_read(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_pl011_read(addr, value);
    }
}

#define TRACE_PL011_READ_FIFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_READ_FIFO) || \
    false)

static inline void _nocheck__trace_pl011_read_fifo(int read_count)
{
    if (trace_event_get_state(TRACE_PL011_READ_FIFO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:pl011_read_fifo " "FIFO read, read_count now %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , read_count);
    }
}

static inline void trace_pl011_read_fifo(int read_count)
{
    if (true) {
        _nocheck__trace_pl011_read_fifo(read_count);
    }
}

#define TRACE_PL011_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_WRITE) || \
    false)

static inline void _nocheck__trace_pl011_write(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_PL011_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:pl011_write " "addr 0x%08x value 0x%08x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, value);
    }
}

static inline void trace_pl011_write(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_pl011_write(addr, value);
    }
}

#define TRACE_PL011_CAN_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_CAN_RECEIVE) || \
    false)

static inline void _nocheck__trace_pl011_can_receive(uint32_t lcr, int read_count, int r)
{
    if (trace_event_get_state(TRACE_PL011_CAN_RECEIVE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:pl011_can_receive " "LCR 0x%08x read_count %d returning %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , lcr, read_count, r);
    }
}

static inline void trace_pl011_can_receive(uint32_t lcr, int read_count, int r)
{
    if (true) {
        _nocheck__trace_pl011_can_receive(lcr, read_count, r);
    }
}

#define TRACE_PL011_PUT_FIFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_PUT_FIFO) || \
    false)

static inline void _nocheck__trace_pl011_put_fifo(uint32_t c, int read_count)
{
    if (trace_event_get_state(TRACE_PL011_PUT_FIFO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:pl011_put_fifo " "new char 0x%x read_count now %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , c, read_count);
    }
}

static inline void trace_pl011_put_fifo(uint32_t c, int read_count)
{
    if (true) {
        _nocheck__trace_pl011_put_fifo(c, read_count);
    }
}

#define TRACE_PL011_PUT_FIFO_FULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_PUT_FIFO_FULL) || \
    false)

static inline void _nocheck__trace_pl011_put_fifo_full(void)
{
    if (trace_event_get_state(TRACE_PL011_PUT_FIFO_FULL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:pl011_put_fifo_full " "FIFO now full, RXFF set" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_pl011_put_fifo_full(void)
{
    if (true) {
        _nocheck__trace_pl011_put_fifo_full();
    }
}

#define TRACE_CMSDK_APB_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_READ) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cmsdk_apb_uart_read " "CMSDK APB UART read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset, data, size);
    }
}

static inline void trace_cmsdk_apb_uart_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_read(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_WRITE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cmsdk_apb_uart_write " "CMSDK APB UART write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset, data, size);
    }
}

static inline void trace_cmsdk_apb_uart_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_write(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_UART_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_RESET) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_reset(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_RESET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cmsdk_apb_uart_reset " "CMSDK APB UART: reset" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_cmsdk_apb_uart_reset(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_reset();
    }
}

#define TRACE_CMSDK_APB_UART_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_RECEIVE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_receive(uint8_t c)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_RECEIVE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cmsdk_apb_uart_receive " "CMSDK APB UART: got character 0x%x from backend" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , c);
    }
}

static inline void trace_cmsdk_apb_uart_receive(uint8_t c)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_receive(c);
    }
}

#define TRACE_CMSDK_APB_UART_TX_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_TX_PENDING) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_tx_pending(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_TX_PENDING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cmsdk_apb_uart_tx_pending " "CMSDK APB UART: character send to backend pending" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_cmsdk_apb_uart_tx_pending(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_tx_pending();
    }
}

#define TRACE_CMSDK_APB_UART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_TX) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_tx(uint8_t c)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_TX)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cmsdk_apb_uart_tx " "CMSDK APB UART: character 0x%x sent to backend" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , c);
    }
}

static inline void trace_cmsdk_apb_uart_tx(uint8_t c)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_tx(c);
    }
}

#define TRACE_CMSDK_APB_UART_SET_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_SET_PARAMS) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_set_params(int speed)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_SET_PARAMS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cmsdk_apb_uart_set_params " "CMSDK APB UART: params set to %d 8N1" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , speed);
    }
}

static inline void trace_cmsdk_apb_uart_set_params(int speed)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_set_params(speed);
    }
}
#endif /* TRACE_HW_CHAR_GENERATED_TRACERS_H */
