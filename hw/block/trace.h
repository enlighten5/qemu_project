/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_BLOCK_GENERATED_TRACERS_H
#define TRACE_HW_BLOCK_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_VIRTIO_BLK_REQ_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_RW_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_WRITE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_LCHS_GUESS_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_GUESS_EVENT;
extern TraceEvent _TRACE_NVME_IRQ_MSIX_EVENT;
extern TraceEvent _TRACE_NVME_IRQ_PIN_EVENT;
extern TraceEvent _TRACE_NVME_IRQ_MASKED_EVENT;
extern TraceEvent _TRACE_NVME_DMA_READ_EVENT;
extern TraceEvent _TRACE_NVME_RW_EVENT;
extern TraceEvent _TRACE_NVME_CREATE_SQ_EVENT;
extern TraceEvent _TRACE_NVME_CREATE_CQ_EVENT;
extern TraceEvent _TRACE_NVME_DEL_SQ_EVENT;
extern TraceEvent _TRACE_NVME_DEL_CQ_EVENT;
extern TraceEvent _TRACE_NVME_IDENTIFY_CTRL_EVENT;
extern TraceEvent _TRACE_NVME_IDENTIFY_NS_EVENT;
extern TraceEvent _TRACE_NVME_IDENTIFY_NSLIST_EVENT;
extern TraceEvent _TRACE_NVME_GETFEAT_VWCACHE_EVENT;
extern TraceEvent _TRACE_NVME_GETFEAT_NUMQ_EVENT;
extern TraceEvent _TRACE_NVME_SETFEAT_NUMQ_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_INTM_SET_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_INTM_CLR_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_CFG_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_AQATTR_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_ASQADDR_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_ACQADDR_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_ASQADDR_HI_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_ACQADDR_HI_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_START_SUCCESS_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_STOPPED_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_SHUTDOWN_SET_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_SHUTDOWN_CLEARED_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_DMA_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_PRPLIST_ENT_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_PRP2_ALIGN_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_PRP2_MISSING_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_FIELD_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_PRP_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_SGL_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_NS_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_OPC_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_ADMIN_OPC_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_LBA_RANGE_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_DEL_SQ_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_CREATE_SQ_CQID_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_CREATE_SQ_SQID_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_CREATE_SQ_SIZE_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_CREATE_SQ_ADDR_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_DEL_CQ_CQID_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_CREATE_CQ_CQID_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_CREATE_CQ_SIZE_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_CREATE_CQ_ADDR_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_CREATE_CQ_VECTOR_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_IDENTIFY_CNS_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_GETFEAT_EVENT;
extern TraceEvent _TRACE_NVME_ERR_INVALID_SETFEAT_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_CQ_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_SQ_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_NBARASQ_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_NBARACQ_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_EVENT;
extern TraceEvent _TRACE_NVME_ERR_STARTFAIL_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIOWR_MISALIGNED32_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIOWR_TOOSMALL_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIOWR_RO_CSTS_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIOWR_CMBLOC_RESERVED_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIOWR_CMBSZ_READONLY_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIOWR_INVALID_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIORD_MISALIGNED32_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIORD_TOOSMALL_EVENT;
extern TraceEvent _TRACE_NVME_UB_MMIORD_INVALID_OFS_EVENT;
extern TraceEvent _TRACE_NVME_UB_DB_WR_MISALIGNED_EVENT;
extern TraceEvent _TRACE_NVME_UB_DB_WR_INVALID_CQ_EVENT;
extern TraceEvent _TRACE_NVME_UB_DB_WR_INVALID_CQHEAD_EVENT;
extern TraceEvent _TRACE_NVME_UB_DB_WR_INVALID_SQ_EVENT;
extern TraceEvent _TRACE_NVME_UB_DB_WR_INVALID_SQTAIL_EVENT;
extern TraceEvent _TRACE_XEN_DISK_ALLOC_EVENT;
extern TraceEvent _TRACE_XEN_DISK_INIT_EVENT;
extern TraceEvent _TRACE_XEN_DISK_CONNECT_EVENT;
extern TraceEvent _TRACE_XEN_DISK_DISCONNECT_EVENT;
extern TraceEvent _TRACE_XEN_DISK_FREE_EVENT;
extern uint16_t _TRACE_VIRTIO_BLK_REQ_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_RW_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_WRITE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_LCHS_GUESS_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_GUESS_DSTATE;
extern uint16_t _TRACE_NVME_IRQ_MSIX_DSTATE;
extern uint16_t _TRACE_NVME_IRQ_PIN_DSTATE;
extern uint16_t _TRACE_NVME_IRQ_MASKED_DSTATE;
extern uint16_t _TRACE_NVME_DMA_READ_DSTATE;
extern uint16_t _TRACE_NVME_RW_DSTATE;
extern uint16_t _TRACE_NVME_CREATE_SQ_DSTATE;
extern uint16_t _TRACE_NVME_CREATE_CQ_DSTATE;
extern uint16_t _TRACE_NVME_DEL_SQ_DSTATE;
extern uint16_t _TRACE_NVME_DEL_CQ_DSTATE;
extern uint16_t _TRACE_NVME_IDENTIFY_CTRL_DSTATE;
extern uint16_t _TRACE_NVME_IDENTIFY_NS_DSTATE;
extern uint16_t _TRACE_NVME_IDENTIFY_NSLIST_DSTATE;
extern uint16_t _TRACE_NVME_GETFEAT_VWCACHE_DSTATE;
extern uint16_t _TRACE_NVME_GETFEAT_NUMQ_DSTATE;
extern uint16_t _TRACE_NVME_SETFEAT_NUMQ_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_INTM_SET_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_INTM_CLR_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_CFG_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_AQATTR_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_ASQADDR_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_ACQADDR_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_ASQADDR_HI_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_ACQADDR_HI_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_START_SUCCESS_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_STOPPED_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_SHUTDOWN_SET_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_SHUTDOWN_CLEARED_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_DMA_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_PRPLIST_ENT_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_PRP2_ALIGN_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_PRP2_MISSING_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_FIELD_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_PRP_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_SGL_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_NS_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_OPC_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_ADMIN_OPC_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_LBA_RANGE_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_DEL_SQ_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_CREATE_SQ_CQID_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_CREATE_SQ_SQID_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_CREATE_SQ_SIZE_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_CREATE_SQ_ADDR_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_DEL_CQ_CQID_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_CREATE_CQ_CQID_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_CREATE_CQ_SIZE_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_CREATE_CQ_ADDR_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_CREATE_CQ_VECTOR_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_IDENTIFY_CNS_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_GETFEAT_DSTATE;
extern uint16_t _TRACE_NVME_ERR_INVALID_SETFEAT_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_CQ_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_SQ_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_NBARASQ_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_NBARACQ_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_DSTATE;
extern uint16_t _TRACE_NVME_ERR_STARTFAIL_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIOWR_MISALIGNED32_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIOWR_TOOSMALL_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIOWR_RO_CSTS_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIOWR_CMBLOC_RESERVED_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIOWR_CMBSZ_READONLY_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIOWR_INVALID_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIORD_MISALIGNED32_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIORD_TOOSMALL_DSTATE;
extern uint16_t _TRACE_NVME_UB_MMIORD_INVALID_OFS_DSTATE;
extern uint16_t _TRACE_NVME_UB_DB_WR_MISALIGNED_DSTATE;
extern uint16_t _TRACE_NVME_UB_DB_WR_INVALID_CQ_DSTATE;
extern uint16_t _TRACE_NVME_UB_DB_WR_INVALID_CQHEAD_DSTATE;
extern uint16_t _TRACE_NVME_UB_DB_WR_INVALID_SQ_DSTATE;
extern uint16_t _TRACE_NVME_UB_DB_WR_INVALID_SQTAIL_DSTATE;
extern uint16_t _TRACE_XEN_DISK_ALLOC_DSTATE;
extern uint16_t _TRACE_XEN_DISK_INIT_DSTATE;
extern uint16_t _TRACE_XEN_DISK_CONNECT_DSTATE;
extern uint16_t _TRACE_XEN_DISK_DISCONNECT_DSTATE;
extern uint16_t _TRACE_XEN_DISK_FREE_DSTATE;
#define TRACE_VIRTIO_BLK_REQ_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_RW_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_WRITE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_READ_ENABLED 1
#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_ENABLED 1
#define TRACE_HD_GEOMETRY_LCHS_GUESS_ENABLED 1
#define TRACE_HD_GEOMETRY_GUESS_ENABLED 1
#define TRACE_NVME_IRQ_MSIX_ENABLED 1
#define TRACE_NVME_IRQ_PIN_ENABLED 1
#define TRACE_NVME_IRQ_MASKED_ENABLED 1
#define TRACE_NVME_DMA_READ_ENABLED 1
#define TRACE_NVME_RW_ENABLED 1
#define TRACE_NVME_CREATE_SQ_ENABLED 1
#define TRACE_NVME_CREATE_CQ_ENABLED 1
#define TRACE_NVME_DEL_SQ_ENABLED 1
#define TRACE_NVME_DEL_CQ_ENABLED 1
#define TRACE_NVME_IDENTIFY_CTRL_ENABLED 1
#define TRACE_NVME_IDENTIFY_NS_ENABLED 1
#define TRACE_NVME_IDENTIFY_NSLIST_ENABLED 1
#define TRACE_NVME_GETFEAT_VWCACHE_ENABLED 1
#define TRACE_NVME_GETFEAT_NUMQ_ENABLED 1
#define TRACE_NVME_SETFEAT_NUMQ_ENABLED 1
#define TRACE_NVME_MMIO_INTM_SET_ENABLED 1
#define TRACE_NVME_MMIO_INTM_CLR_ENABLED 1
#define TRACE_NVME_MMIO_CFG_ENABLED 1
#define TRACE_NVME_MMIO_AQATTR_ENABLED 1
#define TRACE_NVME_MMIO_ASQADDR_ENABLED 1
#define TRACE_NVME_MMIO_ACQADDR_ENABLED 1
#define TRACE_NVME_MMIO_ASQADDR_HI_ENABLED 1
#define TRACE_NVME_MMIO_ACQADDR_HI_ENABLED 1
#define TRACE_NVME_MMIO_START_SUCCESS_ENABLED 1
#define TRACE_NVME_MMIO_STOPPED_ENABLED 1
#define TRACE_NVME_MMIO_SHUTDOWN_SET_ENABLED 1
#define TRACE_NVME_MMIO_SHUTDOWN_CLEARED_ENABLED 1
#define TRACE_NVME_ERR_INVALID_DMA_ENABLED 1
#define TRACE_NVME_ERR_INVALID_PRPLIST_ENT_ENABLED 1
#define TRACE_NVME_ERR_INVALID_PRP2_ALIGN_ENABLED 1
#define TRACE_NVME_ERR_INVALID_PRP2_MISSING_ENABLED 1
#define TRACE_NVME_ERR_INVALID_FIELD_ENABLED 1
#define TRACE_NVME_ERR_INVALID_PRP_ENABLED 1
#define TRACE_NVME_ERR_INVALID_SGL_ENABLED 1
#define TRACE_NVME_ERR_INVALID_NS_ENABLED 1
#define TRACE_NVME_ERR_INVALID_OPC_ENABLED 1
#define TRACE_NVME_ERR_INVALID_ADMIN_OPC_ENABLED 1
#define TRACE_NVME_ERR_INVALID_LBA_RANGE_ENABLED 1
#define TRACE_NVME_ERR_INVALID_DEL_SQ_ENABLED 1
#define TRACE_NVME_ERR_INVALID_CREATE_SQ_CQID_ENABLED 1
#define TRACE_NVME_ERR_INVALID_CREATE_SQ_SQID_ENABLED 1
#define TRACE_NVME_ERR_INVALID_CREATE_SQ_SIZE_ENABLED 1
#define TRACE_NVME_ERR_INVALID_CREATE_SQ_ADDR_ENABLED 1
#define TRACE_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_ENABLED 1
#define TRACE_NVME_ERR_INVALID_DEL_CQ_CQID_ENABLED 1
#define TRACE_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_ENABLED 1
#define TRACE_NVME_ERR_INVALID_CREATE_CQ_CQID_ENABLED 1
#define TRACE_NVME_ERR_INVALID_CREATE_CQ_SIZE_ENABLED 1
#define TRACE_NVME_ERR_INVALID_CREATE_CQ_ADDR_ENABLED 1
#define TRACE_NVME_ERR_INVALID_CREATE_CQ_VECTOR_ENABLED 1
#define TRACE_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_ENABLED 1
#define TRACE_NVME_ERR_INVALID_IDENTIFY_CNS_ENABLED 1
#define TRACE_NVME_ERR_INVALID_GETFEAT_ENABLED 1
#define TRACE_NVME_ERR_INVALID_SETFEAT_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_CQ_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_SQ_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_NBARASQ_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_NBARACQ_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_ENABLED 1
#define TRACE_NVME_ERR_STARTFAIL_ENABLED 1
#define TRACE_NVME_UB_MMIOWR_MISALIGNED32_ENABLED 1
#define TRACE_NVME_UB_MMIOWR_TOOSMALL_ENABLED 1
#define TRACE_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_ENABLED 1
#define TRACE_NVME_UB_MMIOWR_RO_CSTS_ENABLED 1
#define TRACE_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_ENABLED 1
#define TRACE_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_ENABLED 1
#define TRACE_NVME_UB_MMIOWR_CMBLOC_RESERVED_ENABLED 1
#define TRACE_NVME_UB_MMIOWR_CMBSZ_READONLY_ENABLED 1
#define TRACE_NVME_UB_MMIOWR_INVALID_ENABLED 1
#define TRACE_NVME_UB_MMIORD_MISALIGNED32_ENABLED 1
#define TRACE_NVME_UB_MMIORD_TOOSMALL_ENABLED 1
#define TRACE_NVME_UB_MMIORD_INVALID_OFS_ENABLED 1
#define TRACE_NVME_UB_DB_WR_MISALIGNED_ENABLED 1
#define TRACE_NVME_UB_DB_WR_INVALID_CQ_ENABLED 1
#define TRACE_NVME_UB_DB_WR_INVALID_CQHEAD_ENABLED 1
#define TRACE_NVME_UB_DB_WR_INVALID_SQ_ENABLED 1
#define TRACE_NVME_UB_DB_WR_INVALID_SQTAIL_ENABLED 1
#define TRACE_XEN_DISK_ALLOC_ENABLED 1
#define TRACE_XEN_DISK_INIT_ENABLED 1
#define TRACE_XEN_DISK_CONNECT_ENABLED 1
#define TRACE_XEN_DISK_DISCONNECT_ENABLED 1
#define TRACE_XEN_DISK_FREE_ENABLED 1
#include "qemu/log.h"


#define TRACE_VIRTIO_BLK_REQ_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_REQ_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_req_complete(void * vdev, void * req, int status)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_REQ_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_blk_req_complete " "vdev %p req %p status %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , vdev, req, status);
    }
}

static inline void trace_virtio_blk_req_complete(void * vdev, void * req, int status)
{
    if (true) {
        _nocheck__trace_virtio_blk_req_complete(vdev, req, status);
    }
}

#define TRACE_VIRTIO_BLK_RW_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_RW_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_rw_complete(void * vdev, void * req, int ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_RW_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_blk_rw_complete " "vdev %p req %p ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , vdev, req, ret);
    }
}

static inline void trace_virtio_blk_rw_complete(void * vdev, void * req, int ret)
{
    if (true) {
        _nocheck__trace_virtio_blk_rw_complete(vdev, req, ret);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_WRITE) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_write(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_blk_handle_write " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , vdev, req, sector, nsectors);
    }
}

static inline void trace_virtio_blk_handle_write(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_write(vdev, req, sector, nsectors);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_READ) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_read(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_blk_handle_read " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , vdev, req, sector, nsectors);
    }
}

static inline void trace_virtio_blk_handle_read(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_read(vdev, req, sector, nsectors);
    }
}

#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ) || \
    false)

static inline void _nocheck__trace_virtio_blk_submit_multireq(void * vdev, void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:virtio_blk_submit_multireq " "vdev %p mrb %p start %d num_reqs %d offset %"PRIu64" size %zu is_write %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , vdev, mrb, start, num_reqs, offset, size, is_write);
    }
}

static inline void trace_virtio_blk_submit_multireq(void * vdev, void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (true) {
        _nocheck__trace_virtio_blk_submit_multireq(vdev, mrb, start, num_reqs, offset, size, is_write);
    }
}

#define TRACE_HD_GEOMETRY_LCHS_GUESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HD_GEOMETRY_LCHS_GUESS) || \
    false)

static inline void _nocheck__trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (trace_event_get_state(TRACE_HD_GEOMETRY_LCHS_GUESS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:hd_geometry_lchs_guess " "blk %p LCHS %d %d %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , blk, cyls, heads, secs);
    }
}

static inline void trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (true) {
        _nocheck__trace_hd_geometry_lchs_guess(blk, cyls, heads, secs);
    }
}

#define TRACE_HD_GEOMETRY_GUESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HD_GEOMETRY_GUESS) || \
    false)

static inline void _nocheck__trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (trace_event_get_state(TRACE_HD_GEOMETRY_GUESS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:hd_geometry_guess " "blk %p CHS %u %u %u trans %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , blk, cyls, heads, secs, trans);
    }
}

static inline void trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (true) {
        _nocheck__trace_hd_geometry_guess(blk, cyls, heads, secs, trans);
    }
}

#define TRACE_NVME_IRQ_MSIX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_IRQ_MSIX) || \
    false)

static inline void _nocheck__trace_nvme_irq_msix(uint32_t vector)
{
    if (trace_event_get_state(TRACE_NVME_IRQ_MSIX)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_irq_msix " "raising MSI-X IRQ vector %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , vector);
    }
}

static inline void trace_nvme_irq_msix(uint32_t vector)
{
    if (true) {
        _nocheck__trace_nvme_irq_msix(vector);
    }
}

#define TRACE_NVME_IRQ_PIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_IRQ_PIN) || \
    false)

static inline void _nocheck__trace_nvme_irq_pin(void)
{
    if (trace_event_get_state(TRACE_NVME_IRQ_PIN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_irq_pin " "pulsing IRQ pin" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_irq_pin(void)
{
    if (true) {
        _nocheck__trace_nvme_irq_pin();
    }
}

#define TRACE_NVME_IRQ_MASKED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_IRQ_MASKED) || \
    false)

static inline void _nocheck__trace_nvme_irq_masked(void)
{
    if (trace_event_get_state(TRACE_NVME_IRQ_MASKED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_irq_masked " "IRQ is masked" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_irq_masked(void)
{
    if (true) {
        _nocheck__trace_nvme_irq_masked();
    }
}

#define TRACE_NVME_DMA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_DMA_READ) || \
    false)

static inline void _nocheck__trace_nvme_dma_read(uint64_t prp1, uint64_t prp2)
{
    if (trace_event_get_state(TRACE_NVME_DMA_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_dma_read " "DMA read, prp1=0x%"PRIx64" prp2=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , prp1, prp2);
    }
}

static inline void trace_nvme_dma_read(uint64_t prp1, uint64_t prp2)
{
    if (true) {
        _nocheck__trace_nvme_dma_read(prp1, prp2);
    }
}

#define TRACE_NVME_RW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_RW) || \
    false)

static inline void _nocheck__trace_nvme_rw(const char * verb, uint32_t blk_count, uint64_t byte_count, uint64_t lba)
{
    if (trace_event_get_state(TRACE_NVME_RW)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_rw " "%s %"PRIu32" blocks (%"PRIu64" bytes) from LBA %"PRIu64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , verb, blk_count, byte_count, lba);
    }
}

static inline void trace_nvme_rw(const char * verb, uint32_t blk_count, uint64_t byte_count, uint64_t lba)
{
    if (true) {
        _nocheck__trace_nvme_rw(verb, blk_count, byte_count, lba);
    }
}

#define TRACE_NVME_CREATE_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CREATE_SQ) || \
    false)

static inline void _nocheck__trace_nvme_create_sq(uint64_t addr, uint16_t sqid, uint16_t cqid, uint16_t qsize, uint16_t qflags)
{
    if (trace_event_get_state(TRACE_NVME_CREATE_SQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_create_sq " "create submission queue, addr=0x%"PRIx64", sqid=%"PRIu16", cqid=%"PRIu16", qsize=%"PRIu16", qflags=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, sqid, cqid, qsize, qflags);
    }
}

static inline void trace_nvme_create_sq(uint64_t addr, uint16_t sqid, uint16_t cqid, uint16_t qsize, uint16_t qflags)
{
    if (true) {
        _nocheck__trace_nvme_create_sq(addr, sqid, cqid, qsize, qflags);
    }
}

#define TRACE_NVME_CREATE_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CREATE_CQ) || \
    false)

static inline void _nocheck__trace_nvme_create_cq(uint64_t addr, uint16_t cqid, uint16_t vector, uint16_t size, uint16_t qflags, int ien)
{
    if (trace_event_get_state(TRACE_NVME_CREATE_CQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_create_cq " "create completion queue, addr=0x%"PRIx64", cqid=%"PRIu16", vector=%"PRIu16", qsize=%"PRIu16", qflags=%"PRIu16", ien=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, cqid, vector, size, qflags, ien);
    }
}

static inline void trace_nvme_create_cq(uint64_t addr, uint16_t cqid, uint16_t vector, uint16_t size, uint16_t qflags, int ien)
{
    if (true) {
        _nocheck__trace_nvme_create_cq(addr, cqid, vector, size, qflags, ien);
    }
}

#define TRACE_NVME_DEL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_DEL_SQ) || \
    false)

static inline void _nocheck__trace_nvme_del_sq(uint16_t qid)
{
    if (trace_event_get_state(TRACE_NVME_DEL_SQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_del_sq " "deleting submission queue sqid=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , qid);
    }
}

static inline void trace_nvme_del_sq(uint16_t qid)
{
    if (true) {
        _nocheck__trace_nvme_del_sq(qid);
    }
}

#define TRACE_NVME_DEL_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_DEL_CQ) || \
    false)

static inline void _nocheck__trace_nvme_del_cq(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_NVME_DEL_CQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_del_cq " "deleted completion queue, sqid=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cqid);
    }
}

static inline void trace_nvme_del_cq(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_nvme_del_cq(cqid);
    }
}

#define TRACE_NVME_IDENTIFY_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_IDENTIFY_CTRL) || \
    false)

static inline void _nocheck__trace_nvme_identify_ctrl(void)
{
    if (trace_event_get_state(TRACE_NVME_IDENTIFY_CTRL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_identify_ctrl " "identify controller" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_identify_ctrl(void)
{
    if (true) {
        _nocheck__trace_nvme_identify_ctrl();
    }
}

#define TRACE_NVME_IDENTIFY_NS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_IDENTIFY_NS) || \
    false)

static inline void _nocheck__trace_nvme_identify_ns(uint16_t ns)
{
    if (trace_event_get_state(TRACE_NVME_IDENTIFY_NS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_identify_ns " "identify namespace, nsid=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ns);
    }
}

static inline void trace_nvme_identify_ns(uint16_t ns)
{
    if (true) {
        _nocheck__trace_nvme_identify_ns(ns);
    }
}

#define TRACE_NVME_IDENTIFY_NSLIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_IDENTIFY_NSLIST) || \
    false)

static inline void _nocheck__trace_nvme_identify_nslist(uint16_t ns)
{
    if (trace_event_get_state(TRACE_NVME_IDENTIFY_NSLIST)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_identify_nslist " "identify namespace list, nsid=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ns);
    }
}

static inline void trace_nvme_identify_nslist(uint16_t ns)
{
    if (true) {
        _nocheck__trace_nvme_identify_nslist(ns);
    }
}

#define TRACE_NVME_GETFEAT_VWCACHE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_GETFEAT_VWCACHE) || \
    false)

static inline void _nocheck__trace_nvme_getfeat_vwcache(const char* result)
{
    if (trace_event_get_state(TRACE_NVME_GETFEAT_VWCACHE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_getfeat_vwcache " "get feature volatile write cache, result=%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , result);
    }
}

static inline void trace_nvme_getfeat_vwcache(const char* result)
{
    if (true) {
        _nocheck__trace_nvme_getfeat_vwcache(result);
    }
}

#define TRACE_NVME_GETFEAT_NUMQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_GETFEAT_NUMQ) || \
    false)

static inline void _nocheck__trace_nvme_getfeat_numq(int result)
{
    if (trace_event_get_state(TRACE_NVME_GETFEAT_NUMQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_getfeat_numq " "get feature number of queues, result=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , result);
    }
}

static inline void trace_nvme_getfeat_numq(int result)
{
    if (true) {
        _nocheck__trace_nvme_getfeat_numq(result);
    }
}

#define TRACE_NVME_SETFEAT_NUMQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_SETFEAT_NUMQ) || \
    false)

static inline void _nocheck__trace_nvme_setfeat_numq(int reqcq, int reqsq, int gotcq, int gotsq)
{
    if (trace_event_get_state(TRACE_NVME_SETFEAT_NUMQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_setfeat_numq " "requested cq_count=%d sq_count=%d, responding with cq_count=%d sq_count=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , reqcq, reqsq, gotcq, gotsq);
    }
}

static inline void trace_nvme_setfeat_numq(int reqcq, int reqsq, int gotcq, int gotsq)
{
    if (true) {
        _nocheck__trace_nvme_setfeat_numq(reqcq, reqsq, gotcq, gotsq);
    }
}

#define TRACE_NVME_MMIO_INTM_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_INTM_SET) || \
    false)

static inline void _nocheck__trace_nvme_mmio_intm_set(uint64_t data, uint64_t new_mask)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_INTM_SET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_intm_set " "wrote MMIO, interrupt mask set, data=0x%"PRIx64", new_mask=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , data, new_mask);
    }
}

static inline void trace_nvme_mmio_intm_set(uint64_t data, uint64_t new_mask)
{
    if (true) {
        _nocheck__trace_nvme_mmio_intm_set(data, new_mask);
    }
}

#define TRACE_NVME_MMIO_INTM_CLR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_INTM_CLR) || \
    false)

static inline void _nocheck__trace_nvme_mmio_intm_clr(uint64_t data, uint64_t new_mask)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_INTM_CLR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_intm_clr " "wrote MMIO, interrupt mask clr, data=0x%"PRIx64", new_mask=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , data, new_mask);
    }
}

static inline void trace_nvme_mmio_intm_clr(uint64_t data, uint64_t new_mask)
{
    if (true) {
        _nocheck__trace_nvme_mmio_intm_clr(data, new_mask);
    }
}

#define TRACE_NVME_MMIO_CFG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_CFG) || \
    false)

static inline void _nocheck__trace_nvme_mmio_cfg(uint64_t data)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_CFG)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_cfg " "wrote MMIO, config controller config=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , data);
    }
}

static inline void trace_nvme_mmio_cfg(uint64_t data)
{
    if (true) {
        _nocheck__trace_nvme_mmio_cfg(data);
    }
}

#define TRACE_NVME_MMIO_AQATTR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_AQATTR) || \
    false)

static inline void _nocheck__trace_nvme_mmio_aqattr(uint64_t data)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_AQATTR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_aqattr " "wrote MMIO, admin queue attributes=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , data);
    }
}

static inline void trace_nvme_mmio_aqattr(uint64_t data)
{
    if (true) {
        _nocheck__trace_nvme_mmio_aqattr(data);
    }
}

#define TRACE_NVME_MMIO_ASQADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_ASQADDR) || \
    false)

static inline void _nocheck__trace_nvme_mmio_asqaddr(uint64_t data)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_ASQADDR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_asqaddr " "wrote MMIO, admin submission queue address=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , data);
    }
}

static inline void trace_nvme_mmio_asqaddr(uint64_t data)
{
    if (true) {
        _nocheck__trace_nvme_mmio_asqaddr(data);
    }
}

#define TRACE_NVME_MMIO_ACQADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_ACQADDR) || \
    false)

static inline void _nocheck__trace_nvme_mmio_acqaddr(uint64_t data)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_ACQADDR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_acqaddr " "wrote MMIO, admin completion queue address=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , data);
    }
}

static inline void trace_nvme_mmio_acqaddr(uint64_t data)
{
    if (true) {
        _nocheck__trace_nvme_mmio_acqaddr(data);
    }
}

#define TRACE_NVME_MMIO_ASQADDR_HI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_ASQADDR_HI) || \
    false)

static inline void _nocheck__trace_nvme_mmio_asqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_ASQADDR_HI)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_asqaddr_hi " "wrote MMIO, admin submission queue high half=0x%"PRIx64", new_address=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , data, new_addr);
    }
}

static inline void trace_nvme_mmio_asqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (true) {
        _nocheck__trace_nvme_mmio_asqaddr_hi(data, new_addr);
    }
}

#define TRACE_NVME_MMIO_ACQADDR_HI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_ACQADDR_HI) || \
    false)

static inline void _nocheck__trace_nvme_mmio_acqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_ACQADDR_HI)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_acqaddr_hi " "wrote MMIO, admin completion queue high half=0x%"PRIx64", new_address=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , data, new_addr);
    }
}

static inline void trace_nvme_mmio_acqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (true) {
        _nocheck__trace_nvme_mmio_acqaddr_hi(data, new_addr);
    }
}

#define TRACE_NVME_MMIO_START_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_START_SUCCESS) || \
    false)

static inline void _nocheck__trace_nvme_mmio_start_success(void)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_START_SUCCESS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_start_success " "setting controller enable bit succeeded" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_mmio_start_success(void)
{
    if (true) {
        _nocheck__trace_nvme_mmio_start_success();
    }
}

#define TRACE_NVME_MMIO_STOPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_STOPPED) || \
    false)

static inline void _nocheck__trace_nvme_mmio_stopped(void)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_STOPPED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_stopped " "cleared controller enable bit" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_mmio_stopped(void)
{
    if (true) {
        _nocheck__trace_nvme_mmio_stopped();
    }
}

#define TRACE_NVME_MMIO_SHUTDOWN_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_SHUTDOWN_SET) || \
    false)

static inline void _nocheck__trace_nvme_mmio_shutdown_set(void)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_SHUTDOWN_SET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_shutdown_set " "shutdown bit set" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_mmio_shutdown_set(void)
{
    if (true) {
        _nocheck__trace_nvme_mmio_shutdown_set();
    }
}

#define TRACE_NVME_MMIO_SHUTDOWN_CLEARED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_MMIO_SHUTDOWN_CLEARED) || \
    false)

static inline void _nocheck__trace_nvme_mmio_shutdown_cleared(void)
{
    if (trace_event_get_state(TRACE_NVME_MMIO_SHUTDOWN_CLEARED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_mmio_shutdown_cleared " "shutdown bit cleared" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_mmio_shutdown_cleared(void)
{
    if (true) {
        _nocheck__trace_nvme_mmio_shutdown_cleared();
    }
}

#define TRACE_NVME_ERR_INVALID_DMA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_DMA) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_dma(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_DMA)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_dma " "PRP/SGL is too small for transfer size" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_invalid_dma(void)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_dma();
    }
}

#define TRACE_NVME_ERR_INVALID_PRPLIST_ENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_PRPLIST_ENT) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_prplist_ent(uint64_t prplist)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_PRPLIST_ENT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_prplist_ent " "PRP list entry is null or not page aligned: 0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , prplist);
    }
}

static inline void trace_nvme_err_invalid_prplist_ent(uint64_t prplist)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_prplist_ent(prplist);
    }
}

#define TRACE_NVME_ERR_INVALID_PRP2_ALIGN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_PRP2_ALIGN) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_prp2_align(uint64_t prp2)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_PRP2_ALIGN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_prp2_align " "PRP2 is not page aligned: 0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , prp2);
    }
}

static inline void trace_nvme_err_invalid_prp2_align(uint64_t prp2)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_prp2_align(prp2);
    }
}

#define TRACE_NVME_ERR_INVALID_PRP2_MISSING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_PRP2_MISSING) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_prp2_missing(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_PRP2_MISSING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_prp2_missing " "PRP2 is null and more data to be transferred" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_invalid_prp2_missing(void)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_prp2_missing();
    }
}

#define TRACE_NVME_ERR_INVALID_FIELD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_FIELD) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_field(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_FIELD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_field " "invalid field" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_invalid_field(void)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_field();
    }
}

#define TRACE_NVME_ERR_INVALID_PRP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_PRP) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_prp(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_PRP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_prp " "invalid PRP" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_invalid_prp(void)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_prp();
    }
}

#define TRACE_NVME_ERR_INVALID_SGL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_SGL) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_sgl(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_SGL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_sgl " "invalid SGL" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_invalid_sgl(void)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_sgl();
    }
}

#define TRACE_NVME_ERR_INVALID_NS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_NS) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_ns(uint32_t ns, uint32_t limit)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_NS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_ns " "invalid namespace %u not within 1-%u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ns, limit);
    }
}

static inline void trace_nvme_err_invalid_ns(uint32_t ns, uint32_t limit)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_ns(ns, limit);
    }
}

#define TRACE_NVME_ERR_INVALID_OPC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_OPC) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_opc(uint8_t opc)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_OPC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_opc " "invalid opcode 0x%"PRIx8"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , opc);
    }
}

static inline void trace_nvme_err_invalid_opc(uint8_t opc)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_opc(opc);
    }
}

#define TRACE_NVME_ERR_INVALID_ADMIN_OPC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_ADMIN_OPC) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_admin_opc(uint8_t opc)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_ADMIN_OPC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_admin_opc " "invalid admin opcode 0x%"PRIx8"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , opc);
    }
}

static inline void trace_nvme_err_invalid_admin_opc(uint8_t opc)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_admin_opc(opc);
    }
}

#define TRACE_NVME_ERR_INVALID_LBA_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_LBA_RANGE) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_lba_range(uint64_t start, uint64_t len, uint64_t limit)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_LBA_RANGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_lba_range " "Invalid LBA start=%"PRIu64" len=%"PRIu64" limit=%"PRIu64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , start, len, limit);
    }
}

static inline void trace_nvme_err_invalid_lba_range(uint64_t start, uint64_t len, uint64_t limit)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_lba_range(start, len, limit);
    }
}

#define TRACE_NVME_ERR_INVALID_DEL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_DEL_SQ) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_del_sq(uint16_t qid)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_DEL_SQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_del_sq " "invalid submission queue deletion, sid=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , qid);
    }
}

static inline void trace_nvme_err_invalid_del_sq(uint16_t qid)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_del_sq(qid);
    }
}

#define TRACE_NVME_ERR_INVALID_CREATE_SQ_CQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_CREATE_SQ_CQID) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_create_sq_cqid(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_CREATE_SQ_CQID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_create_sq_cqid " "failed creating submission queue, invalid cqid=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cqid);
    }
}

static inline void trace_nvme_err_invalid_create_sq_cqid(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_create_sq_cqid(cqid);
    }
}

#define TRACE_NVME_ERR_INVALID_CREATE_SQ_SQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_CREATE_SQ_SQID) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_create_sq_sqid(uint16_t sqid)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_CREATE_SQ_SQID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_create_sq_sqid " "failed creating submission queue, invalid sqid=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sqid);
    }
}

static inline void trace_nvme_err_invalid_create_sq_sqid(uint16_t sqid)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_create_sq_sqid(sqid);
    }
}

#define TRACE_NVME_ERR_INVALID_CREATE_SQ_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_CREATE_SQ_SIZE) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_create_sq_size(uint16_t qsize)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_CREATE_SQ_SIZE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_create_sq_size " "failed creating submission queue, invalid qsize=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , qsize);
    }
}

static inline void trace_nvme_err_invalid_create_sq_size(uint16_t qsize)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_create_sq_size(qsize);
    }
}

#define TRACE_NVME_ERR_INVALID_CREATE_SQ_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_CREATE_SQ_ADDR) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_create_sq_addr(uint64_t addr)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_CREATE_SQ_ADDR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_create_sq_addr " "failed creating submission queue, addr=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_nvme_err_invalid_create_sq_addr(uint64_t addr)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_create_sq_addr(addr);
    }
}

#define TRACE_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_CREATE_SQ_QFLAGS) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_create_sq_qflags(uint16_t qflags)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_CREATE_SQ_QFLAGS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_create_sq_qflags " "failed creating submission queue, qflags=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , qflags);
    }
}

static inline void trace_nvme_err_invalid_create_sq_qflags(uint16_t qflags)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_create_sq_qflags(qflags);
    }
}

#define TRACE_NVME_ERR_INVALID_DEL_CQ_CQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_DEL_CQ_CQID) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_del_cq_cqid(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_DEL_CQ_CQID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_del_cq_cqid " "failed deleting completion queue, cqid=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cqid);
    }
}

static inline void trace_nvme_err_invalid_del_cq_cqid(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_del_cq_cqid(cqid);
    }
}

#define TRACE_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_del_cq_notempty(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_del_cq_notempty " "failed deleting completion queue, it is not empty, cqid=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cqid);
    }
}

static inline void trace_nvme_err_invalid_del_cq_notempty(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_del_cq_notempty(cqid);
    }
}

#define TRACE_NVME_ERR_INVALID_CREATE_CQ_CQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_CREATE_CQ_CQID) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_create_cq_cqid(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_CREATE_CQ_CQID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_create_cq_cqid " "failed creating completion queue, cqid=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cqid);
    }
}

static inline void trace_nvme_err_invalid_create_cq_cqid(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_create_cq_cqid(cqid);
    }
}

#define TRACE_NVME_ERR_INVALID_CREATE_CQ_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_CREATE_CQ_SIZE) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_create_cq_size(uint16_t size)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_CREATE_CQ_SIZE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_create_cq_size " "failed creating completion queue, size=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , size);
    }
}

static inline void trace_nvme_err_invalid_create_cq_size(uint16_t size)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_create_cq_size(size);
    }
}

#define TRACE_NVME_ERR_INVALID_CREATE_CQ_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_CREATE_CQ_ADDR) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_create_cq_addr(uint64_t addr)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_CREATE_CQ_ADDR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_create_cq_addr " "failed creating completion queue, addr=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_nvme_err_invalid_create_cq_addr(uint64_t addr)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_create_cq_addr(addr);
    }
}

#define TRACE_NVME_ERR_INVALID_CREATE_CQ_VECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_CREATE_CQ_VECTOR) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_create_cq_vector(uint16_t vector)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_CREATE_CQ_VECTOR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_create_cq_vector " "failed creating completion queue, vector=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , vector);
    }
}

static inline void trace_nvme_err_invalid_create_cq_vector(uint16_t vector)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_create_cq_vector(vector);
    }
}

#define TRACE_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_CREATE_CQ_QFLAGS) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_create_cq_qflags(uint16_t qflags)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_CREATE_CQ_QFLAGS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_create_cq_qflags " "failed creating completion queue, qflags=%"PRIu16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , qflags);
    }
}

static inline void trace_nvme_err_invalid_create_cq_qflags(uint16_t qflags)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_create_cq_qflags(qflags);
    }
}

#define TRACE_NVME_ERR_INVALID_IDENTIFY_CNS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_IDENTIFY_CNS) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_identify_cns(uint16_t cns)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_IDENTIFY_CNS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_identify_cns " "identify, invalid cns=0x%"PRIx16"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cns);
    }
}

static inline void trace_nvme_err_invalid_identify_cns(uint16_t cns)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_identify_cns(cns);
    }
}

#define TRACE_NVME_ERR_INVALID_GETFEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_GETFEAT) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_getfeat(int dw10)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_GETFEAT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_getfeat " "invalid get features, dw10=0x%"PRIx32"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , dw10);
    }
}

static inline void trace_nvme_err_invalid_getfeat(int dw10)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_getfeat(dw10);
    }
}

#define TRACE_NVME_ERR_INVALID_SETFEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_INVALID_SETFEAT) || \
    false)

static inline void _nocheck__trace_nvme_err_invalid_setfeat(uint32_t dw10)
{
    if (trace_event_get_state(TRACE_NVME_ERR_INVALID_SETFEAT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_invalid_setfeat " "invalid set features, dw10=0x%"PRIx32"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , dw10);
    }
}

static inline void trace_nvme_err_invalid_setfeat(uint32_t dw10)
{
    if (true) {
        _nocheck__trace_nvme_err_invalid_setfeat(dw10);
    }
}

#define TRACE_NVME_ERR_STARTFAIL_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_CQ) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_cq(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_CQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_cq " "nvme_start_ctrl failed because there are non-admin completion queues" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_startfail_cq(void)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_cq();
    }
}

#define TRACE_NVME_ERR_STARTFAIL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_SQ) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_sq(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_SQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_sq " "nvme_start_ctrl failed because there are non-admin submission queues" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_startfail_sq(void)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_sq();
    }
}

#define TRACE_NVME_ERR_STARTFAIL_NBARASQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_NBARASQ) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_nbarasq(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_NBARASQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_nbarasq " "nvme_start_ctrl failed because the admin submission queue address is null" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_startfail_nbarasq(void)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_nbarasq();
    }
}

#define TRACE_NVME_ERR_STARTFAIL_NBARACQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_NBARACQ) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_nbaracq(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_NBARACQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_nbaracq " "nvme_start_ctrl failed because the admin completion queue address is null" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_startfail_nbaracq(void)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_nbaracq();
    }
}

#define TRACE_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_ASQ_MISALIGNED) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_asq_misaligned(uint64_t addr)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_ASQ_MISALIGNED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_asq_misaligned " "nvme_start_ctrl failed because the admin submission queue address is misaligned: 0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_nvme_err_startfail_asq_misaligned(uint64_t addr)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_asq_misaligned(addr);
    }
}

#define TRACE_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_ACQ_MISALIGNED) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_acq_misaligned(uint64_t addr)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_ACQ_MISALIGNED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_acq_misaligned " "nvme_start_ctrl failed because the admin completion queue address is misaligned: 0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_nvme_err_startfail_acq_misaligned(uint64_t addr)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_acq_misaligned(addr);
    }
}

#define TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_page_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_page_too_small " "nvme_start_ctrl failed because the page size is too small: log2size=%u, min=%u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , log2ps, maxlog2ps);
    }
}

static inline void trace_nvme_err_startfail_page_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_page_too_small(log2ps, maxlog2ps);
    }
}

#define TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_page_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_page_too_large " "nvme_start_ctrl failed because the page size is too large: log2size=%u, max=%u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , log2ps, maxlog2ps);
    }
}

static inline void trace_nvme_err_startfail_page_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_page_too_large(log2ps, maxlog2ps);
    }
}

#define TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_cqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_cqent_too_small " "nvme_start_ctrl failed because the completion queue entry size is too small: log2size=%u, min=%u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , log2ps, maxlog2ps);
    }
}

static inline void trace_nvme_err_startfail_cqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_cqent_too_small(log2ps, maxlog2ps);
    }
}

#define TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_cqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_cqent_too_large " "nvme_start_ctrl failed because the completion queue entry size is too large: log2size=%u, max=%u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , log2ps, maxlog2ps);
    }
}

static inline void trace_nvme_err_startfail_cqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_cqent_too_large(log2ps, maxlog2ps);
    }
}

#define TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_sqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_sqent_too_small " "nvme_start_ctrl failed because the submission queue entry size is too small: log2size=%u, min=%u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , log2ps, maxlog2ps);
    }
}

static inline void trace_nvme_err_startfail_sqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_sqent_too_small(log2ps, maxlog2ps);
    }
}

#define TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_sqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_sqent_too_large " "nvme_start_ctrl failed because the submission queue entry size is too large: log2size=%u, max=%u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , log2ps, maxlog2ps);
    }
}

static inline void trace_nvme_err_startfail_sqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_sqent_too_large(log2ps, maxlog2ps);
    }
}

#define TRACE_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_asqent_sz_zero(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_asqent_sz_zero " "nvme_start_ctrl failed because the admin submission queue size is zero" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_startfail_asqent_sz_zero(void)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_asqent_sz_zero();
    }
}

#define TRACE_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail_acqent_sz_zero(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail_acqent_sz_zero " "nvme_start_ctrl failed because the admin completion queue size is zero" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_startfail_acqent_sz_zero(void)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail_acqent_sz_zero();
    }
}

#define TRACE_NVME_ERR_STARTFAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERR_STARTFAIL) || \
    false)

static inline void _nocheck__trace_nvme_err_startfail(void)
{
    if (trace_event_get_state(TRACE_NVME_ERR_STARTFAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_err_startfail " "setting controller enable bit failed" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_err_startfail(void)
{
    if (true) {
        _nocheck__trace_nvme_err_startfail();
    }
}

#define TRACE_NVME_UB_MMIOWR_MISALIGNED32_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIOWR_MISALIGNED32) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiowr_misaligned32(uint64_t offset)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIOWR_MISALIGNED32)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiowr_misaligned32 " "MMIO write not 32-bit aligned, offset=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset);
    }
}

static inline void trace_nvme_ub_mmiowr_misaligned32(uint64_t offset)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiowr_misaligned32(offset);
    }
}

#define TRACE_NVME_UB_MMIOWR_TOOSMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIOWR_TOOSMALL) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiowr_toosmall(uint64_t offset, unsigned size)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIOWR_TOOSMALL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiowr_toosmall " "MMIO write smaller than 32 bits, offset=0x%"PRIx64", size=%u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset, size);
    }
}

static inline void trace_nvme_ub_mmiowr_toosmall(uint64_t offset, unsigned size)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiowr_toosmall(offset, size);
    }
}

#define TRACE_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIOWR_INTMASK_WITH_MSIX) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiowr_intmask_with_msix(void)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIOWR_INTMASK_WITH_MSIX)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiowr_intmask_with_msix " "undefined access to interrupt mask set when MSI-X is enabled" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_ub_mmiowr_intmask_with_msix(void)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiowr_intmask_with_msix();
    }
}

#define TRACE_NVME_UB_MMIOWR_RO_CSTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIOWR_RO_CSTS) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiowr_ro_csts(void)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIOWR_RO_CSTS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiowr_ro_csts " "attempted to set a read only bit of controller status" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_ub_mmiowr_ro_csts(void)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiowr_ro_csts();
    }
}

#define TRACE_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiowr_ssreset_w1c_unsupported(void)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiowr_ssreset_w1c_unsupported " "attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_ub_mmiowr_ssreset_w1c_unsupported(void)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiowr_ssreset_w1c_unsupported();
    }
}

#define TRACE_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiowr_ssreset_unsupported(void)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiowr_ssreset_unsupported " "attempted NVM subsystem reset but CAP.NSSRS is zero (not supported)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_ub_mmiowr_ssreset_unsupported(void)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiowr_ssreset_unsupported();
    }
}

#define TRACE_NVME_UB_MMIOWR_CMBLOC_RESERVED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIOWR_CMBLOC_RESERVED) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiowr_cmbloc_reserved(void)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIOWR_CMBLOC_RESERVED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiowr_cmbloc_reserved " "invalid write to reserved CMBLOC when CMBSZ is zero, ignored" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_ub_mmiowr_cmbloc_reserved(void)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiowr_cmbloc_reserved();
    }
}

#define TRACE_NVME_UB_MMIOWR_CMBSZ_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIOWR_CMBSZ_READONLY) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiowr_cmbsz_readonly(void)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIOWR_CMBSZ_READONLY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiowr_cmbsz_readonly " "invalid write to read only CMBSZ, ignored" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_nvme_ub_mmiowr_cmbsz_readonly(void)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiowr_cmbsz_readonly();
    }
}

#define TRACE_NVME_UB_MMIOWR_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIOWR_INVALID) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiowr_invalid(uint64_t offset, uint64_t data)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIOWR_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiowr_invalid " "invalid MMIO write, offset=0x%"PRIx64", data=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset, data);
    }
}

static inline void trace_nvme_ub_mmiowr_invalid(uint64_t offset, uint64_t data)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiowr_invalid(offset, data);
    }
}

#define TRACE_NVME_UB_MMIORD_MISALIGNED32_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIORD_MISALIGNED32) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiord_misaligned32(uint64_t offset)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIORD_MISALIGNED32)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiord_misaligned32 " "MMIO read not 32-bit aligned, offset=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset);
    }
}

static inline void trace_nvme_ub_mmiord_misaligned32(uint64_t offset)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiord_misaligned32(offset);
    }
}

#define TRACE_NVME_UB_MMIORD_TOOSMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIORD_TOOSMALL) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiord_toosmall(uint64_t offset)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIORD_TOOSMALL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiord_toosmall " "MMIO read smaller than 32-bits, offset=0x%"PRIx64"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset);
    }
}

static inline void trace_nvme_ub_mmiord_toosmall(uint64_t offset)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiord_toosmall(offset);
    }
}

#define TRACE_NVME_UB_MMIORD_INVALID_OFS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_MMIORD_INVALID_OFS) || \
    false)

static inline void _nocheck__trace_nvme_ub_mmiord_invalid_ofs(uint64_t offset)
{
    if (trace_event_get_state(TRACE_NVME_UB_MMIORD_INVALID_OFS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_mmiord_invalid_ofs " "MMIO read beyond last register, offset=0x%"PRIx64", returning 0" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset);
    }
}

static inline void trace_nvme_ub_mmiord_invalid_ofs(uint64_t offset)
{
    if (true) {
        _nocheck__trace_nvme_ub_mmiord_invalid_ofs(offset);
    }
}

#define TRACE_NVME_UB_DB_WR_MISALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_DB_WR_MISALIGNED) || \
    false)

static inline void _nocheck__trace_nvme_ub_db_wr_misaligned(uint64_t offset)
{
    if (trace_event_get_state(TRACE_NVME_UB_DB_WR_MISALIGNED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_db_wr_misaligned " "doorbell write not 32-bit aligned, offset=0x%"PRIx64", ignoring" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset);
    }
}

static inline void trace_nvme_ub_db_wr_misaligned(uint64_t offset)
{
    if (true) {
        _nocheck__trace_nvme_ub_db_wr_misaligned(offset);
    }
}

#define TRACE_NVME_UB_DB_WR_INVALID_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_DB_WR_INVALID_CQ) || \
    false)

static inline void _nocheck__trace_nvme_ub_db_wr_invalid_cq(uint32_t qid)
{
    if (trace_event_get_state(TRACE_NVME_UB_DB_WR_INVALID_CQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_db_wr_invalid_cq " "completion queue doorbell write for nonexistent queue, cqid=%"PRIu32", ignoring" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , qid);
    }
}

static inline void trace_nvme_ub_db_wr_invalid_cq(uint32_t qid)
{
    if (true) {
        _nocheck__trace_nvme_ub_db_wr_invalid_cq(qid);
    }
}

#define TRACE_NVME_UB_DB_WR_INVALID_CQHEAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_DB_WR_INVALID_CQHEAD) || \
    false)

static inline void _nocheck__trace_nvme_ub_db_wr_invalid_cqhead(uint32_t qid, uint16_t new_head)
{
    if (trace_event_get_state(TRACE_NVME_UB_DB_WR_INVALID_CQHEAD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_db_wr_invalid_cqhead " "completion queue doorbell write value beyond queue size, cqid=%"PRIu32", new_head=%"PRIu16", ignoring" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , qid, new_head);
    }
}

static inline void trace_nvme_ub_db_wr_invalid_cqhead(uint32_t qid, uint16_t new_head)
{
    if (true) {
        _nocheck__trace_nvme_ub_db_wr_invalid_cqhead(qid, new_head);
    }
}

#define TRACE_NVME_UB_DB_WR_INVALID_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_DB_WR_INVALID_SQ) || \
    false)

static inline void _nocheck__trace_nvme_ub_db_wr_invalid_sq(uint32_t qid)
{
    if (trace_event_get_state(TRACE_NVME_UB_DB_WR_INVALID_SQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_db_wr_invalid_sq " "submission queue doorbell write for nonexistent queue, sqid=%"PRIu32", ignoring" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , qid);
    }
}

static inline void trace_nvme_ub_db_wr_invalid_sq(uint32_t qid)
{
    if (true) {
        _nocheck__trace_nvme_ub_db_wr_invalid_sq(qid);
    }
}

#define TRACE_NVME_UB_DB_WR_INVALID_SQTAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_UB_DB_WR_INVALID_SQTAIL) || \
    false)

static inline void _nocheck__trace_nvme_ub_db_wr_invalid_sqtail(uint32_t qid, uint16_t new_tail)
{
    if (trace_event_get_state(TRACE_NVME_UB_DB_WR_INVALID_SQTAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_ub_db_wr_invalid_sqtail " "submission queue doorbell write value beyond queue size, sqid=%"PRIu32", new_head=%"PRIu16", ignoring" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , qid, new_tail);
    }
}

static inline void trace_nvme_ub_db_wr_invalid_sqtail(uint32_t qid, uint16_t new_tail)
{
    if (true) {
        _nocheck__trace_nvme_ub_db_wr_invalid_sqtail(qid, new_tail);
    }
}

#define TRACE_XEN_DISK_ALLOC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_ALLOC) || \
    false)

static inline void _nocheck__trace_xen_disk_alloc(char * name)
{
    if (trace_event_get_state(TRACE_XEN_DISK_ALLOC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:xen_disk_alloc " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name);
    }
}

static inline void trace_xen_disk_alloc(char * name)
{
    if (true) {
        _nocheck__trace_xen_disk_alloc(name);
    }
}

#define TRACE_XEN_DISK_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_INIT) || \
    false)

static inline void _nocheck__trace_xen_disk_init(char * name)
{
    if (trace_event_get_state(TRACE_XEN_DISK_INIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:xen_disk_init " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name);
    }
}

static inline void trace_xen_disk_init(char * name)
{
    if (true) {
        _nocheck__trace_xen_disk_init(name);
    }
}

#define TRACE_XEN_DISK_CONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_CONNECT) || \
    false)

static inline void _nocheck__trace_xen_disk_connect(char * name)
{
    if (trace_event_get_state(TRACE_XEN_DISK_CONNECT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:xen_disk_connect " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name);
    }
}

static inline void trace_xen_disk_connect(char * name)
{
    if (true) {
        _nocheck__trace_xen_disk_connect(name);
    }
}

#define TRACE_XEN_DISK_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_DISCONNECT) || \
    false)

static inline void _nocheck__trace_xen_disk_disconnect(char * name)
{
    if (trace_event_get_state(TRACE_XEN_DISK_DISCONNECT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:xen_disk_disconnect " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name);
    }
}

static inline void trace_xen_disk_disconnect(char * name)
{
    if (true) {
        _nocheck__trace_xen_disk_disconnect(name);
    }
}

#define TRACE_XEN_DISK_FREE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_FREE) || \
    false)

static inline void _nocheck__trace_xen_disk_free(char * name)
{
    if (trace_event_get_state(TRACE_XEN_DISK_FREE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:xen_disk_free " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name);
    }
}

static inline void trace_xen_disk_free(char * name)
{
    if (true) {
        _nocheck__trace_xen_disk_free(name);
    }
}
#endif /* TRACE_HW_BLOCK_GENERATED_TRACERS_H */
