/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_BLOCK_GENERATED_TRACERS_H
#define TRACE_BLOCK_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_BDRV_OPEN_COMMON_EVENT;
extern TraceEvent _TRACE_BDRV_LOCK_MEDIUM_EVENT;
extern TraceEvent _TRACE_BLK_CO_PREADV_EVENT;
extern TraceEvent _TRACE_BLK_CO_PWRITEV_EVENT;
extern TraceEvent _TRACE_BDRV_CO_PREADV_EVENT;
extern TraceEvent _TRACE_BDRV_CO_PWRITEV_EVENT;
extern TraceEvent _TRACE_BDRV_CO_PWRITE_ZEROES_EVENT;
extern TraceEvent _TRACE_BDRV_CO_DO_COPY_ON_READV_EVENT;
extern TraceEvent _TRACE_STREAM_ONE_ITERATION_EVENT;
extern TraceEvent _TRACE_STREAM_START_EVENT;
extern TraceEvent _TRACE_COMMIT_ONE_ITERATION_EVENT;
extern TraceEvent _TRACE_COMMIT_START_EVENT;
extern TraceEvent _TRACE_MIRROR_START_EVENT;
extern TraceEvent _TRACE_MIRROR_RESTART_ITER_EVENT;
extern TraceEvent _TRACE_MIRROR_BEFORE_FLUSH_EVENT;
extern TraceEvent _TRACE_MIRROR_BEFORE_DRAIN_EVENT;
extern TraceEvent _TRACE_MIRROR_BEFORE_SLEEP_EVENT;
extern TraceEvent _TRACE_MIRROR_ONE_ITERATION_EVENT;
extern TraceEvent _TRACE_MIRROR_ITERATION_DONE_EVENT;
extern TraceEvent _TRACE_MIRROR_YIELD_EVENT;
extern TraceEvent _TRACE_MIRROR_YIELD_IN_FLIGHT_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_ENTER_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_RETURN_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_SKIP_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_PROCESS_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_READ_FAIL_EVENT;
extern TraceEvent _TRACE_BACKUP_DO_COW_WRITE_FAIL_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_CANCEL_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_PAUSE_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_RESUME_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_JOB_COMPLETE_EVENT;
extern TraceEvent _TRACE_QMP_BLOCK_STREAM_EVENT;
extern TraceEvent _TRACE_PAIO_SUBMIT_CO_EVENT;
extern TraceEvent _TRACE_PAIO_SUBMIT_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_START_REQ_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_DONE_REQ_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_START_PART_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_DONE_PART_EVENT;
extern TraceEvent _TRACE_QCOW2_WRITEV_DATA_EVENT;
extern TraceEvent _TRACE_QCOW2_PWRITE_ZEROES_START_REQ_EVENT;
extern TraceEvent _TRACE_QCOW2_PWRITE_ZEROES_EVENT;
extern TraceEvent _TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_EVENT;
extern TraceEvent _TRACE_QCOW2_HANDLE_COPIED_EVENT;
extern TraceEvent _TRACE_QCOW2_HANDLE_ALLOC_EVENT;
extern TraceEvent _TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_EVENT;
extern TraceEvent _TRACE_QCOW2_CLUSTER_ALLOC_PHYS_EVENT;
extern TraceEvent _TRACE_QCOW2_CLUSTER_LINK_L2_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_EVENT;
extern TraceEvent _TRACE_QCOW2_L2_ALLOCATE_DONE_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_READ_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_GET_DONE_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_FLUSH_EVENT;
extern TraceEvent _TRACE_QCOW2_CACHE_ENTRY_FLUSH_EVENT;
extern TraceEvent _TRACE_QED_ALLOC_L2_CACHE_ENTRY_EVENT;
extern TraceEvent _TRACE_QED_UNREF_L2_CACHE_ENTRY_EVENT;
extern TraceEvent _TRACE_QED_FIND_L2_CACHE_ENTRY_EVENT;
extern TraceEvent _TRACE_QED_READ_TABLE_EVENT;
extern TraceEvent _TRACE_QED_READ_TABLE_CB_EVENT;
extern TraceEvent _TRACE_QED_WRITE_TABLE_EVENT;
extern TraceEvent _TRACE_QED_WRITE_TABLE_CB_EVENT;
extern TraceEvent _TRACE_QED_NEED_CHECK_TIMER_CB_EVENT;
extern TraceEvent _TRACE_QED_START_NEED_CHECK_TIMER_EVENT;
extern TraceEvent _TRACE_QED_CANCEL_NEED_CHECK_TIMER_EVENT;
extern TraceEvent _TRACE_QED_AIO_COMPLETE_EVENT;
extern TraceEvent _TRACE_QED_AIO_SETUP_EVENT;
extern TraceEvent _TRACE_QED_AIO_NEXT_IO_EVENT;
extern TraceEvent _TRACE_QED_AIO_READ_DATA_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_DATA_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_PREFILL_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_POSTFILL_EVENT;
extern TraceEvent _TRACE_QED_AIO_WRITE_MAIN_EVENT;
extern TraceEvent _TRACE_VXHS_IIO_CALLBACK_EVENT;
extern TraceEvent _TRACE_VXHS_IIO_CALLBACK_CHNFAIL_EVENT;
extern TraceEvent _TRACE_VXHS_IIO_CALLBACK_UNKNWN_EVENT;
extern TraceEvent _TRACE_VXHS_AIO_RW_INVALID_EVENT;
extern TraceEvent _TRACE_VXHS_AIO_RW_IOERR_EVENT;
extern TraceEvent _TRACE_VXHS_GET_VDISK_STAT_ERR_EVENT;
extern TraceEvent _TRACE_VXHS_GET_VDISK_STAT_EVENT;
extern TraceEvent _TRACE_VXHS_COMPLETE_AIO_EVENT;
extern TraceEvent _TRACE_VXHS_PARSE_URI_FILENAME_EVENT;
extern TraceEvent _TRACE_VXHS_OPEN_VDISKID_EVENT;
extern TraceEvent _TRACE_VXHS_OPEN_HOSTINFO_EVENT;
extern TraceEvent _TRACE_VXHS_OPEN_IIO_OPEN_EVENT;
extern TraceEvent _TRACE_VXHS_PARSE_URI_HOSTINFO_EVENT;
extern TraceEvent _TRACE_VXHS_CLOSE_EVENT;
extern TraceEvent _TRACE_VXHS_GET_CREDS_EVENT;
extern TraceEvent _TRACE_NVME_KICK_EVENT;
extern TraceEvent _TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_EVENT;
extern TraceEvent _TRACE_NVME_ERROR_EVENT;
extern TraceEvent _TRACE_NVME_PROCESS_COMPLETION_EVENT;
extern TraceEvent _TRACE_NVME_PROCESS_COMPLETION_QUEUE_BUSY_EVENT;
extern TraceEvent _TRACE_NVME_COMPLETE_COMMAND_EVENT;
extern TraceEvent _TRACE_NVME_SUBMIT_COMMAND_EVENT;
extern TraceEvent _TRACE_NVME_SUBMIT_COMMAND_RAW_EVENT;
extern TraceEvent _TRACE_NVME_HANDLE_EVENT_EVENT;
extern TraceEvent _TRACE_NVME_POLL_CB_EVENT;
extern TraceEvent _TRACE_NVME_PRW_ALIGNED_EVENT;
extern TraceEvent _TRACE_NVME_QIOV_UNALIGNED_EVENT;
extern TraceEvent _TRACE_NVME_PRW_BUFFERED_EVENT;
extern TraceEvent _TRACE_NVME_RW_DONE_EVENT;
extern TraceEvent _TRACE_NVME_DMA_MAP_FLUSH_EVENT;
extern TraceEvent _TRACE_NVME_FREE_REQ_QUEUE_WAIT_EVENT;
extern TraceEvent _TRACE_NVME_CMD_MAP_QIOV_EVENT;
extern TraceEvent _TRACE_NVME_CMD_MAP_QIOV_PAGES_EVENT;
extern TraceEvent _TRACE_NVME_CMD_MAP_QIOV_IOV_EVENT;
extern uint16_t _TRACE_BDRV_OPEN_COMMON_DSTATE;
extern uint16_t _TRACE_BDRV_LOCK_MEDIUM_DSTATE;
extern uint16_t _TRACE_BLK_CO_PREADV_DSTATE;
extern uint16_t _TRACE_BLK_CO_PWRITEV_DSTATE;
extern uint16_t _TRACE_BDRV_CO_PREADV_DSTATE;
extern uint16_t _TRACE_BDRV_CO_PWRITEV_DSTATE;
extern uint16_t _TRACE_BDRV_CO_PWRITE_ZEROES_DSTATE;
extern uint16_t _TRACE_BDRV_CO_DO_COPY_ON_READV_DSTATE;
extern uint16_t _TRACE_STREAM_ONE_ITERATION_DSTATE;
extern uint16_t _TRACE_STREAM_START_DSTATE;
extern uint16_t _TRACE_COMMIT_ONE_ITERATION_DSTATE;
extern uint16_t _TRACE_COMMIT_START_DSTATE;
extern uint16_t _TRACE_MIRROR_START_DSTATE;
extern uint16_t _TRACE_MIRROR_RESTART_ITER_DSTATE;
extern uint16_t _TRACE_MIRROR_BEFORE_FLUSH_DSTATE;
extern uint16_t _TRACE_MIRROR_BEFORE_DRAIN_DSTATE;
extern uint16_t _TRACE_MIRROR_BEFORE_SLEEP_DSTATE;
extern uint16_t _TRACE_MIRROR_ONE_ITERATION_DSTATE;
extern uint16_t _TRACE_MIRROR_ITERATION_DONE_DSTATE;
extern uint16_t _TRACE_MIRROR_YIELD_DSTATE;
extern uint16_t _TRACE_MIRROR_YIELD_IN_FLIGHT_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_ENTER_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_RETURN_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_SKIP_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_PROCESS_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_READ_FAIL_DSTATE;
extern uint16_t _TRACE_BACKUP_DO_COW_WRITE_FAIL_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_CANCEL_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_PAUSE_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_RESUME_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_JOB_COMPLETE_DSTATE;
extern uint16_t _TRACE_QMP_BLOCK_STREAM_DSTATE;
extern uint16_t _TRACE_PAIO_SUBMIT_CO_DSTATE;
extern uint16_t _TRACE_PAIO_SUBMIT_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_START_REQ_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_DONE_REQ_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_START_PART_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_DONE_PART_DSTATE;
extern uint16_t _TRACE_QCOW2_WRITEV_DATA_DSTATE;
extern uint16_t _TRACE_QCOW2_PWRITE_ZEROES_START_REQ_DSTATE;
extern uint16_t _TRACE_QCOW2_PWRITE_ZEROES_DSTATE;
extern uint16_t _TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_DSTATE;
extern uint16_t _TRACE_QCOW2_HANDLE_COPIED_DSTATE;
extern uint16_t _TRACE_QCOW2_HANDLE_ALLOC_DSTATE;
extern uint16_t _TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_DSTATE;
extern uint16_t _TRACE_QCOW2_CLUSTER_ALLOC_PHYS_DSTATE;
extern uint16_t _TRACE_QCOW2_CLUSTER_LINK_L2_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_DSTATE;
extern uint16_t _TRACE_QCOW2_L2_ALLOCATE_DONE_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_READ_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_GET_DONE_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_FLUSH_DSTATE;
extern uint16_t _TRACE_QCOW2_CACHE_ENTRY_FLUSH_DSTATE;
extern uint16_t _TRACE_QED_ALLOC_L2_CACHE_ENTRY_DSTATE;
extern uint16_t _TRACE_QED_UNREF_L2_CACHE_ENTRY_DSTATE;
extern uint16_t _TRACE_QED_FIND_L2_CACHE_ENTRY_DSTATE;
extern uint16_t _TRACE_QED_READ_TABLE_DSTATE;
extern uint16_t _TRACE_QED_READ_TABLE_CB_DSTATE;
extern uint16_t _TRACE_QED_WRITE_TABLE_DSTATE;
extern uint16_t _TRACE_QED_WRITE_TABLE_CB_DSTATE;
extern uint16_t _TRACE_QED_NEED_CHECK_TIMER_CB_DSTATE;
extern uint16_t _TRACE_QED_START_NEED_CHECK_TIMER_DSTATE;
extern uint16_t _TRACE_QED_CANCEL_NEED_CHECK_TIMER_DSTATE;
extern uint16_t _TRACE_QED_AIO_COMPLETE_DSTATE;
extern uint16_t _TRACE_QED_AIO_SETUP_DSTATE;
extern uint16_t _TRACE_QED_AIO_NEXT_IO_DSTATE;
extern uint16_t _TRACE_QED_AIO_READ_DATA_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_DATA_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_PREFILL_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_POSTFILL_DSTATE;
extern uint16_t _TRACE_QED_AIO_WRITE_MAIN_DSTATE;
extern uint16_t _TRACE_VXHS_IIO_CALLBACK_DSTATE;
extern uint16_t _TRACE_VXHS_IIO_CALLBACK_CHNFAIL_DSTATE;
extern uint16_t _TRACE_VXHS_IIO_CALLBACK_UNKNWN_DSTATE;
extern uint16_t _TRACE_VXHS_AIO_RW_INVALID_DSTATE;
extern uint16_t _TRACE_VXHS_AIO_RW_IOERR_DSTATE;
extern uint16_t _TRACE_VXHS_GET_VDISK_STAT_ERR_DSTATE;
extern uint16_t _TRACE_VXHS_GET_VDISK_STAT_DSTATE;
extern uint16_t _TRACE_VXHS_COMPLETE_AIO_DSTATE;
extern uint16_t _TRACE_VXHS_PARSE_URI_FILENAME_DSTATE;
extern uint16_t _TRACE_VXHS_OPEN_VDISKID_DSTATE;
extern uint16_t _TRACE_VXHS_OPEN_HOSTINFO_DSTATE;
extern uint16_t _TRACE_VXHS_OPEN_IIO_OPEN_DSTATE;
extern uint16_t _TRACE_VXHS_PARSE_URI_HOSTINFO_DSTATE;
extern uint16_t _TRACE_VXHS_CLOSE_DSTATE;
extern uint16_t _TRACE_VXHS_GET_CREDS_DSTATE;
extern uint16_t _TRACE_NVME_KICK_DSTATE;
extern uint16_t _TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_DSTATE;
extern uint16_t _TRACE_NVME_ERROR_DSTATE;
extern uint16_t _TRACE_NVME_PROCESS_COMPLETION_DSTATE;
extern uint16_t _TRACE_NVME_PROCESS_COMPLETION_QUEUE_BUSY_DSTATE;
extern uint16_t _TRACE_NVME_COMPLETE_COMMAND_DSTATE;
extern uint16_t _TRACE_NVME_SUBMIT_COMMAND_DSTATE;
extern uint16_t _TRACE_NVME_SUBMIT_COMMAND_RAW_DSTATE;
extern uint16_t _TRACE_NVME_HANDLE_EVENT_DSTATE;
extern uint16_t _TRACE_NVME_POLL_CB_DSTATE;
extern uint16_t _TRACE_NVME_PRW_ALIGNED_DSTATE;
extern uint16_t _TRACE_NVME_QIOV_UNALIGNED_DSTATE;
extern uint16_t _TRACE_NVME_PRW_BUFFERED_DSTATE;
extern uint16_t _TRACE_NVME_RW_DONE_DSTATE;
extern uint16_t _TRACE_NVME_DMA_MAP_FLUSH_DSTATE;
extern uint16_t _TRACE_NVME_FREE_REQ_QUEUE_WAIT_DSTATE;
extern uint16_t _TRACE_NVME_CMD_MAP_QIOV_DSTATE;
extern uint16_t _TRACE_NVME_CMD_MAP_QIOV_PAGES_DSTATE;
extern uint16_t _TRACE_NVME_CMD_MAP_QIOV_IOV_DSTATE;
#define TRACE_BDRV_OPEN_COMMON_ENABLED 1
#define TRACE_BDRV_LOCK_MEDIUM_ENABLED 1
#define TRACE_BLK_CO_PREADV_ENABLED 1
#define TRACE_BLK_CO_PWRITEV_ENABLED 1
#define TRACE_BDRV_CO_PREADV_ENABLED 1
#define TRACE_BDRV_CO_PWRITEV_ENABLED 1
#define TRACE_BDRV_CO_PWRITE_ZEROES_ENABLED 1
#define TRACE_BDRV_CO_DO_COPY_ON_READV_ENABLED 1
#define TRACE_STREAM_ONE_ITERATION_ENABLED 1
#define TRACE_STREAM_START_ENABLED 1
#define TRACE_COMMIT_ONE_ITERATION_ENABLED 1
#define TRACE_COMMIT_START_ENABLED 1
#define TRACE_MIRROR_START_ENABLED 1
#define TRACE_MIRROR_RESTART_ITER_ENABLED 1
#define TRACE_MIRROR_BEFORE_FLUSH_ENABLED 1
#define TRACE_MIRROR_BEFORE_DRAIN_ENABLED 1
#define TRACE_MIRROR_BEFORE_SLEEP_ENABLED 1
#define TRACE_MIRROR_ONE_ITERATION_ENABLED 1
#define TRACE_MIRROR_ITERATION_DONE_ENABLED 1
#define TRACE_MIRROR_YIELD_ENABLED 1
#define TRACE_MIRROR_YIELD_IN_FLIGHT_ENABLED 1
#define TRACE_BACKUP_DO_COW_ENTER_ENABLED 1
#define TRACE_BACKUP_DO_COW_RETURN_ENABLED 1
#define TRACE_BACKUP_DO_COW_SKIP_ENABLED 1
#define TRACE_BACKUP_DO_COW_PROCESS_ENABLED 1
#define TRACE_BACKUP_DO_COW_READ_FAIL_ENABLED 1
#define TRACE_BACKUP_DO_COW_WRITE_FAIL_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_CANCEL_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_PAUSE_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_RESUME_ENABLED 1
#define TRACE_QMP_BLOCK_JOB_COMPLETE_ENABLED 1
#define TRACE_QMP_BLOCK_STREAM_ENABLED 1
#define TRACE_PAIO_SUBMIT_CO_ENABLED 1
#define TRACE_PAIO_SUBMIT_ENABLED 1
#define TRACE_QCOW2_WRITEV_START_REQ_ENABLED 1
#define TRACE_QCOW2_WRITEV_DONE_REQ_ENABLED 1
#define TRACE_QCOW2_WRITEV_START_PART_ENABLED 1
#define TRACE_QCOW2_WRITEV_DONE_PART_ENABLED 1
#define TRACE_QCOW2_WRITEV_DATA_ENABLED 1
#define TRACE_QCOW2_PWRITE_ZEROES_START_REQ_ENABLED 1
#define TRACE_QCOW2_PWRITE_ZEROES_ENABLED 1
#define TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_ENABLED 1
#define TRACE_QCOW2_HANDLE_COPIED_ENABLED 1
#define TRACE_QCOW2_HANDLE_ALLOC_ENABLED 1
#define TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_ENABLED 1
#define TRACE_QCOW2_CLUSTER_ALLOC_PHYS_ENABLED 1
#define TRACE_QCOW2_CLUSTER_LINK_L2_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_ENABLED 1
#define TRACE_QCOW2_L2_ALLOCATE_DONE_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_READ_ENABLED 1
#define TRACE_QCOW2_CACHE_GET_DONE_ENABLED 1
#define TRACE_QCOW2_CACHE_FLUSH_ENABLED 1
#define TRACE_QCOW2_CACHE_ENTRY_FLUSH_ENABLED 1
#define TRACE_QED_ALLOC_L2_CACHE_ENTRY_ENABLED 1
#define TRACE_QED_UNREF_L2_CACHE_ENTRY_ENABLED 1
#define TRACE_QED_FIND_L2_CACHE_ENTRY_ENABLED 1
#define TRACE_QED_READ_TABLE_ENABLED 1
#define TRACE_QED_READ_TABLE_CB_ENABLED 1
#define TRACE_QED_WRITE_TABLE_ENABLED 1
#define TRACE_QED_WRITE_TABLE_CB_ENABLED 1
#define TRACE_QED_NEED_CHECK_TIMER_CB_ENABLED 1
#define TRACE_QED_START_NEED_CHECK_TIMER_ENABLED 1
#define TRACE_QED_CANCEL_NEED_CHECK_TIMER_ENABLED 1
#define TRACE_QED_AIO_COMPLETE_ENABLED 1
#define TRACE_QED_AIO_SETUP_ENABLED 1
#define TRACE_QED_AIO_NEXT_IO_ENABLED 1
#define TRACE_QED_AIO_READ_DATA_ENABLED 1
#define TRACE_QED_AIO_WRITE_DATA_ENABLED 1
#define TRACE_QED_AIO_WRITE_PREFILL_ENABLED 1
#define TRACE_QED_AIO_WRITE_POSTFILL_ENABLED 1
#define TRACE_QED_AIO_WRITE_MAIN_ENABLED 1
#define TRACE_VXHS_IIO_CALLBACK_ENABLED 1
#define TRACE_VXHS_IIO_CALLBACK_CHNFAIL_ENABLED 1
#define TRACE_VXHS_IIO_CALLBACK_UNKNWN_ENABLED 1
#define TRACE_VXHS_AIO_RW_INVALID_ENABLED 1
#define TRACE_VXHS_AIO_RW_IOERR_ENABLED 1
#define TRACE_VXHS_GET_VDISK_STAT_ERR_ENABLED 1
#define TRACE_VXHS_GET_VDISK_STAT_ENABLED 1
#define TRACE_VXHS_COMPLETE_AIO_ENABLED 1
#define TRACE_VXHS_PARSE_URI_FILENAME_ENABLED 1
#define TRACE_VXHS_OPEN_VDISKID_ENABLED 1
#define TRACE_VXHS_OPEN_HOSTINFO_ENABLED 1
#define TRACE_VXHS_OPEN_IIO_OPEN_ENABLED 1
#define TRACE_VXHS_PARSE_URI_HOSTINFO_ENABLED 1
#define TRACE_VXHS_CLOSE_ENABLED 1
#define TRACE_VXHS_GET_CREDS_ENABLED 1
#define TRACE_NVME_KICK_ENABLED 1
#define TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_ENABLED 1
#define TRACE_NVME_ERROR_ENABLED 1
#define TRACE_NVME_PROCESS_COMPLETION_ENABLED 1
#define TRACE_NVME_PROCESS_COMPLETION_QUEUE_BUSY_ENABLED 1
#define TRACE_NVME_COMPLETE_COMMAND_ENABLED 1
#define TRACE_NVME_SUBMIT_COMMAND_ENABLED 1
#define TRACE_NVME_SUBMIT_COMMAND_RAW_ENABLED 1
#define TRACE_NVME_HANDLE_EVENT_ENABLED 1
#define TRACE_NVME_POLL_CB_ENABLED 1
#define TRACE_NVME_PRW_ALIGNED_ENABLED 1
#define TRACE_NVME_QIOV_UNALIGNED_ENABLED 1
#define TRACE_NVME_PRW_BUFFERED_ENABLED 1
#define TRACE_NVME_RW_DONE_ENABLED 1
#define TRACE_NVME_DMA_MAP_FLUSH_ENABLED 1
#define TRACE_NVME_FREE_REQ_QUEUE_WAIT_ENABLED 1
#define TRACE_NVME_CMD_MAP_QIOV_ENABLED 1
#define TRACE_NVME_CMD_MAP_QIOV_PAGES_ENABLED 1
#define TRACE_NVME_CMD_MAP_QIOV_IOV_ENABLED 1
#include "qemu/log.h"


#define TRACE_BDRV_OPEN_COMMON_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_OPEN_COMMON) || \
    false)

static inline void _nocheck__trace_bdrv_open_common(void * bs, const char * filename, int flags, const char * format_name)
{
    if (trace_event_get_state(TRACE_BDRV_OPEN_COMMON)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:bdrv_open_common " "bs %p filename \"%s\" flags 0x%x format_name \"%s\"" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, filename, flags, format_name);
    }
}

static inline void trace_bdrv_open_common(void * bs, const char * filename, int flags, const char * format_name)
{
    if (true) {
        _nocheck__trace_bdrv_open_common(bs, filename, flags, format_name);
    }
}

#define TRACE_BDRV_LOCK_MEDIUM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_LOCK_MEDIUM) || \
    false)

static inline void _nocheck__trace_bdrv_lock_medium(void * bs, bool locked)
{
    if (trace_event_get_state(TRACE_BDRV_LOCK_MEDIUM)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:bdrv_lock_medium " "bs %p locked %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, locked);
    }
}

static inline void trace_bdrv_lock_medium(void * bs, bool locked)
{
    if (true) {
        _nocheck__trace_bdrv_lock_medium(bs, locked);
    }
}

#define TRACE_BLK_CO_PREADV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLK_CO_PREADV) || \
    false)

static inline void _nocheck__trace_blk_co_preadv(void * blk, void * bs, int64_t offset, unsigned int bytes, int flags)
{
    if (trace_event_get_state(TRACE_BLK_CO_PREADV)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:blk_co_preadv " "blk %p bs %p offset %"PRId64" bytes %u flags 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , blk, bs, offset, bytes, flags);
    }
}

static inline void trace_blk_co_preadv(void * blk, void * bs, int64_t offset, unsigned int bytes, int flags)
{
    if (true) {
        _nocheck__trace_blk_co_preadv(blk, bs, offset, bytes, flags);
    }
}

#define TRACE_BLK_CO_PWRITEV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BLK_CO_PWRITEV) || \
    false)

static inline void _nocheck__trace_blk_co_pwritev(void * blk, void * bs, int64_t offset, unsigned int bytes, int flags)
{
    if (trace_event_get_state(TRACE_BLK_CO_PWRITEV)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:blk_co_pwritev " "blk %p bs %p offset %"PRId64" bytes %u flags 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , blk, bs, offset, bytes, flags);
    }
}

static inline void trace_blk_co_pwritev(void * blk, void * bs, int64_t offset, unsigned int bytes, int flags)
{
    if (true) {
        _nocheck__trace_blk_co_pwritev(blk, bs, offset, bytes, flags);
    }
}

#define TRACE_BDRV_CO_PREADV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_CO_PREADV) || \
    false)

static inline void _nocheck__trace_bdrv_co_preadv(void * bs, int64_t offset, int64_t nbytes, unsigned int flags)
{
    if (trace_event_get_state(TRACE_BDRV_CO_PREADV)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:bdrv_co_preadv " "bs %p offset %"PRId64" nbytes %"PRId64" flags 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, offset, nbytes, flags);
    }
}

static inline void trace_bdrv_co_preadv(void * bs, int64_t offset, int64_t nbytes, unsigned int flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_preadv(bs, offset, nbytes, flags);
    }
}

#define TRACE_BDRV_CO_PWRITEV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_CO_PWRITEV) || \
    false)

static inline void _nocheck__trace_bdrv_co_pwritev(void * bs, int64_t offset, int64_t nbytes, unsigned int flags)
{
    if (trace_event_get_state(TRACE_BDRV_CO_PWRITEV)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:bdrv_co_pwritev " "bs %p offset %"PRId64" nbytes %"PRId64" flags 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, offset, nbytes, flags);
    }
}

static inline void trace_bdrv_co_pwritev(void * bs, int64_t offset, int64_t nbytes, unsigned int flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_pwritev(bs, offset, nbytes, flags);
    }
}

#define TRACE_BDRV_CO_PWRITE_ZEROES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_CO_PWRITE_ZEROES) || \
    false)

static inline void _nocheck__trace_bdrv_co_pwrite_zeroes(void * bs, int64_t offset, int count, int flags)
{
    if (trace_event_get_state(TRACE_BDRV_CO_PWRITE_ZEROES)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:bdrv_co_pwrite_zeroes " "bs %p offset %"PRId64" count %d flags 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, offset, count, flags);
    }
}

static inline void trace_bdrv_co_pwrite_zeroes(void * bs, int64_t offset, int count, int flags)
{
    if (true) {
        _nocheck__trace_bdrv_co_pwrite_zeroes(bs, offset, count, flags);
    }
}

#define TRACE_BDRV_CO_DO_COPY_ON_READV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BDRV_CO_DO_COPY_ON_READV) || \
    false)

static inline void _nocheck__trace_bdrv_co_do_copy_on_readv(void * bs, int64_t offset, unsigned int bytes, int64_t cluster_offset, int64_t cluster_bytes)
{
    if (trace_event_get_state(TRACE_BDRV_CO_DO_COPY_ON_READV)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:bdrv_co_do_copy_on_readv " "bs %p offset %"PRId64" bytes %u cluster_offset %"PRId64" cluster_bytes %"PRId64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, offset, bytes, cluster_offset, cluster_bytes);
    }
}

static inline void trace_bdrv_co_do_copy_on_readv(void * bs, int64_t offset, unsigned int bytes, int64_t cluster_offset, int64_t cluster_bytes)
{
    if (true) {
        _nocheck__trace_bdrv_co_do_copy_on_readv(bs, offset, bytes, cluster_offset, cluster_bytes);
    }
}

#define TRACE_STREAM_ONE_ITERATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STREAM_ONE_ITERATION) || \
    false)

static inline void _nocheck__trace_stream_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
    if (trace_event_get_state(TRACE_STREAM_ONE_ITERATION)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:stream_one_iteration " "s %p offset %" PRId64 " bytes %" PRIu64 " is_allocated %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, offset, bytes, is_allocated);
    }
}

static inline void trace_stream_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
    if (true) {
        _nocheck__trace_stream_one_iteration(s, offset, bytes, is_allocated);
    }
}

#define TRACE_STREAM_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_STREAM_START) || \
    false)

static inline void _nocheck__trace_stream_start(void * bs, void * base, void * s)
{
    if (trace_event_get_state(TRACE_STREAM_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:stream_start " "bs %p base %p s %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, base, s);
    }
}

static inline void trace_stream_start(void * bs, void * base, void * s)
{
    if (true) {
        _nocheck__trace_stream_start(bs, base, s);
    }
}

#define TRACE_COMMIT_ONE_ITERATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_COMMIT_ONE_ITERATION) || \
    false)

static inline void _nocheck__trace_commit_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
    if (trace_event_get_state(TRACE_COMMIT_ONE_ITERATION)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:commit_one_iteration " "s %p offset %" PRId64 " bytes %" PRIu64 " is_allocated %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, offset, bytes, is_allocated);
    }
}

static inline void trace_commit_one_iteration(void * s, int64_t offset, uint64_t bytes, int is_allocated)
{
    if (true) {
        _nocheck__trace_commit_one_iteration(s, offset, bytes, is_allocated);
    }
}

#define TRACE_COMMIT_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_COMMIT_START) || \
    false)

static inline void _nocheck__trace_commit_start(void * bs, void * base, void * top, void * s)
{
    if (trace_event_get_state(TRACE_COMMIT_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:commit_start " "bs %p base %p top %p s %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, base, top, s);
    }
}

static inline void trace_commit_start(void * bs, void * base, void * top, void * s)
{
    if (true) {
        _nocheck__trace_commit_start(bs, base, top, s);
    }
}

#define TRACE_MIRROR_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_START) || \
    false)

static inline void _nocheck__trace_mirror_start(void * bs, void * s, void * opaque)
{
    if (trace_event_get_state(TRACE_MIRROR_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:mirror_start " "bs %p s %p opaque %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, s, opaque);
    }
}

static inline void trace_mirror_start(void * bs, void * s, void * opaque)
{
    if (true) {
        _nocheck__trace_mirror_start(bs, s, opaque);
    }
}

#define TRACE_MIRROR_RESTART_ITER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_RESTART_ITER) || \
    false)

static inline void _nocheck__trace_mirror_restart_iter(void * s, int64_t cnt)
{
    if (trace_event_get_state(TRACE_MIRROR_RESTART_ITER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:mirror_restart_iter " "s %p dirty count %"PRId64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, cnt);
    }
}

static inline void trace_mirror_restart_iter(void * s, int64_t cnt)
{
    if (true) {
        _nocheck__trace_mirror_restart_iter(s, cnt);
    }
}

#define TRACE_MIRROR_BEFORE_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_BEFORE_FLUSH) || \
    false)

static inline void _nocheck__trace_mirror_before_flush(void * s)
{
    if (trace_event_get_state(TRACE_MIRROR_BEFORE_FLUSH)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:mirror_before_flush " "s %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s);
    }
}

static inline void trace_mirror_before_flush(void * s)
{
    if (true) {
        _nocheck__trace_mirror_before_flush(s);
    }
}

#define TRACE_MIRROR_BEFORE_DRAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_BEFORE_DRAIN) || \
    false)

static inline void _nocheck__trace_mirror_before_drain(void * s, int64_t cnt)
{
    if (trace_event_get_state(TRACE_MIRROR_BEFORE_DRAIN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:mirror_before_drain " "s %p dirty count %"PRId64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, cnt);
    }
}

static inline void trace_mirror_before_drain(void * s, int64_t cnt)
{
    if (true) {
        _nocheck__trace_mirror_before_drain(s, cnt);
    }
}

#define TRACE_MIRROR_BEFORE_SLEEP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_BEFORE_SLEEP) || \
    false)

static inline void _nocheck__trace_mirror_before_sleep(void * s, int64_t cnt, int synced, uint64_t delay_ns)
{
    if (trace_event_get_state(TRACE_MIRROR_BEFORE_SLEEP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:mirror_before_sleep " "s %p dirty count %"PRId64" synced %d delay %"PRIu64"ns" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, cnt, synced, delay_ns);
    }
}

static inline void trace_mirror_before_sleep(void * s, int64_t cnt, int synced, uint64_t delay_ns)
{
    if (true) {
        _nocheck__trace_mirror_before_sleep(s, cnt, synced, delay_ns);
    }
}

#define TRACE_MIRROR_ONE_ITERATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_ONE_ITERATION) || \
    false)

static inline void _nocheck__trace_mirror_one_iteration(void * s, int64_t offset, uint64_t bytes)
{
    if (trace_event_get_state(TRACE_MIRROR_ONE_ITERATION)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:mirror_one_iteration " "s %p offset %" PRId64 " bytes %" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, offset, bytes);
    }
}

static inline void trace_mirror_one_iteration(void * s, int64_t offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_mirror_one_iteration(s, offset, bytes);
    }
}

#define TRACE_MIRROR_ITERATION_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_ITERATION_DONE) || \
    false)

static inline void _nocheck__trace_mirror_iteration_done(void * s, int64_t offset, uint64_t bytes, int ret)
{
    if (trace_event_get_state(TRACE_MIRROR_ITERATION_DONE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:mirror_iteration_done " "s %p offset %" PRId64 " bytes %" PRIu64 " ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, offset, bytes, ret);
    }
}

static inline void trace_mirror_iteration_done(void * s, int64_t offset, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_mirror_iteration_done(s, offset, bytes, ret);
    }
}

#define TRACE_MIRROR_YIELD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_YIELD) || \
    false)

static inline void _nocheck__trace_mirror_yield(void * s, int64_t cnt, int buf_free_count, int in_flight)
{
    if (trace_event_get_state(TRACE_MIRROR_YIELD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:mirror_yield " "s %p dirty count %"PRId64" free buffers %d in_flight %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, cnt, buf_free_count, in_flight);
    }
}

static inline void trace_mirror_yield(void * s, int64_t cnt, int buf_free_count, int in_flight)
{
    if (true) {
        _nocheck__trace_mirror_yield(s, cnt, buf_free_count, in_flight);
    }
}

#define TRACE_MIRROR_YIELD_IN_FLIGHT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIRROR_YIELD_IN_FLIGHT) || \
    false)

static inline void _nocheck__trace_mirror_yield_in_flight(void * s, int64_t offset, int in_flight)
{
    if (trace_event_get_state(TRACE_MIRROR_YIELD_IN_FLIGHT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:mirror_yield_in_flight " "s %p offset %" PRId64 " in_flight %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, offset, in_flight);
    }
}

static inline void trace_mirror_yield_in_flight(void * s, int64_t offset, int in_flight)
{
    if (true) {
        _nocheck__trace_mirror_yield_in_flight(s, offset, in_flight);
    }
}

#define TRACE_BACKUP_DO_COW_ENTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BACKUP_DO_COW_ENTER) || \
    false)

static inline void _nocheck__trace_backup_do_cow_enter(void * job, int64_t start, int64_t offset, uint64_t bytes)
{
    if (trace_event_get_state(TRACE_BACKUP_DO_COW_ENTER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:backup_do_cow_enter " "job %p start %" PRId64 " offset %" PRId64 " bytes %" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , job, start, offset, bytes);
    }
}

static inline void trace_backup_do_cow_enter(void * job, int64_t start, int64_t offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_backup_do_cow_enter(job, start, offset, bytes);
    }
}

#define TRACE_BACKUP_DO_COW_RETURN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BACKUP_DO_COW_RETURN) || \
    false)

static inline void _nocheck__trace_backup_do_cow_return(void * job, int64_t offset, uint64_t bytes, int ret)
{
    if (trace_event_get_state(TRACE_BACKUP_DO_COW_RETURN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:backup_do_cow_return " "job %p offset %" PRId64 " bytes %" PRIu64 " ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , job, offset, bytes, ret);
    }
}

static inline void trace_backup_do_cow_return(void * job, int64_t offset, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_backup_do_cow_return(job, offset, bytes, ret);
    }
}

#define TRACE_BACKUP_DO_COW_SKIP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BACKUP_DO_COW_SKIP) || \
    false)

static inline void _nocheck__trace_backup_do_cow_skip(void * job, int64_t start)
{
    if (trace_event_get_state(TRACE_BACKUP_DO_COW_SKIP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:backup_do_cow_skip " "job %p start %"PRId64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , job, start);
    }
}

static inline void trace_backup_do_cow_skip(void * job, int64_t start)
{
    if (true) {
        _nocheck__trace_backup_do_cow_skip(job, start);
    }
}

#define TRACE_BACKUP_DO_COW_PROCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BACKUP_DO_COW_PROCESS) || \
    false)

static inline void _nocheck__trace_backup_do_cow_process(void * job, int64_t start)
{
    if (trace_event_get_state(TRACE_BACKUP_DO_COW_PROCESS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:backup_do_cow_process " "job %p start %"PRId64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , job, start);
    }
}

static inline void trace_backup_do_cow_process(void * job, int64_t start)
{
    if (true) {
        _nocheck__trace_backup_do_cow_process(job, start);
    }
}

#define TRACE_BACKUP_DO_COW_READ_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BACKUP_DO_COW_READ_FAIL) || \
    false)

static inline void _nocheck__trace_backup_do_cow_read_fail(void * job, int64_t start, int ret)
{
    if (trace_event_get_state(TRACE_BACKUP_DO_COW_READ_FAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:backup_do_cow_read_fail " "job %p start %"PRId64" ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , job, start, ret);
    }
}

static inline void trace_backup_do_cow_read_fail(void * job, int64_t start, int ret)
{
    if (true) {
        _nocheck__trace_backup_do_cow_read_fail(job, start, ret);
    }
}

#define TRACE_BACKUP_DO_COW_WRITE_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BACKUP_DO_COW_WRITE_FAIL) || \
    false)

static inline void _nocheck__trace_backup_do_cow_write_fail(void * job, int64_t start, int ret)
{
    if (trace_event_get_state(TRACE_BACKUP_DO_COW_WRITE_FAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:backup_do_cow_write_fail " "job %p start %"PRId64" ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , job, start, ret);
    }
}

static inline void trace_backup_do_cow_write_fail(void * job, int64_t start, int ret)
{
    if (true) {
        _nocheck__trace_backup_do_cow_write_fail(job, start, ret);
    }
}

#define TRACE_QMP_BLOCK_JOB_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_JOB_CANCEL) || \
    false)

static inline void _nocheck__trace_qmp_block_job_cancel(void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_JOB_CANCEL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qmp_block_job_cancel " "job %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , job);
    }
}

static inline void trace_qmp_block_job_cancel(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_cancel(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_PAUSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_JOB_PAUSE) || \
    false)

static inline void _nocheck__trace_qmp_block_job_pause(void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_JOB_PAUSE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qmp_block_job_pause " "job %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , job);
    }
}

static inline void trace_qmp_block_job_pause(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_pause(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_RESUME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_JOB_RESUME) || \
    false)

static inline void _nocheck__trace_qmp_block_job_resume(void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_JOB_RESUME)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qmp_block_job_resume " "job %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , job);
    }
}

static inline void trace_qmp_block_job_resume(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_resume(job);
    }
}

#define TRACE_QMP_BLOCK_JOB_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_JOB_COMPLETE) || \
    false)

static inline void _nocheck__trace_qmp_block_job_complete(void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_JOB_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qmp_block_job_complete " "job %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , job);
    }
}

static inline void trace_qmp_block_job_complete(void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_job_complete(job);
    }
}

#define TRACE_QMP_BLOCK_STREAM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QMP_BLOCK_STREAM) || \
    false)

static inline void _nocheck__trace_qmp_block_stream(void * bs, void * job)
{
    if (trace_event_get_state(TRACE_QMP_BLOCK_STREAM)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qmp_block_stream " "bs %p job %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, job);
    }
}

static inline void trace_qmp_block_stream(void * bs, void * job)
{
    if (true) {
        _nocheck__trace_qmp_block_stream(bs, job);
    }
}

#define TRACE_PAIO_SUBMIT_CO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PAIO_SUBMIT_CO) || \
    false)

static inline void _nocheck__trace_paio_submit_co(int64_t offset, int count, int type)
{
    if (trace_event_get_state(TRACE_PAIO_SUBMIT_CO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:paio_submit_co " "offset %"PRId64" count %d type %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , offset, count, type);
    }
}

static inline void trace_paio_submit_co(int64_t offset, int count, int type)
{
    if (true) {
        _nocheck__trace_paio_submit_co(offset, count, type);
    }
}

#define TRACE_PAIO_SUBMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PAIO_SUBMIT) || \
    false)

static inline void _nocheck__trace_paio_submit(void * acb, void * opaque, int64_t offset, int count, int type)
{
    if (trace_event_get_state(TRACE_PAIO_SUBMIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:paio_submit " "acb %p opaque %p offset %"PRId64" count %d type %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , acb, opaque, offset, count, type);
    }
}

static inline void trace_paio_submit(void * acb, void * opaque, int64_t offset, int count, int type)
{
    if (true) {
        _nocheck__trace_paio_submit(acb, opaque, offset, count, type);
    }
}

#define TRACE_QCOW2_WRITEV_START_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_WRITEV_START_REQ) || \
    false)

static inline void _nocheck__trace_qcow2_writev_start_req(void * co, int64_t offset, int bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_WRITEV_START_REQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_writev_start_req " "co %p offset 0x%" PRIx64 " bytes %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, offset, bytes);
    }
}

static inline void trace_qcow2_writev_start_req(void * co, int64_t offset, int bytes)
{
    if (true) {
        _nocheck__trace_qcow2_writev_start_req(co, offset, bytes);
    }
}

#define TRACE_QCOW2_WRITEV_DONE_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_WRITEV_DONE_REQ) || \
    false)

static inline void _nocheck__trace_qcow2_writev_done_req(void * co, int ret)
{
    if (trace_event_get_state(TRACE_QCOW2_WRITEV_DONE_REQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_writev_done_req " "co %p ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, ret);
    }
}

static inline void trace_qcow2_writev_done_req(void * co, int ret)
{
    if (true) {
        _nocheck__trace_qcow2_writev_done_req(co, ret);
    }
}

#define TRACE_QCOW2_WRITEV_START_PART_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_WRITEV_START_PART) || \
    false)

static inline void _nocheck__trace_qcow2_writev_start_part(void * co)
{
    if (trace_event_get_state(TRACE_QCOW2_WRITEV_START_PART)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_writev_start_part " "co %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co);
    }
}

static inline void trace_qcow2_writev_start_part(void * co)
{
    if (true) {
        _nocheck__trace_qcow2_writev_start_part(co);
    }
}

#define TRACE_QCOW2_WRITEV_DONE_PART_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_WRITEV_DONE_PART) || \
    false)

static inline void _nocheck__trace_qcow2_writev_done_part(void * co, int cur_bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_WRITEV_DONE_PART)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_writev_done_part " "co %p cur_bytes %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, cur_bytes);
    }
}

static inline void trace_qcow2_writev_done_part(void * co, int cur_bytes)
{
    if (true) {
        _nocheck__trace_qcow2_writev_done_part(co, cur_bytes);
    }
}

#define TRACE_QCOW2_WRITEV_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_WRITEV_DATA) || \
    false)

static inline void _nocheck__trace_qcow2_writev_data(void * co, uint64_t offset)
{
    if (trace_event_get_state(TRACE_QCOW2_WRITEV_DATA)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_writev_data " "co %p offset 0x%" PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, offset);
    }
}

static inline void trace_qcow2_writev_data(void * co, uint64_t offset)
{
    if (true) {
        _nocheck__trace_qcow2_writev_data(co, offset);
    }
}

#define TRACE_QCOW2_PWRITE_ZEROES_START_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_PWRITE_ZEROES_START_REQ) || \
    false)

static inline void _nocheck__trace_qcow2_pwrite_zeroes_start_req(void * co, int64_t offset, int count)
{
    if (trace_event_get_state(TRACE_QCOW2_PWRITE_ZEROES_START_REQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_pwrite_zeroes_start_req " "co %p offset 0x%" PRIx64 " count %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, offset, count);
    }
}

static inline void trace_qcow2_pwrite_zeroes_start_req(void * co, int64_t offset, int count)
{
    if (true) {
        _nocheck__trace_qcow2_pwrite_zeroes_start_req(co, offset, count);
    }
}

#define TRACE_QCOW2_PWRITE_ZEROES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_PWRITE_ZEROES) || \
    false)

static inline void _nocheck__trace_qcow2_pwrite_zeroes(void * co, int64_t offset, int count)
{
    if (trace_event_get_state(TRACE_QCOW2_PWRITE_ZEROES)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_pwrite_zeroes " "co %p offset 0x%" PRIx64 " count %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, offset, count);
    }
}

static inline void trace_qcow2_pwrite_zeroes(void * co, int64_t offset, int count)
{
    if (true) {
        _nocheck__trace_qcow2_pwrite_zeroes(co, offset, count);
    }
}

#define TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET) || \
    false)

static inline void _nocheck__trace_qcow2_alloc_clusters_offset(void * co, uint64_t offset, int bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_alloc_clusters_offset " "co %p offset 0x%" PRIx64 " bytes %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, offset, bytes);
    }
}

static inline void trace_qcow2_alloc_clusters_offset(void * co, uint64_t offset, int bytes)
{
    if (true) {
        _nocheck__trace_qcow2_alloc_clusters_offset(co, offset, bytes);
    }
}

#define TRACE_QCOW2_HANDLE_COPIED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_HANDLE_COPIED) || \
    false)

static inline void _nocheck__trace_qcow2_handle_copied(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_HANDLE_COPIED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_handle_copied " "co %p guest_offset 0x%" PRIx64 " host_offset 0x%" PRIx64 " bytes 0x%" PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, guest_offset, host_offset, bytes);
    }
}

static inline void trace_qcow2_handle_copied(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_qcow2_handle_copied(co, guest_offset, host_offset, bytes);
    }
}

#define TRACE_QCOW2_HANDLE_ALLOC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_HANDLE_ALLOC) || \
    false)

static inline void _nocheck__trace_qcow2_handle_alloc(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    if (trace_event_get_state(TRACE_QCOW2_HANDLE_ALLOC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_handle_alloc " "co %p guest_offset 0x%" PRIx64 " host_offset 0x%" PRIx64 " bytes 0x%" PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, guest_offset, host_offset, bytes);
    }
}

static inline void trace_qcow2_handle_alloc(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    if (true) {
        _nocheck__trace_qcow2_handle_alloc(co, guest_offset, host_offset, bytes);
    }
}

#define TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET) || \
    false)

static inline void _nocheck__trace_qcow2_do_alloc_clusters_offset(void * co, uint64_t guest_offset, uint64_t host_offset, int nb_clusters)
{
    if (trace_event_get_state(TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_do_alloc_clusters_offset " "co %p guest_offset 0x%" PRIx64 " host_offset 0x%" PRIx64 " nb_clusters %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, guest_offset, host_offset, nb_clusters);
    }
}

static inline void trace_qcow2_do_alloc_clusters_offset(void * co, uint64_t guest_offset, uint64_t host_offset, int nb_clusters)
{
    if (true) {
        _nocheck__trace_qcow2_do_alloc_clusters_offset(co, guest_offset, host_offset, nb_clusters);
    }
}

#define TRACE_QCOW2_CLUSTER_ALLOC_PHYS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CLUSTER_ALLOC_PHYS) || \
    false)

static inline void _nocheck__trace_qcow2_cluster_alloc_phys(void * co)
{
    if (trace_event_get_state(TRACE_QCOW2_CLUSTER_ALLOC_PHYS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_cluster_alloc_phys " "co %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co);
    }
}

static inline void trace_qcow2_cluster_alloc_phys(void * co)
{
    if (true) {
        _nocheck__trace_qcow2_cluster_alloc_phys(co);
    }
}

#define TRACE_QCOW2_CLUSTER_LINK_L2_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CLUSTER_LINK_L2) || \
    false)

static inline void _nocheck__trace_qcow2_cluster_link_l2(void * co, int nb_clusters)
{
    if (trace_event_get_state(TRACE_QCOW2_CLUSTER_LINK_L2)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_cluster_link_l2 " "co %p nb_clusters %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, nb_clusters);
    }
}

static inline void trace_qcow2_cluster_link_l2(void * co, int nb_clusters)
{
    if (true) {
        _nocheck__trace_qcow2_cluster_link_l2(co, nb_clusters);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_L2_ALLOCATE) || \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate(void * bs, int l1_index)
{
    if (trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_l2_allocate " "bs %p l1_index %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, l1_index);
    }
}

static inline void trace_qcow2_l2_allocate(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY) || \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_get_empty(void * bs, int l1_index)
{
    if (trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_l2_allocate_get_empty " "bs %p l1_index %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, l1_index);
    }
}

static inline void trace_qcow2_l2_allocate_get_empty(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_get_empty(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L2_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_L2_ALLOCATE_WRITE_L2) || \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_write_l2(void * bs, int l1_index)
{
    if (trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_WRITE_L2)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_l2_allocate_write_l2 " "bs %p l1_index %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, l1_index);
    }
}

static inline void trace_qcow2_l2_allocate_write_l2(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_write_l2(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_WRITE_L1_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_L2_ALLOCATE_WRITE_L1) || \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_write_l1(void * bs, int l1_index)
{
    if (trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_WRITE_L1)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_l2_allocate_write_l1 " "bs %p l1_index %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, l1_index);
    }
}

static inline void trace_qcow2_l2_allocate_write_l1(void * bs, int l1_index)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_write_l1(bs, l1_index);
    }
}

#define TRACE_QCOW2_L2_ALLOCATE_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_L2_ALLOCATE_DONE) || \
    false)

static inline void _nocheck__trace_qcow2_l2_allocate_done(void * bs, int l1_index, int ret)
{
    if (trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_DONE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_l2_allocate_done " "bs %p l1_index %d ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bs, l1_index, ret);
    }
}

static inline void trace_qcow2_l2_allocate_done(void * bs, int l1_index, int ret)
{
    if (true) {
        _nocheck__trace_qcow2_l2_allocate_done(bs, l1_index, ret);
    }
}

#define TRACE_QCOW2_CACHE_GET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_GET) || \
    false)

static inline void _nocheck__trace_qcow2_cache_get(void * co, int c, uint64_t offset, bool read_from_disk)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_GET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_cache_get " "co %p is_l2_cache %d offset 0x%" PRIx64 " read_from_disk %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, c, offset, read_from_disk);
    }
}

static inline void trace_qcow2_cache_get(void * co, int c, uint64_t offset, bool read_from_disk)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get(co, c, offset, read_from_disk);
    }
}

#define TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY) || \
    false)

static inline void _nocheck__trace_qcow2_cache_get_replace_entry(void * co, int c, int i)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_cache_get_replace_entry " "co %p is_l2_cache %d index %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, c, i);
    }
}

static inline void trace_qcow2_cache_get_replace_entry(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get_replace_entry(co, c, i);
    }
}

#define TRACE_QCOW2_CACHE_GET_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_GET_READ) || \
    false)

static inline void _nocheck__trace_qcow2_cache_get_read(void * co, int c, int i)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_GET_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_cache_get_read " "co %p is_l2_cache %d index %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, c, i);
    }
}

static inline void trace_qcow2_cache_get_read(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get_read(co, c, i);
    }
}

#define TRACE_QCOW2_CACHE_GET_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_GET_DONE) || \
    false)

static inline void _nocheck__trace_qcow2_cache_get_done(void * co, int c, int i)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_GET_DONE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_cache_get_done " "co %p is_l2_cache %d index %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, c, i);
    }
}

static inline void trace_qcow2_cache_get_done(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_get_done(co, c, i);
    }
}

#define TRACE_QCOW2_CACHE_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_FLUSH) || \
    false)

static inline void _nocheck__trace_qcow2_cache_flush(void * co, int c)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_FLUSH)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_cache_flush " "co %p is_l2_cache %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, c);
    }
}

static inline void trace_qcow2_cache_flush(void * co, int c)
{
    if (true) {
        _nocheck__trace_qcow2_cache_flush(co, c);
    }
}

#define TRACE_QCOW2_CACHE_ENTRY_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QCOW2_CACHE_ENTRY_FLUSH) || \
    false)

static inline void _nocheck__trace_qcow2_cache_entry_flush(void * co, int c, int i)
{
    if (trace_event_get_state(TRACE_QCOW2_CACHE_ENTRY_FLUSH)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qcow2_cache_entry_flush " "co %p is_l2_cache %d index %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , co, c, i);
    }
}

static inline void trace_qcow2_cache_entry_flush(void * co, int c, int i)
{
    if (true) {
        _nocheck__trace_qcow2_cache_entry_flush(co, c, i);
    }
}

#define TRACE_QED_ALLOC_L2_CACHE_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_ALLOC_L2_CACHE_ENTRY) || \
    false)

static inline void _nocheck__trace_qed_alloc_l2_cache_entry(void * l2_cache, void * entry)
{
    if (trace_event_get_state(TRACE_QED_ALLOC_L2_CACHE_ENTRY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_alloc_l2_cache_entry " "l2_cache %p entry %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , l2_cache, entry);
    }
}

static inline void trace_qed_alloc_l2_cache_entry(void * l2_cache, void * entry)
{
    if (true) {
        _nocheck__trace_qed_alloc_l2_cache_entry(l2_cache, entry);
    }
}

#define TRACE_QED_UNREF_L2_CACHE_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_UNREF_L2_CACHE_ENTRY) || \
    false)

static inline void _nocheck__trace_qed_unref_l2_cache_entry(void * entry, int ref)
{
    if (trace_event_get_state(TRACE_QED_UNREF_L2_CACHE_ENTRY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_unref_l2_cache_entry " "entry %p ref %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , entry, ref);
    }
}

static inline void trace_qed_unref_l2_cache_entry(void * entry, int ref)
{
    if (true) {
        _nocheck__trace_qed_unref_l2_cache_entry(entry, ref);
    }
}

#define TRACE_QED_FIND_L2_CACHE_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_FIND_L2_CACHE_ENTRY) || \
    false)

static inline void _nocheck__trace_qed_find_l2_cache_entry(void * l2_cache, void * entry, uint64_t offset, int ref)
{
    if (trace_event_get_state(TRACE_QED_FIND_L2_CACHE_ENTRY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_find_l2_cache_entry " "l2_cache %p entry %p offset %"PRIu64" ref %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , l2_cache, entry, offset, ref);
    }
}

static inline void trace_qed_find_l2_cache_entry(void * l2_cache, void * entry, uint64_t offset, int ref)
{
    if (true) {
        _nocheck__trace_qed_find_l2_cache_entry(l2_cache, entry, offset, ref);
    }
}

#define TRACE_QED_READ_TABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_READ_TABLE) || \
    false)

static inline void _nocheck__trace_qed_read_table(void * s, uint64_t offset, void * table)
{
    if (trace_event_get_state(TRACE_QED_READ_TABLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_read_table " "s %p offset %"PRIu64" table %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, offset, table);
    }
}

static inline void trace_qed_read_table(void * s, uint64_t offset, void * table)
{
    if (true) {
        _nocheck__trace_qed_read_table(s, offset, table);
    }
}

#define TRACE_QED_READ_TABLE_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_READ_TABLE_CB) || \
    false)

static inline void _nocheck__trace_qed_read_table_cb(void * s, void * table, int ret)
{
    if (trace_event_get_state(TRACE_QED_READ_TABLE_CB)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_read_table_cb " "s %p table %p ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, table, ret);
    }
}

static inline void trace_qed_read_table_cb(void * s, void * table, int ret)
{
    if (true) {
        _nocheck__trace_qed_read_table_cb(s, table, ret);
    }
}

#define TRACE_QED_WRITE_TABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_WRITE_TABLE) || \
    false)

static inline void _nocheck__trace_qed_write_table(void * s, uint64_t offset, void * table, unsigned int index, unsigned int n)
{
    if (trace_event_get_state(TRACE_QED_WRITE_TABLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_write_table " "s %p offset %"PRIu64" table %p index %u n %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, offset, table, index, n);
    }
}

static inline void trace_qed_write_table(void * s, uint64_t offset, void * table, unsigned int index, unsigned int n)
{
    if (true) {
        _nocheck__trace_qed_write_table(s, offset, table, index, n);
    }
}

#define TRACE_QED_WRITE_TABLE_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_WRITE_TABLE_CB) || \
    false)

static inline void _nocheck__trace_qed_write_table_cb(void * s, void * table, int flush, int ret)
{
    if (trace_event_get_state(TRACE_QED_WRITE_TABLE_CB)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_write_table_cb " "s %p table %p flush %d ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, table, flush, ret);
    }
}

static inline void trace_qed_write_table_cb(void * s, void * table, int flush, int ret)
{
    if (true) {
        _nocheck__trace_qed_write_table_cb(s, table, flush, ret);
    }
}

#define TRACE_QED_NEED_CHECK_TIMER_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_NEED_CHECK_TIMER_CB) || \
    false)

static inline void _nocheck__trace_qed_need_check_timer_cb(void * s)
{
    if (trace_event_get_state(TRACE_QED_NEED_CHECK_TIMER_CB)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_need_check_timer_cb " "s %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s);
    }
}

static inline void trace_qed_need_check_timer_cb(void * s)
{
    if (true) {
        _nocheck__trace_qed_need_check_timer_cb(s);
    }
}

#define TRACE_QED_START_NEED_CHECK_TIMER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_START_NEED_CHECK_TIMER) || \
    false)

static inline void _nocheck__trace_qed_start_need_check_timer(void * s)
{
    if (trace_event_get_state(TRACE_QED_START_NEED_CHECK_TIMER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_start_need_check_timer " "s %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s);
    }
}

static inline void trace_qed_start_need_check_timer(void * s)
{
    if (true) {
        _nocheck__trace_qed_start_need_check_timer(s);
    }
}

#define TRACE_QED_CANCEL_NEED_CHECK_TIMER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_CANCEL_NEED_CHECK_TIMER) || \
    false)

static inline void _nocheck__trace_qed_cancel_need_check_timer(void * s)
{
    if (trace_event_get_state(TRACE_QED_CANCEL_NEED_CHECK_TIMER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_cancel_need_check_timer " "s %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s);
    }
}

static inline void trace_qed_cancel_need_check_timer(void * s)
{
    if (true) {
        _nocheck__trace_qed_cancel_need_check_timer(s);
    }
}

#define TRACE_QED_AIO_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_COMPLETE) || \
    false)

static inline void _nocheck__trace_qed_aio_complete(void * s, void * acb, int ret)
{
    if (trace_event_get_state(TRACE_QED_AIO_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_aio_complete " "s %p acb %p ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, acb, ret);
    }
}

static inline void trace_qed_aio_complete(void * s, void * acb, int ret)
{
    if (true) {
        _nocheck__trace_qed_aio_complete(s, acb, ret);
    }
}

#define TRACE_QED_AIO_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_SETUP) || \
    false)

static inline void _nocheck__trace_qed_aio_setup(void * s, void * acb, int64_t sector_num, int nb_sectors, void * opaque, int flags)
{
    if (trace_event_get_state(TRACE_QED_AIO_SETUP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_aio_setup " "s %p acb %p sector_num %"PRId64" nb_sectors %d opaque %p flags 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, acb, sector_num, nb_sectors, opaque, flags);
    }
}

static inline void trace_qed_aio_setup(void * s, void * acb, int64_t sector_num, int nb_sectors, void * opaque, int flags)
{
    if (true) {
        _nocheck__trace_qed_aio_setup(s, acb, sector_num, nb_sectors, opaque, flags);
    }
}

#define TRACE_QED_AIO_NEXT_IO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_NEXT_IO) || \
    false)

static inline void _nocheck__trace_qed_aio_next_io(void * s, void * acb, int ret, uint64_t cur_pos)
{
    if (trace_event_get_state(TRACE_QED_AIO_NEXT_IO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_aio_next_io " "s %p acb %p ret %d cur_pos %"PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, acb, ret, cur_pos);
    }
}

static inline void trace_qed_aio_next_io(void * s, void * acb, int ret, uint64_t cur_pos)
{
    if (true) {
        _nocheck__trace_qed_aio_next_io(s, acb, ret, cur_pos);
    }
}

#define TRACE_QED_AIO_READ_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_READ_DATA) || \
    false)

static inline void _nocheck__trace_qed_aio_read_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (trace_event_get_state(TRACE_QED_AIO_READ_DATA)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_aio_read_data " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, acb, ret, offset, len);
    }
}

static inline void trace_qed_aio_read_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (true) {
        _nocheck__trace_qed_aio_read_data(s, acb, ret, offset, len);
    }
}

#define TRACE_QED_AIO_WRITE_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_WRITE_DATA) || \
    false)

static inline void _nocheck__trace_qed_aio_write_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (trace_event_get_state(TRACE_QED_AIO_WRITE_DATA)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_aio_write_data " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, acb, ret, offset, len);
    }
}

static inline void trace_qed_aio_write_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (true) {
        _nocheck__trace_qed_aio_write_data(s, acb, ret, offset, len);
    }
}

#define TRACE_QED_AIO_WRITE_PREFILL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_WRITE_PREFILL) || \
    false)

static inline void _nocheck__trace_qed_aio_write_prefill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    if (trace_event_get_state(TRACE_QED_AIO_WRITE_PREFILL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_aio_write_prefill " "s %p acb %p start %"PRIu64" len %zu offset %"PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, acb, start, len, offset);
    }
}

static inline void trace_qed_aio_write_prefill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    if (true) {
        _nocheck__trace_qed_aio_write_prefill(s, acb, start, len, offset);
    }
}

#define TRACE_QED_AIO_WRITE_POSTFILL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_WRITE_POSTFILL) || \
    false)

static inline void _nocheck__trace_qed_aio_write_postfill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    if (trace_event_get_state(TRACE_QED_AIO_WRITE_POSTFILL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_aio_write_postfill " "s %p acb %p start %"PRIu64" len %zu offset %"PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, acb, start, len, offset);
    }
}

static inline void trace_qed_aio_write_postfill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    if (true) {
        _nocheck__trace_qed_aio_write_postfill(s, acb, start, len, offset);
    }
}

#define TRACE_QED_AIO_WRITE_MAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QED_AIO_WRITE_MAIN) || \
    false)

static inline void _nocheck__trace_qed_aio_write_main(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (trace_event_get_state(TRACE_QED_AIO_WRITE_MAIN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qed_aio_write_main " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, acb, ret, offset, len);
    }
}

static inline void trace_qed_aio_write_main(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    if (true) {
        _nocheck__trace_qed_aio_write_main(s, acb, ret, offset, len);
    }
}

#define TRACE_VXHS_IIO_CALLBACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_IIO_CALLBACK) || \
    false)

static inline void _nocheck__trace_vxhs_iio_callback(int error)
{
    if (trace_event_get_state(TRACE_VXHS_IIO_CALLBACK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_iio_callback " "ctx is NULL: error %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , error);
    }
}

static inline void trace_vxhs_iio_callback(int error)
{
    if (true) {
        _nocheck__trace_vxhs_iio_callback(error);
    }
}

#define TRACE_VXHS_IIO_CALLBACK_CHNFAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_IIO_CALLBACK_CHNFAIL) || \
    false)

static inline void _nocheck__trace_vxhs_iio_callback_chnfail(int err, int error)
{
    if (trace_event_get_state(TRACE_VXHS_IIO_CALLBACK_CHNFAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_iio_callback_chnfail " "QNIO channel failed, no i/o %d, %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , err, error);
    }
}

static inline void trace_vxhs_iio_callback_chnfail(int err, int error)
{
    if (true) {
        _nocheck__trace_vxhs_iio_callback_chnfail(err, error);
    }
}

#define TRACE_VXHS_IIO_CALLBACK_UNKNWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_IIO_CALLBACK_UNKNWN) || \
    false)

static inline void _nocheck__trace_vxhs_iio_callback_unknwn(int opcode, int err)
{
    if (trace_event_get_state(TRACE_VXHS_IIO_CALLBACK_UNKNWN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_iio_callback_unknwn " "unexpected opcode %d, errno %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , opcode, err);
    }
}

static inline void trace_vxhs_iio_callback_unknwn(int opcode, int err)
{
    if (true) {
        _nocheck__trace_vxhs_iio_callback_unknwn(opcode, err);
    }
}

#define TRACE_VXHS_AIO_RW_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_AIO_RW_INVALID) || \
    false)

static inline void _nocheck__trace_vxhs_aio_rw_invalid(int req)
{
    if (trace_event_get_state(TRACE_VXHS_AIO_RW_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_aio_rw_invalid " "Invalid I/O request iodir %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , req);
    }
}

static inline void trace_vxhs_aio_rw_invalid(int req)
{
    if (true) {
        _nocheck__trace_vxhs_aio_rw_invalid(req);
    }
}

#define TRACE_VXHS_AIO_RW_IOERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_AIO_RW_IOERR) || \
    false)

static inline void _nocheck__trace_vxhs_aio_rw_ioerr(char * guid, int iodir, uint64_t size, uint64_t off, void * acb, int ret, int err)
{
    if (trace_event_get_state(TRACE_VXHS_AIO_RW_IOERR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_aio_rw_ioerr " "IO ERROR (vDisk %s) FOR : Read/Write = %d size = %"PRIu64" offset = %"PRIu64" ACB = %p. Error = %d, errno = %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , guid, iodir, size, off, acb, ret, err);
    }
}

static inline void trace_vxhs_aio_rw_ioerr(char * guid, int iodir, uint64_t size, uint64_t off, void * acb, int ret, int err)
{
    if (true) {
        _nocheck__trace_vxhs_aio_rw_ioerr(guid, iodir, size, off, acb, ret, err);
    }
}

#define TRACE_VXHS_GET_VDISK_STAT_ERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_GET_VDISK_STAT_ERR) || \
    false)

static inline void _nocheck__trace_vxhs_get_vdisk_stat_err(char * guid, int ret, int err)
{
    if (trace_event_get_state(TRACE_VXHS_GET_VDISK_STAT_ERR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_get_vdisk_stat_err " "vDisk (%s) stat ioctl failed, ret = %d, errno = %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , guid, ret, err);
    }
}

static inline void trace_vxhs_get_vdisk_stat_err(char * guid, int ret, int err)
{
    if (true) {
        _nocheck__trace_vxhs_get_vdisk_stat_err(guid, ret, err);
    }
}

#define TRACE_VXHS_GET_VDISK_STAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_GET_VDISK_STAT) || \
    false)

static inline void _nocheck__trace_vxhs_get_vdisk_stat(char * vdisk_guid, uint64_t vdisk_size)
{
    if (trace_event_get_state(TRACE_VXHS_GET_VDISK_STAT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_get_vdisk_stat " "vDisk %s stat ioctl returned size %"PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , vdisk_guid, vdisk_size);
    }
}

static inline void trace_vxhs_get_vdisk_stat(char * vdisk_guid, uint64_t vdisk_size)
{
    if (true) {
        _nocheck__trace_vxhs_get_vdisk_stat(vdisk_guid, vdisk_size);
    }
}

#define TRACE_VXHS_COMPLETE_AIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_COMPLETE_AIO) || \
    false)

static inline void _nocheck__trace_vxhs_complete_aio(void * acb, uint64_t ret)
{
    if (trace_event_get_state(TRACE_VXHS_COMPLETE_AIO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_complete_aio " "aio failed acb %p ret %"PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , acb, ret);
    }
}

static inline void trace_vxhs_complete_aio(void * acb, uint64_t ret)
{
    if (true) {
        _nocheck__trace_vxhs_complete_aio(acb, ret);
    }
}

#define TRACE_VXHS_PARSE_URI_FILENAME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_PARSE_URI_FILENAME) || \
    false)

static inline void _nocheck__trace_vxhs_parse_uri_filename(const char * filename)
{
    if (trace_event_get_state(TRACE_VXHS_PARSE_URI_FILENAME)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_parse_uri_filename " "URI passed via bdrv_parse_filename %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , filename);
    }
}

static inline void trace_vxhs_parse_uri_filename(const char * filename)
{
    if (true) {
        _nocheck__trace_vxhs_parse_uri_filename(filename);
    }
}

#define TRACE_VXHS_OPEN_VDISKID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_OPEN_VDISKID) || \
    false)

static inline void _nocheck__trace_vxhs_open_vdiskid(const char * vdisk_id)
{
    if (trace_event_get_state(TRACE_VXHS_OPEN_VDISKID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_open_vdiskid " "Opening vdisk-id %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , vdisk_id);
    }
}

static inline void trace_vxhs_open_vdiskid(const char * vdisk_id)
{
    if (true) {
        _nocheck__trace_vxhs_open_vdiskid(vdisk_id);
    }
}

#define TRACE_VXHS_OPEN_HOSTINFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_OPEN_HOSTINFO) || \
    false)

static inline void _nocheck__trace_vxhs_open_hostinfo(char * of_vsa_addr, int port)
{
    if (trace_event_get_state(TRACE_VXHS_OPEN_HOSTINFO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_open_hostinfo " "Adding host %s:%d to BDRVVXHSState" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , of_vsa_addr, port);
    }
}

static inline void trace_vxhs_open_hostinfo(char * of_vsa_addr, int port)
{
    if (true) {
        _nocheck__trace_vxhs_open_hostinfo(of_vsa_addr, port);
    }
}

#define TRACE_VXHS_OPEN_IIO_OPEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_OPEN_IIO_OPEN) || \
    false)

static inline void _nocheck__trace_vxhs_open_iio_open(const char * host)
{
    if (trace_event_get_state(TRACE_VXHS_OPEN_IIO_OPEN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_open_iio_open " "Failed to connect to storage agent on host %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , host);
    }
}

static inline void trace_vxhs_open_iio_open(const char * host)
{
    if (true) {
        _nocheck__trace_vxhs_open_iio_open(host);
    }
}

#define TRACE_VXHS_PARSE_URI_HOSTINFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_PARSE_URI_HOSTINFO) || \
    false)

static inline void _nocheck__trace_vxhs_parse_uri_hostinfo(char * host, int port)
{
    if (trace_event_get_state(TRACE_VXHS_PARSE_URI_HOSTINFO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_parse_uri_hostinfo " "Host: IP %s, Port %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , host, port);
    }
}

static inline void trace_vxhs_parse_uri_hostinfo(char * host, int port)
{
    if (true) {
        _nocheck__trace_vxhs_parse_uri_hostinfo(host, port);
    }
}

#define TRACE_VXHS_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_CLOSE) || \
    false)

static inline void _nocheck__trace_vxhs_close(char * vdisk_guid)
{
    if (trace_event_get_state(TRACE_VXHS_CLOSE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_close " "Closing vdisk %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , vdisk_guid);
    }
}

static inline void trace_vxhs_close(char * vdisk_guid)
{
    if (true) {
        _nocheck__trace_vxhs_close(vdisk_guid);
    }
}

#define TRACE_VXHS_GET_CREDS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VXHS_GET_CREDS) || \
    false)

static inline void _nocheck__trace_vxhs_get_creds(const char * cacert, const char * client_key, const char * client_cert)
{
    if (trace_event_get_state(TRACE_VXHS_GET_CREDS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vxhs_get_creds " "cacert %s, client_key %s, client_cert %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cacert, client_key, client_cert);
    }
}

static inline void trace_vxhs_get_creds(const char * cacert, const char * client_key, const char * client_cert)
{
    if (true) {
        _nocheck__trace_vxhs_get_creds(cacert, client_key, client_cert);
    }
}

#define TRACE_NVME_KICK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_KICK) || \
    false)

static inline void _nocheck__trace_nvme_kick(void * s, int queue)
{
    if (trace_event_get_state(TRACE_NVME_KICK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_kick " "s %p queue %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, queue);
    }
}

static inline void trace_nvme_kick(void * s, int queue)
{
    if (true) {
        _nocheck__trace_nvme_kick(s, queue);
    }
}

#define TRACE_NVME_DMA_FLUSH_QUEUE_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_DMA_FLUSH_QUEUE_WAIT) || \
    false)

static inline void _nocheck__trace_nvme_dma_flush_queue_wait(void * s)
{
    if (trace_event_get_state(TRACE_NVME_DMA_FLUSH_QUEUE_WAIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_dma_flush_queue_wait " "s %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s);
    }
}

static inline void trace_nvme_dma_flush_queue_wait(void * s)
{
    if (true) {
        _nocheck__trace_nvme_dma_flush_queue_wait(s);
    }
}

#define TRACE_NVME_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_ERROR) || \
    false)

static inline void _nocheck__trace_nvme_error(int cmd_specific, int sq_head, int sqid, int cid, int status)
{
    if (trace_event_get_state(TRACE_NVME_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_error " "cmd_specific %d sq_head %d sqid %d cid %d status 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cmd_specific, sq_head, sqid, cid, status);
    }
}

static inline void trace_nvme_error(int cmd_specific, int sq_head, int sqid, int cid, int status)
{
    if (true) {
        _nocheck__trace_nvme_error(cmd_specific, sq_head, sqid, cid, status);
    }
}

#define TRACE_NVME_PROCESS_COMPLETION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_PROCESS_COMPLETION) || \
    false)

static inline void _nocheck__trace_nvme_process_completion(void * s, int index, int inflight)
{
    if (trace_event_get_state(TRACE_NVME_PROCESS_COMPLETION)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_process_completion " "s %p queue %d inflight %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, index, inflight);
    }
}

static inline void trace_nvme_process_completion(void * s, int index, int inflight)
{
    if (true) {
        _nocheck__trace_nvme_process_completion(s, index, inflight);
    }
}

#define TRACE_NVME_PROCESS_COMPLETION_QUEUE_BUSY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_PROCESS_COMPLETION_QUEUE_BUSY) || \
    false)

static inline void _nocheck__trace_nvme_process_completion_queue_busy(void * s, int index)
{
    if (trace_event_get_state(TRACE_NVME_PROCESS_COMPLETION_QUEUE_BUSY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_process_completion_queue_busy " "s %p queue %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, index);
    }
}

static inline void trace_nvme_process_completion_queue_busy(void * s, int index)
{
    if (true) {
        _nocheck__trace_nvme_process_completion_queue_busy(s, index);
    }
}

#define TRACE_NVME_COMPLETE_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_COMPLETE_COMMAND) || \
    false)

static inline void _nocheck__trace_nvme_complete_command(void * s, int index, int cid)
{
    if (trace_event_get_state(TRACE_NVME_COMPLETE_COMMAND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_complete_command " "s %p queue %d cid %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, index, cid);
    }
}

static inline void trace_nvme_complete_command(void * s, int index, int cid)
{
    if (true) {
        _nocheck__trace_nvme_complete_command(s, index, cid);
    }
}

#define TRACE_NVME_SUBMIT_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_SUBMIT_COMMAND) || \
    false)

static inline void _nocheck__trace_nvme_submit_command(void * s, int index, int cid)
{
    if (trace_event_get_state(TRACE_NVME_SUBMIT_COMMAND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_submit_command " "s %p queue %d cid %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, index, cid);
    }
}

static inline void trace_nvme_submit_command(void * s, int index, int cid)
{
    if (true) {
        _nocheck__trace_nvme_submit_command(s, index, cid);
    }
}

#define TRACE_NVME_SUBMIT_COMMAND_RAW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_SUBMIT_COMMAND_RAW) || \
    false)

static inline void _nocheck__trace_nvme_submit_command_raw(int c0, int c1, int c2, int c3, int c4, int c5, int c6, int c7)
{
    if (trace_event_get_state(TRACE_NVME_SUBMIT_COMMAND_RAW)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_submit_command_raw " "%02x %02x %02x %02x %02x %02x %02x %02x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , c0, c1, c2, c3, c4, c5, c6, c7);
    }
}

static inline void trace_nvme_submit_command_raw(int c0, int c1, int c2, int c3, int c4, int c5, int c6, int c7)
{
    if (true) {
        _nocheck__trace_nvme_submit_command_raw(c0, c1, c2, c3, c4, c5, c6, c7);
    }
}

#define TRACE_NVME_HANDLE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_HANDLE_EVENT) || \
    false)

static inline void _nocheck__trace_nvme_handle_event(void * s)
{
    if (trace_event_get_state(TRACE_NVME_HANDLE_EVENT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_handle_event " "s %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s);
    }
}

static inline void trace_nvme_handle_event(void * s)
{
    if (true) {
        _nocheck__trace_nvme_handle_event(s);
    }
}

#define TRACE_NVME_POLL_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_POLL_CB) || \
    false)

static inline void _nocheck__trace_nvme_poll_cb(void * s)
{
    if (trace_event_get_state(TRACE_NVME_POLL_CB)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_poll_cb " "s %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s);
    }
}

static inline void trace_nvme_poll_cb(void * s)
{
    if (true) {
        _nocheck__trace_nvme_poll_cb(s);
    }
}

#define TRACE_NVME_PRW_ALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_PRW_ALIGNED) || \
    false)

static inline void _nocheck__trace_nvme_prw_aligned(void * s, int is_write, uint64_t offset, uint64_t bytes, int flags, int niov)
{
    if (trace_event_get_state(TRACE_NVME_PRW_ALIGNED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_prw_aligned " "s %p is_write %d offset %"PRId64" bytes %"PRId64" flags %d niov %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, is_write, offset, bytes, flags, niov);
    }
}

static inline void trace_nvme_prw_aligned(void * s, int is_write, uint64_t offset, uint64_t bytes, int flags, int niov)
{
    if (true) {
        _nocheck__trace_nvme_prw_aligned(s, is_write, offset, bytes, flags, niov);
    }
}

#define TRACE_NVME_QIOV_UNALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_QIOV_UNALIGNED) || \
    false)

static inline void _nocheck__trace_nvme_qiov_unaligned(const void * qiov, int n, void * base, size_t size, int align)
{
    if (trace_event_get_state(TRACE_NVME_QIOV_UNALIGNED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_qiov_unaligned " "qiov %p n %d base %p size 0x%zx align 0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , qiov, n, base, size, align);
    }
}

static inline void trace_nvme_qiov_unaligned(const void * qiov, int n, void * base, size_t size, int align)
{
    if (true) {
        _nocheck__trace_nvme_qiov_unaligned(qiov, n, base, size, align);
    }
}

#define TRACE_NVME_PRW_BUFFERED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_PRW_BUFFERED) || \
    false)

static inline void _nocheck__trace_nvme_prw_buffered(void * s, uint64_t offset, uint64_t bytes, int niov, int is_write)
{
    if (trace_event_get_state(TRACE_NVME_PRW_BUFFERED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_prw_buffered " "s %p offset %"PRId64" bytes %"PRId64" niov %d is_write %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, offset, bytes, niov, is_write);
    }
}

static inline void trace_nvme_prw_buffered(void * s, uint64_t offset, uint64_t bytes, int niov, int is_write)
{
    if (true) {
        _nocheck__trace_nvme_prw_buffered(s, offset, bytes, niov, is_write);
    }
}

#define TRACE_NVME_RW_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_RW_DONE) || \
    false)

static inline void _nocheck__trace_nvme_rw_done(void * s, int is_write, uint64_t offset, uint64_t bytes, int ret)
{
    if (trace_event_get_state(TRACE_NVME_RW_DONE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_rw_done " "s %p is_write %d offset %"PRId64" bytes %"PRId64" ret %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, is_write, offset, bytes, ret);
    }
}

static inline void trace_nvme_rw_done(void * s, int is_write, uint64_t offset, uint64_t bytes, int ret)
{
    if (true) {
        _nocheck__trace_nvme_rw_done(s, is_write, offset, bytes, ret);
    }
}

#define TRACE_NVME_DMA_MAP_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_DMA_MAP_FLUSH) || \
    false)

static inline void _nocheck__trace_nvme_dma_map_flush(void * s)
{
    if (trace_event_get_state(TRACE_NVME_DMA_MAP_FLUSH)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_dma_map_flush " "s %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s);
    }
}

static inline void trace_nvme_dma_map_flush(void * s)
{
    if (true) {
        _nocheck__trace_nvme_dma_map_flush(s);
    }
}

#define TRACE_NVME_FREE_REQ_QUEUE_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_FREE_REQ_QUEUE_WAIT) || \
    false)

static inline void _nocheck__trace_nvme_free_req_queue_wait(void * q)
{
    if (trace_event_get_state(TRACE_NVME_FREE_REQ_QUEUE_WAIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_free_req_queue_wait " "q %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , q);
    }
}

static inline void trace_nvme_free_req_queue_wait(void * q)
{
    if (true) {
        _nocheck__trace_nvme_free_req_queue_wait(q);
    }
}

#define TRACE_NVME_CMD_MAP_QIOV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CMD_MAP_QIOV) || \
    false)

static inline void _nocheck__trace_nvme_cmd_map_qiov(void * s, void * cmd, void * req, void * qiov, int entries)
{
    if (trace_event_get_state(TRACE_NVME_CMD_MAP_QIOV)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_cmd_map_qiov " "s %p cmd %p req %p qiov %p entries %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, cmd, req, qiov, entries);
    }
}

static inline void trace_nvme_cmd_map_qiov(void * s, void * cmd, void * req, void * qiov, int entries)
{
    if (true) {
        _nocheck__trace_nvme_cmd_map_qiov(s, cmd, req, qiov, entries);
    }
}

#define TRACE_NVME_CMD_MAP_QIOV_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CMD_MAP_QIOV_PAGES) || \
    false)

static inline void _nocheck__trace_nvme_cmd_map_qiov_pages(void * s, int i, uint64_t page)
{
    if (trace_event_get_state(TRACE_NVME_CMD_MAP_QIOV_PAGES)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_cmd_map_qiov_pages " "s %p page[%d] 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, i, page);
    }
}

static inline void trace_nvme_cmd_map_qiov_pages(void * s, int i, uint64_t page)
{
    if (true) {
        _nocheck__trace_nvme_cmd_map_qiov_pages(s, i, page);
    }
}

#define TRACE_NVME_CMD_MAP_QIOV_IOV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NVME_CMD_MAP_QIOV_IOV) || \
    false)

static inline void _nocheck__trace_nvme_cmd_map_qiov_iov(void * s, int i, void * page, int pages)
{
    if (trace_event_get_state(TRACE_NVME_CMD_MAP_QIOV_IOV)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:nvme_cmd_map_qiov_iov " "s %p iov[%d] %p pages %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , s, i, page, pages);
    }
}

static inline void trace_nvme_cmd_map_qiov_iov(void * s, int i, void * page, int pages)
{
    if (true) {
        _nocheck__trace_nvme_cmd_map_qiov_iov(s, i, page, pages);
    }
}
#endif /* TRACE_BLOCK_GENERATED_TRACERS_H */
