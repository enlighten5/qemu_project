/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_MIGRATION_GENERATED_TRACERS_H
#define TRACE_MIGRATION_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_QEMU_LOADVM_STATE_SECTION_EVENT;
extern TraceEvent _TRACE_QEMU_LOADVM_STATE_SECTION_COMMAND_EVENT;
extern TraceEvent _TRACE_QEMU_LOADVM_STATE_SECTION_PARTEND_EVENT;
extern TraceEvent _TRACE_QEMU_LOADVM_STATE_POST_MAIN_EVENT;
extern TraceEvent _TRACE_QEMU_LOADVM_STATE_SECTION_STARTFULL_EVENT;
extern TraceEvent _TRACE_QEMU_SAVEVM_SEND_PACKAGED_EVENT;
extern TraceEvent _TRACE_LOADVM_STATE_SETUP_EVENT;
extern TraceEvent _TRACE_LOADVM_STATE_CLEANUP_EVENT;
extern TraceEvent _TRACE_LOADVM_HANDLE_CMD_PACKAGED_EVENT;
extern TraceEvent _TRACE_LOADVM_HANDLE_CMD_PACKAGED_MAIN_EVENT;
extern TraceEvent _TRACE_LOADVM_HANDLE_CMD_PACKAGED_RECEIVED_EVENT;
extern TraceEvent _TRACE_LOADVM_POSTCOPY_HANDLE_ADVISE_EVENT;
extern TraceEvent _TRACE_LOADVM_POSTCOPY_HANDLE_LISTEN_EVENT;
extern TraceEvent _TRACE_LOADVM_POSTCOPY_HANDLE_RUN_EVENT;
extern TraceEvent _TRACE_LOADVM_POSTCOPY_HANDLE_RUN_CPU_SYNC_EVENT;
extern TraceEvent _TRACE_LOADVM_POSTCOPY_HANDLE_RUN_VMSTART_EVENT;
extern TraceEvent _TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_EVENT;
extern TraceEvent _TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_END_EVENT;
extern TraceEvent _TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_HEADER_EVENT;
extern TraceEvent _TRACE_LOADVM_PROCESS_COMMAND_EVENT;
extern TraceEvent _TRACE_LOADVM_PROCESS_COMMAND_PING_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_LISTEN_THREAD_EXIT_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_LISTEN_THREAD_START_EVENT;
extern TraceEvent _TRACE_QEMU_SAVEVM_SEND_POSTCOPY_ADVISE_EVENT;
extern TraceEvent _TRACE_QEMU_SAVEVM_SEND_POSTCOPY_RAM_DISCARD_EVENT;
extern TraceEvent _TRACE_SAVEVM_COMMAND_SEND_EVENT;
extern TraceEvent _TRACE_SAVEVM_SECTION_START_EVENT;
extern TraceEvent _TRACE_SAVEVM_SECTION_END_EVENT;
extern TraceEvent _TRACE_SAVEVM_SECTION_SKIP_EVENT;
extern TraceEvent _TRACE_SAVEVM_SEND_OPEN_RETURN_PATH_EVENT;
extern TraceEvent _TRACE_SAVEVM_SEND_PING_EVENT;
extern TraceEvent _TRACE_SAVEVM_SEND_POSTCOPY_LISTEN_EVENT;
extern TraceEvent _TRACE_SAVEVM_SEND_POSTCOPY_RUN_EVENT;
extern TraceEvent _TRACE_SAVEVM_STATE_SETUP_EVENT;
extern TraceEvent _TRACE_SAVEVM_STATE_HEADER_EVENT;
extern TraceEvent _TRACE_SAVEVM_STATE_ITERATE_EVENT;
extern TraceEvent _TRACE_SAVEVM_STATE_CLEANUP_EVENT;
extern TraceEvent _TRACE_SAVEVM_STATE_COMPLETE_PRECOPY_EVENT;
extern TraceEvent _TRACE_VMSTATE_SAVE_EVENT;
extern TraceEvent _TRACE_VMSTATE_SAVE_STATE_PRE_SAVE_RES_EVENT;
extern TraceEvent _TRACE_VMSTATE_SAVE_STATE_LOOP_EVENT;
extern TraceEvent _TRACE_VMSTATE_SAVE_STATE_TOP_EVENT;
extern TraceEvent _TRACE_VMSTATE_SUBSECTION_SAVE_LOOP_EVENT;
extern TraceEvent _TRACE_VMSTATE_SUBSECTION_SAVE_TOP_EVENT;
extern TraceEvent _TRACE_VMSTATE_LOAD_EVENT;
extern TraceEvent _TRACE_QEMU_ANNOUNCE_SELF_ITER_EVENT;
extern TraceEvent _TRACE_VMSTATE_LOAD_FIELD_ERROR_EVENT;
extern TraceEvent _TRACE_VMSTATE_LOAD_STATE_EVENT;
extern TraceEvent _TRACE_VMSTATE_LOAD_STATE_END_EVENT;
extern TraceEvent _TRACE_VMSTATE_LOAD_STATE_FIELD_EVENT;
extern TraceEvent _TRACE_VMSTATE_N_ELEMS_EVENT;
extern TraceEvent _TRACE_VMSTATE_SUBSECTION_LOAD_EVENT;
extern TraceEvent _TRACE_VMSTATE_SUBSECTION_LOAD_BAD_EVENT;
extern TraceEvent _TRACE_VMSTATE_SUBSECTION_LOAD_GOOD_EVENT;
extern TraceEvent _TRACE_GET_QTAILQ_EVENT;
extern TraceEvent _TRACE_GET_QTAILQ_END_EVENT;
extern TraceEvent _TRACE_PUT_QTAILQ_EVENT;
extern TraceEvent _TRACE_PUT_QTAILQ_END_EVENT;
extern TraceEvent _TRACE_QEMU_FILE_FCLOSE_EVENT;
extern TraceEvent _TRACE_GET_QUEUED_PAGE_EVENT;
extern TraceEvent _TRACE_GET_QUEUED_PAGE_NOT_DIRTY_EVENT;
extern TraceEvent _TRACE_MIGRATION_BITMAP_SYNC_START_EVENT;
extern TraceEvent _TRACE_MIGRATION_BITMAP_SYNC_END_EVENT;
extern TraceEvent _TRACE_MIGRATION_THROTTLE_EVENT;
extern TraceEvent _TRACE_RAM_DISCARD_RANGE_EVENT;
extern TraceEvent _TRACE_RAM_LOAD_LOOP_EVENT;
extern TraceEvent _TRACE_RAM_LOAD_POSTCOPY_LOOP_EVENT;
extern TraceEvent _TRACE_RAM_POSTCOPY_SEND_DISCARD_BITMAP_EVENT;
extern TraceEvent _TRACE_RAM_SAVE_PAGE_EVENT;
extern TraceEvent _TRACE_RAM_SAVE_QUEUE_PAGES_EVENT;
extern TraceEvent _TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_CLOSE_EVENT;
extern TraceEvent _TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_JOINING_EVENT;
extern TraceEvent _TRACE_MIGRATE_SET_STATE_EVENT;
extern TraceEvent _TRACE_MIGRATE_FD_CLEANUP_EVENT;
extern TraceEvent _TRACE_MIGRATE_FD_ERROR_EVENT;
extern TraceEvent _TRACE_MIGRATE_FD_CANCEL_EVENT;
extern TraceEvent _TRACE_MIGRATE_HANDLE_RP_REQ_PAGES_EVENT;
extern TraceEvent _TRACE_MIGRATE_PENDING_EVENT;
extern TraceEvent _TRACE_MIGRATE_SEND_RP_MESSAGE_EVENT;
extern TraceEvent _TRACE_MIGRATION_COMPLETION_FILE_ERR_EVENT;
extern TraceEvent _TRACE_MIGRATION_COMPLETION_POSTCOPY_END_EVENT;
extern TraceEvent _TRACE_MIGRATION_COMPLETION_POSTCOPY_END_AFTER_COMPLETE_EVENT;
extern TraceEvent _TRACE_MIGRATION_RETURN_PATH_END_BEFORE_EVENT;
extern TraceEvent _TRACE_MIGRATION_RETURN_PATH_END_AFTER_EVENT;
extern TraceEvent _TRACE_MIGRATION_THREAD_AFTER_LOOP_EVENT;
extern TraceEvent _TRACE_MIGRATION_THREAD_FILE_ERR_EVENT;
extern TraceEvent _TRACE_MIGRATION_THREAD_SETUP_COMPLETE_EVENT;
extern TraceEvent _TRACE_OPEN_RETURN_PATH_ON_SOURCE_EVENT;
extern TraceEvent _TRACE_OPEN_RETURN_PATH_ON_SOURCE_CONTINUE_EVENT;
extern TraceEvent _TRACE_POSTCOPY_START_EVENT;
extern TraceEvent _TRACE_POSTCOPY_START_SET_RUN_EVENT;
extern TraceEvent _TRACE_SOURCE_RETURN_PATH_THREAD_BAD_END_EVENT;
extern TraceEvent _TRACE_SOURCE_RETURN_PATH_THREAD_END_EVENT;
extern TraceEvent _TRACE_SOURCE_RETURN_PATH_THREAD_ENTRY_EVENT;
extern TraceEvent _TRACE_SOURCE_RETURN_PATH_THREAD_LOOP_TOP_EVENT;
extern TraceEvent _TRACE_SOURCE_RETURN_PATH_THREAD_PONG_EVENT;
extern TraceEvent _TRACE_SOURCE_RETURN_PATH_THREAD_SHUT_EVENT;
extern TraceEvent _TRACE_MIGRATE_GLOBAL_STATE_POST_LOAD_EVENT;
extern TraceEvent _TRACE_MIGRATE_GLOBAL_STATE_PRE_SAVE_EVENT;
extern TraceEvent _TRACE_MIGRATION_THREAD_LOW_PENDING_EVENT;
extern TraceEvent _TRACE_MIGRATE_STATE_TOO_BIG_EVENT;
extern TraceEvent _TRACE_MIGRATE_TRANSFERRED_EVENT;
extern TraceEvent _TRACE_PROCESS_INCOMING_MIGRATION_CO_END_EVENT;
extern TraceEvent _TRACE_PROCESS_INCOMING_MIGRATION_CO_POSTCOPY_END_MAIN_EVENT;
extern TraceEvent _TRACE_MIGRATION_SET_INCOMING_CHANNEL_EVENT;
extern TraceEvent _TRACE_MIGRATION_SET_OUTGOING_CHANNEL_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION_ACCEPTED_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_ACCEPT_PIN_STATE_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_ACCEPT_PIN_VERBSC_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_BLOCK_FOR_WRID_MISS_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_CLEANUP_DISCONNECT_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_CLEANUP_WAITING_FOR_DISCONNECT_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_CLOSE_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_CONNECT_PIN_ALL_REQUESTED_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_CONNECT_PIN_ALL_OUTCOME_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_DEST_INIT_TRYING_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_DUMP_GID_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_START_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_NONE_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_EXCHANGE_SEND_ISSUE_CALLBACK_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_EXCHANGE_SEND_WAITING_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_EXCHANGE_SEND_RECEIVED_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_FILL_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_INIT_RAM_BLOCKS_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_POLL_RECV_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_POLL_WRITE_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_POLL_OTHER_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_POST_SEND_CONTROL_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTER_AND_GET_KEYS_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_COMPRESS_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_FINISHED_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS_LOOP_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_LOOP_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_RKEY_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_LOOP_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_SUCCESS_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_WAIT_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_START_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_STOP_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_REGISTRATION_STOP_RAM_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_RESOLVE_HOST_TRYING_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_APPEND_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_ALREADY_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_UNREGISTER_WAITING_INFLIGHT_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_UNREGISTER_WAITING_PROC_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_UNREGISTER_WAITING_SEND_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_UNREGISTER_WAITING_COMPLETE_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_WRITE_FLUSH_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_WRITE_ONE_BLOCK_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_WRITE_ONE_POST_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_WRITE_ONE_QUEUE_FULL_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_WRITE_ONE_RECVREGRES_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_WRITE_ONE_SENDREG_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_WRITE_ONE_TOP_EVENT;
extern TraceEvent _TRACE_QEMU_RDMA_WRITE_ONE_ZERO_EVENT;
extern TraceEvent _TRACE_RDMA_ADD_BLOCK_EVENT;
extern TraceEvent _TRACE_RDMA_BLOCK_NOTIFICATION_HANDLE_EVENT;
extern TraceEvent _TRACE_RDMA_DELETE_BLOCK_EVENT;
extern TraceEvent _TRACE_RDMA_START_INCOMING_MIGRATION_EVENT;
extern TraceEvent _TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_DEST_INIT_EVENT;
extern TraceEvent _TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_RDMA_LISTEN_EVENT;
extern TraceEvent _TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_CONNECT_EVENT;
extern TraceEvent _TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_SOURCE_INIT_EVENT;
extern TraceEvent _TRACE_POSTCOPY_DISCARD_SEND_FINISH_EVENT;
extern TraceEvent _TRACE_POSTCOPY_DISCARD_SEND_RANGE_EVENT;
extern TraceEvent _TRACE_POSTCOPY_CLEANUP_RANGE_EVENT;
extern TraceEvent _TRACE_POSTCOPY_INIT_RANGE_EVENT;
extern TraceEvent _TRACE_POSTCOPY_NHP_RANGE_EVENT;
extern TraceEvent _TRACE_POSTCOPY_PLACE_PAGE_EVENT;
extern TraceEvent _TRACE_POSTCOPY_PLACE_PAGE_ZERO_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_ENABLE_NOTIFY_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_FAULT_THREAD_ENTRY_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_FAULT_THREAD_EXIT_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_FAULT_THREAD_QUIT_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_FAULT_THREAD_REQUEST_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_CLOSEUF_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_ENTRY_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_EXIT_EVENT;
extern TraceEvent _TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_JOIN_EVENT;
extern TraceEvent _TRACE_SAVE_XBZRLE_PAGE_SKIPPING_EVENT;
extern TraceEvent _TRACE_SAVE_XBZRLE_PAGE_OVERFLOW_EVENT;
extern TraceEvent _TRACE_RAM_SAVE_ITERATE_BIG_WAIT_EVENT;
extern TraceEvent _TRACE_RAM_LOAD_COMPLETE_EVENT;
extern TraceEvent _TRACE_MIGRATION_EXEC_OUTGOING_EVENT;
extern TraceEvent _TRACE_MIGRATION_EXEC_INCOMING_EVENT;
extern TraceEvent _TRACE_MIGRATION_FD_OUTGOING_EVENT;
extern TraceEvent _TRACE_MIGRATION_FD_INCOMING_EVENT;
extern TraceEvent _TRACE_MIGRATION_SOCKET_INCOMING_ACCEPTED_EVENT;
extern TraceEvent _TRACE_MIGRATION_SOCKET_OUTGOING_CONNECTED_EVENT;
extern TraceEvent _TRACE_MIGRATION_SOCKET_OUTGOING_ERROR_EVENT;
extern TraceEvent _TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_START_EVENT;
extern TraceEvent _TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_ERROR_EVENT;
extern TraceEvent _TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_COMPLETE_EVENT;
extern TraceEvent _TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_START_EVENT;
extern TraceEvent _TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_ERROR_EVENT;
extern TraceEvent _TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_COMPLETE_EVENT;
extern TraceEvent _TRACE_COLO_VM_STATE_CHANGE_EVENT;
extern TraceEvent _TRACE_COLO_SEND_MESSAGE_EVENT;
extern TraceEvent _TRACE_COLO_RECEIVE_MESSAGE_EVENT;
extern TraceEvent _TRACE_COLO_FAILOVER_SET_STATE_EVENT;
extern uint16_t _TRACE_QEMU_LOADVM_STATE_SECTION_DSTATE;
extern uint16_t _TRACE_QEMU_LOADVM_STATE_SECTION_COMMAND_DSTATE;
extern uint16_t _TRACE_QEMU_LOADVM_STATE_SECTION_PARTEND_DSTATE;
extern uint16_t _TRACE_QEMU_LOADVM_STATE_POST_MAIN_DSTATE;
extern uint16_t _TRACE_QEMU_LOADVM_STATE_SECTION_STARTFULL_DSTATE;
extern uint16_t _TRACE_QEMU_SAVEVM_SEND_PACKAGED_DSTATE;
extern uint16_t _TRACE_LOADVM_STATE_SETUP_DSTATE;
extern uint16_t _TRACE_LOADVM_STATE_CLEANUP_DSTATE;
extern uint16_t _TRACE_LOADVM_HANDLE_CMD_PACKAGED_DSTATE;
extern uint16_t _TRACE_LOADVM_HANDLE_CMD_PACKAGED_MAIN_DSTATE;
extern uint16_t _TRACE_LOADVM_HANDLE_CMD_PACKAGED_RECEIVED_DSTATE;
extern uint16_t _TRACE_LOADVM_POSTCOPY_HANDLE_ADVISE_DSTATE;
extern uint16_t _TRACE_LOADVM_POSTCOPY_HANDLE_LISTEN_DSTATE;
extern uint16_t _TRACE_LOADVM_POSTCOPY_HANDLE_RUN_DSTATE;
extern uint16_t _TRACE_LOADVM_POSTCOPY_HANDLE_RUN_CPU_SYNC_DSTATE;
extern uint16_t _TRACE_LOADVM_POSTCOPY_HANDLE_RUN_VMSTART_DSTATE;
extern uint16_t _TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_DSTATE;
extern uint16_t _TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_END_DSTATE;
extern uint16_t _TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_HEADER_DSTATE;
extern uint16_t _TRACE_LOADVM_PROCESS_COMMAND_DSTATE;
extern uint16_t _TRACE_LOADVM_PROCESS_COMMAND_PING_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_LISTEN_THREAD_EXIT_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_LISTEN_THREAD_START_DSTATE;
extern uint16_t _TRACE_QEMU_SAVEVM_SEND_POSTCOPY_ADVISE_DSTATE;
extern uint16_t _TRACE_QEMU_SAVEVM_SEND_POSTCOPY_RAM_DISCARD_DSTATE;
extern uint16_t _TRACE_SAVEVM_COMMAND_SEND_DSTATE;
extern uint16_t _TRACE_SAVEVM_SECTION_START_DSTATE;
extern uint16_t _TRACE_SAVEVM_SECTION_END_DSTATE;
extern uint16_t _TRACE_SAVEVM_SECTION_SKIP_DSTATE;
extern uint16_t _TRACE_SAVEVM_SEND_OPEN_RETURN_PATH_DSTATE;
extern uint16_t _TRACE_SAVEVM_SEND_PING_DSTATE;
extern uint16_t _TRACE_SAVEVM_SEND_POSTCOPY_LISTEN_DSTATE;
extern uint16_t _TRACE_SAVEVM_SEND_POSTCOPY_RUN_DSTATE;
extern uint16_t _TRACE_SAVEVM_STATE_SETUP_DSTATE;
extern uint16_t _TRACE_SAVEVM_STATE_HEADER_DSTATE;
extern uint16_t _TRACE_SAVEVM_STATE_ITERATE_DSTATE;
extern uint16_t _TRACE_SAVEVM_STATE_CLEANUP_DSTATE;
extern uint16_t _TRACE_SAVEVM_STATE_COMPLETE_PRECOPY_DSTATE;
extern uint16_t _TRACE_VMSTATE_SAVE_DSTATE;
extern uint16_t _TRACE_VMSTATE_SAVE_STATE_PRE_SAVE_RES_DSTATE;
extern uint16_t _TRACE_VMSTATE_SAVE_STATE_LOOP_DSTATE;
extern uint16_t _TRACE_VMSTATE_SAVE_STATE_TOP_DSTATE;
extern uint16_t _TRACE_VMSTATE_SUBSECTION_SAVE_LOOP_DSTATE;
extern uint16_t _TRACE_VMSTATE_SUBSECTION_SAVE_TOP_DSTATE;
extern uint16_t _TRACE_VMSTATE_LOAD_DSTATE;
extern uint16_t _TRACE_QEMU_ANNOUNCE_SELF_ITER_DSTATE;
extern uint16_t _TRACE_VMSTATE_LOAD_FIELD_ERROR_DSTATE;
extern uint16_t _TRACE_VMSTATE_LOAD_STATE_DSTATE;
extern uint16_t _TRACE_VMSTATE_LOAD_STATE_END_DSTATE;
extern uint16_t _TRACE_VMSTATE_LOAD_STATE_FIELD_DSTATE;
extern uint16_t _TRACE_VMSTATE_N_ELEMS_DSTATE;
extern uint16_t _TRACE_VMSTATE_SUBSECTION_LOAD_DSTATE;
extern uint16_t _TRACE_VMSTATE_SUBSECTION_LOAD_BAD_DSTATE;
extern uint16_t _TRACE_VMSTATE_SUBSECTION_LOAD_GOOD_DSTATE;
extern uint16_t _TRACE_GET_QTAILQ_DSTATE;
extern uint16_t _TRACE_GET_QTAILQ_END_DSTATE;
extern uint16_t _TRACE_PUT_QTAILQ_DSTATE;
extern uint16_t _TRACE_PUT_QTAILQ_END_DSTATE;
extern uint16_t _TRACE_QEMU_FILE_FCLOSE_DSTATE;
extern uint16_t _TRACE_GET_QUEUED_PAGE_DSTATE;
extern uint16_t _TRACE_GET_QUEUED_PAGE_NOT_DIRTY_DSTATE;
extern uint16_t _TRACE_MIGRATION_BITMAP_SYNC_START_DSTATE;
extern uint16_t _TRACE_MIGRATION_BITMAP_SYNC_END_DSTATE;
extern uint16_t _TRACE_MIGRATION_THROTTLE_DSTATE;
extern uint16_t _TRACE_RAM_DISCARD_RANGE_DSTATE;
extern uint16_t _TRACE_RAM_LOAD_LOOP_DSTATE;
extern uint16_t _TRACE_RAM_LOAD_POSTCOPY_LOOP_DSTATE;
extern uint16_t _TRACE_RAM_POSTCOPY_SEND_DISCARD_BITMAP_DSTATE;
extern uint16_t _TRACE_RAM_SAVE_PAGE_DSTATE;
extern uint16_t _TRACE_RAM_SAVE_QUEUE_PAGES_DSTATE;
extern uint16_t _TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_CLOSE_DSTATE;
extern uint16_t _TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_JOINING_DSTATE;
extern uint16_t _TRACE_MIGRATE_SET_STATE_DSTATE;
extern uint16_t _TRACE_MIGRATE_FD_CLEANUP_DSTATE;
extern uint16_t _TRACE_MIGRATE_FD_ERROR_DSTATE;
extern uint16_t _TRACE_MIGRATE_FD_CANCEL_DSTATE;
extern uint16_t _TRACE_MIGRATE_HANDLE_RP_REQ_PAGES_DSTATE;
extern uint16_t _TRACE_MIGRATE_PENDING_DSTATE;
extern uint16_t _TRACE_MIGRATE_SEND_RP_MESSAGE_DSTATE;
extern uint16_t _TRACE_MIGRATION_COMPLETION_FILE_ERR_DSTATE;
extern uint16_t _TRACE_MIGRATION_COMPLETION_POSTCOPY_END_DSTATE;
extern uint16_t _TRACE_MIGRATION_COMPLETION_POSTCOPY_END_AFTER_COMPLETE_DSTATE;
extern uint16_t _TRACE_MIGRATION_RETURN_PATH_END_BEFORE_DSTATE;
extern uint16_t _TRACE_MIGRATION_RETURN_PATH_END_AFTER_DSTATE;
extern uint16_t _TRACE_MIGRATION_THREAD_AFTER_LOOP_DSTATE;
extern uint16_t _TRACE_MIGRATION_THREAD_FILE_ERR_DSTATE;
extern uint16_t _TRACE_MIGRATION_THREAD_SETUP_COMPLETE_DSTATE;
extern uint16_t _TRACE_OPEN_RETURN_PATH_ON_SOURCE_DSTATE;
extern uint16_t _TRACE_OPEN_RETURN_PATH_ON_SOURCE_CONTINUE_DSTATE;
extern uint16_t _TRACE_POSTCOPY_START_DSTATE;
extern uint16_t _TRACE_POSTCOPY_START_SET_RUN_DSTATE;
extern uint16_t _TRACE_SOURCE_RETURN_PATH_THREAD_BAD_END_DSTATE;
extern uint16_t _TRACE_SOURCE_RETURN_PATH_THREAD_END_DSTATE;
extern uint16_t _TRACE_SOURCE_RETURN_PATH_THREAD_ENTRY_DSTATE;
extern uint16_t _TRACE_SOURCE_RETURN_PATH_THREAD_LOOP_TOP_DSTATE;
extern uint16_t _TRACE_SOURCE_RETURN_PATH_THREAD_PONG_DSTATE;
extern uint16_t _TRACE_SOURCE_RETURN_PATH_THREAD_SHUT_DSTATE;
extern uint16_t _TRACE_MIGRATE_GLOBAL_STATE_POST_LOAD_DSTATE;
extern uint16_t _TRACE_MIGRATE_GLOBAL_STATE_PRE_SAVE_DSTATE;
extern uint16_t _TRACE_MIGRATION_THREAD_LOW_PENDING_DSTATE;
extern uint16_t _TRACE_MIGRATE_STATE_TOO_BIG_DSTATE;
extern uint16_t _TRACE_MIGRATE_TRANSFERRED_DSTATE;
extern uint16_t _TRACE_PROCESS_INCOMING_MIGRATION_CO_END_DSTATE;
extern uint16_t _TRACE_PROCESS_INCOMING_MIGRATION_CO_POSTCOPY_END_MAIN_DSTATE;
extern uint16_t _TRACE_MIGRATION_SET_INCOMING_CHANNEL_DSTATE;
extern uint16_t _TRACE_MIGRATION_SET_OUTGOING_CHANNEL_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION_ACCEPTED_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_ACCEPT_PIN_STATE_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_ACCEPT_PIN_VERBSC_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_BLOCK_FOR_WRID_MISS_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_CLEANUP_DISCONNECT_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_CLEANUP_WAITING_FOR_DISCONNECT_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_CLOSE_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_CONNECT_PIN_ALL_REQUESTED_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_CONNECT_PIN_ALL_OUTCOME_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_DEST_INIT_TRYING_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_DUMP_GID_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_START_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_NONE_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_EXCHANGE_SEND_ISSUE_CALLBACK_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_EXCHANGE_SEND_WAITING_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_EXCHANGE_SEND_RECEIVED_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_FILL_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_INIT_RAM_BLOCKS_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_POLL_RECV_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_POLL_WRITE_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_POLL_OTHER_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_POST_SEND_CONTROL_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTER_AND_GET_KEYS_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_COMPRESS_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_FINISHED_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS_LOOP_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_LOOP_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_RKEY_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_LOOP_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_SUCCESS_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_HANDLE_WAIT_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_START_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_STOP_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_REGISTRATION_STOP_RAM_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_RESOLVE_HOST_TRYING_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_APPEND_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_ALREADY_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_UNREGISTER_WAITING_INFLIGHT_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_UNREGISTER_WAITING_PROC_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_UNREGISTER_WAITING_SEND_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_UNREGISTER_WAITING_COMPLETE_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_WRITE_FLUSH_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_WRITE_ONE_BLOCK_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_WRITE_ONE_POST_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_WRITE_ONE_QUEUE_FULL_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_WRITE_ONE_RECVREGRES_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_WRITE_ONE_SENDREG_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_WRITE_ONE_TOP_DSTATE;
extern uint16_t _TRACE_QEMU_RDMA_WRITE_ONE_ZERO_DSTATE;
extern uint16_t _TRACE_RDMA_ADD_BLOCK_DSTATE;
extern uint16_t _TRACE_RDMA_BLOCK_NOTIFICATION_HANDLE_DSTATE;
extern uint16_t _TRACE_RDMA_DELETE_BLOCK_DSTATE;
extern uint16_t _TRACE_RDMA_START_INCOMING_MIGRATION_DSTATE;
extern uint16_t _TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_DEST_INIT_DSTATE;
extern uint16_t _TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_RDMA_LISTEN_DSTATE;
extern uint16_t _TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_CONNECT_DSTATE;
extern uint16_t _TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_SOURCE_INIT_DSTATE;
extern uint16_t _TRACE_POSTCOPY_DISCARD_SEND_FINISH_DSTATE;
extern uint16_t _TRACE_POSTCOPY_DISCARD_SEND_RANGE_DSTATE;
extern uint16_t _TRACE_POSTCOPY_CLEANUP_RANGE_DSTATE;
extern uint16_t _TRACE_POSTCOPY_INIT_RANGE_DSTATE;
extern uint16_t _TRACE_POSTCOPY_NHP_RANGE_DSTATE;
extern uint16_t _TRACE_POSTCOPY_PLACE_PAGE_DSTATE;
extern uint16_t _TRACE_POSTCOPY_PLACE_PAGE_ZERO_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_ENABLE_NOTIFY_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_FAULT_THREAD_ENTRY_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_FAULT_THREAD_EXIT_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_FAULT_THREAD_QUIT_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_FAULT_THREAD_REQUEST_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_CLOSEUF_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_ENTRY_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_EXIT_DSTATE;
extern uint16_t _TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_JOIN_DSTATE;
extern uint16_t _TRACE_SAVE_XBZRLE_PAGE_SKIPPING_DSTATE;
extern uint16_t _TRACE_SAVE_XBZRLE_PAGE_OVERFLOW_DSTATE;
extern uint16_t _TRACE_RAM_SAVE_ITERATE_BIG_WAIT_DSTATE;
extern uint16_t _TRACE_RAM_LOAD_COMPLETE_DSTATE;
extern uint16_t _TRACE_MIGRATION_EXEC_OUTGOING_DSTATE;
extern uint16_t _TRACE_MIGRATION_EXEC_INCOMING_DSTATE;
extern uint16_t _TRACE_MIGRATION_FD_OUTGOING_DSTATE;
extern uint16_t _TRACE_MIGRATION_FD_INCOMING_DSTATE;
extern uint16_t _TRACE_MIGRATION_SOCKET_INCOMING_ACCEPTED_DSTATE;
extern uint16_t _TRACE_MIGRATION_SOCKET_OUTGOING_CONNECTED_DSTATE;
extern uint16_t _TRACE_MIGRATION_SOCKET_OUTGOING_ERROR_DSTATE;
extern uint16_t _TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_START_DSTATE;
extern uint16_t _TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_ERROR_DSTATE;
extern uint16_t _TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_COMPLETE_DSTATE;
extern uint16_t _TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_START_DSTATE;
extern uint16_t _TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_ERROR_DSTATE;
extern uint16_t _TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_COMPLETE_DSTATE;
extern uint16_t _TRACE_COLO_VM_STATE_CHANGE_DSTATE;
extern uint16_t _TRACE_COLO_SEND_MESSAGE_DSTATE;
extern uint16_t _TRACE_COLO_RECEIVE_MESSAGE_DSTATE;
extern uint16_t _TRACE_COLO_FAILOVER_SET_STATE_DSTATE;
#define TRACE_QEMU_LOADVM_STATE_SECTION_ENABLED 1
#define TRACE_QEMU_LOADVM_STATE_SECTION_COMMAND_ENABLED 1
#define TRACE_QEMU_LOADVM_STATE_SECTION_PARTEND_ENABLED 1
#define TRACE_QEMU_LOADVM_STATE_POST_MAIN_ENABLED 1
#define TRACE_QEMU_LOADVM_STATE_SECTION_STARTFULL_ENABLED 1
#define TRACE_QEMU_SAVEVM_SEND_PACKAGED_ENABLED 1
#define TRACE_LOADVM_STATE_SETUP_ENABLED 1
#define TRACE_LOADVM_STATE_CLEANUP_ENABLED 1
#define TRACE_LOADVM_HANDLE_CMD_PACKAGED_ENABLED 1
#define TRACE_LOADVM_HANDLE_CMD_PACKAGED_MAIN_ENABLED 1
#define TRACE_LOADVM_HANDLE_CMD_PACKAGED_RECEIVED_ENABLED 1
#define TRACE_LOADVM_POSTCOPY_HANDLE_ADVISE_ENABLED 1
#define TRACE_LOADVM_POSTCOPY_HANDLE_LISTEN_ENABLED 1
#define TRACE_LOADVM_POSTCOPY_HANDLE_RUN_ENABLED 1
#define TRACE_LOADVM_POSTCOPY_HANDLE_RUN_CPU_SYNC_ENABLED 1
#define TRACE_LOADVM_POSTCOPY_HANDLE_RUN_VMSTART_ENABLED 1
#define TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_ENABLED 1
#define TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_END_ENABLED 1
#define TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_HEADER_ENABLED 1
#define TRACE_LOADVM_PROCESS_COMMAND_ENABLED 1
#define TRACE_LOADVM_PROCESS_COMMAND_PING_ENABLED 1
#define TRACE_POSTCOPY_RAM_LISTEN_THREAD_EXIT_ENABLED 1
#define TRACE_POSTCOPY_RAM_LISTEN_THREAD_START_ENABLED 1
#define TRACE_QEMU_SAVEVM_SEND_POSTCOPY_ADVISE_ENABLED 1
#define TRACE_QEMU_SAVEVM_SEND_POSTCOPY_RAM_DISCARD_ENABLED 1
#define TRACE_SAVEVM_COMMAND_SEND_ENABLED 1
#define TRACE_SAVEVM_SECTION_START_ENABLED 1
#define TRACE_SAVEVM_SECTION_END_ENABLED 1
#define TRACE_SAVEVM_SECTION_SKIP_ENABLED 1
#define TRACE_SAVEVM_SEND_OPEN_RETURN_PATH_ENABLED 1
#define TRACE_SAVEVM_SEND_PING_ENABLED 1
#define TRACE_SAVEVM_SEND_POSTCOPY_LISTEN_ENABLED 1
#define TRACE_SAVEVM_SEND_POSTCOPY_RUN_ENABLED 1
#define TRACE_SAVEVM_STATE_SETUP_ENABLED 1
#define TRACE_SAVEVM_STATE_HEADER_ENABLED 1
#define TRACE_SAVEVM_STATE_ITERATE_ENABLED 1
#define TRACE_SAVEVM_STATE_CLEANUP_ENABLED 1
#define TRACE_SAVEVM_STATE_COMPLETE_PRECOPY_ENABLED 1
#define TRACE_VMSTATE_SAVE_ENABLED 1
#define TRACE_VMSTATE_SAVE_STATE_PRE_SAVE_RES_ENABLED 1
#define TRACE_VMSTATE_SAVE_STATE_LOOP_ENABLED 1
#define TRACE_VMSTATE_SAVE_STATE_TOP_ENABLED 1
#define TRACE_VMSTATE_SUBSECTION_SAVE_LOOP_ENABLED 1
#define TRACE_VMSTATE_SUBSECTION_SAVE_TOP_ENABLED 1
#define TRACE_VMSTATE_LOAD_ENABLED 1
#define TRACE_QEMU_ANNOUNCE_SELF_ITER_ENABLED 1
#define TRACE_VMSTATE_LOAD_FIELD_ERROR_ENABLED 1
#define TRACE_VMSTATE_LOAD_STATE_ENABLED 1
#define TRACE_VMSTATE_LOAD_STATE_END_ENABLED 1
#define TRACE_VMSTATE_LOAD_STATE_FIELD_ENABLED 1
#define TRACE_VMSTATE_N_ELEMS_ENABLED 1
#define TRACE_VMSTATE_SUBSECTION_LOAD_ENABLED 1
#define TRACE_VMSTATE_SUBSECTION_LOAD_BAD_ENABLED 1
#define TRACE_VMSTATE_SUBSECTION_LOAD_GOOD_ENABLED 1
#define TRACE_GET_QTAILQ_ENABLED 1
#define TRACE_GET_QTAILQ_END_ENABLED 1
#define TRACE_PUT_QTAILQ_ENABLED 1
#define TRACE_PUT_QTAILQ_END_ENABLED 1
#define TRACE_QEMU_FILE_FCLOSE_ENABLED 1
#define TRACE_GET_QUEUED_PAGE_ENABLED 1
#define TRACE_GET_QUEUED_PAGE_NOT_DIRTY_ENABLED 1
#define TRACE_MIGRATION_BITMAP_SYNC_START_ENABLED 1
#define TRACE_MIGRATION_BITMAP_SYNC_END_ENABLED 1
#define TRACE_MIGRATION_THROTTLE_ENABLED 1
#define TRACE_RAM_DISCARD_RANGE_ENABLED 1
#define TRACE_RAM_LOAD_LOOP_ENABLED 1
#define TRACE_RAM_LOAD_POSTCOPY_LOOP_ENABLED 1
#define TRACE_RAM_POSTCOPY_SEND_DISCARD_BITMAP_ENABLED 1
#define TRACE_RAM_SAVE_PAGE_ENABLED 1
#define TRACE_RAM_SAVE_QUEUE_PAGES_ENABLED 1
#define TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_CLOSE_ENABLED 1
#define TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_JOINING_ENABLED 1
#define TRACE_MIGRATE_SET_STATE_ENABLED 1
#define TRACE_MIGRATE_FD_CLEANUP_ENABLED 1
#define TRACE_MIGRATE_FD_ERROR_ENABLED 1
#define TRACE_MIGRATE_FD_CANCEL_ENABLED 1
#define TRACE_MIGRATE_HANDLE_RP_REQ_PAGES_ENABLED 1
#define TRACE_MIGRATE_PENDING_ENABLED 1
#define TRACE_MIGRATE_SEND_RP_MESSAGE_ENABLED 1
#define TRACE_MIGRATION_COMPLETION_FILE_ERR_ENABLED 1
#define TRACE_MIGRATION_COMPLETION_POSTCOPY_END_ENABLED 1
#define TRACE_MIGRATION_COMPLETION_POSTCOPY_END_AFTER_COMPLETE_ENABLED 1
#define TRACE_MIGRATION_RETURN_PATH_END_BEFORE_ENABLED 1
#define TRACE_MIGRATION_RETURN_PATH_END_AFTER_ENABLED 1
#define TRACE_MIGRATION_THREAD_AFTER_LOOP_ENABLED 1
#define TRACE_MIGRATION_THREAD_FILE_ERR_ENABLED 1
#define TRACE_MIGRATION_THREAD_SETUP_COMPLETE_ENABLED 1
#define TRACE_OPEN_RETURN_PATH_ON_SOURCE_ENABLED 1
#define TRACE_OPEN_RETURN_PATH_ON_SOURCE_CONTINUE_ENABLED 1
#define TRACE_POSTCOPY_START_ENABLED 1
#define TRACE_POSTCOPY_START_SET_RUN_ENABLED 1
#define TRACE_SOURCE_RETURN_PATH_THREAD_BAD_END_ENABLED 1
#define TRACE_SOURCE_RETURN_PATH_THREAD_END_ENABLED 1
#define TRACE_SOURCE_RETURN_PATH_THREAD_ENTRY_ENABLED 1
#define TRACE_SOURCE_RETURN_PATH_THREAD_LOOP_TOP_ENABLED 1
#define TRACE_SOURCE_RETURN_PATH_THREAD_PONG_ENABLED 1
#define TRACE_SOURCE_RETURN_PATH_THREAD_SHUT_ENABLED 1
#define TRACE_MIGRATE_GLOBAL_STATE_POST_LOAD_ENABLED 1
#define TRACE_MIGRATE_GLOBAL_STATE_PRE_SAVE_ENABLED 1
#define TRACE_MIGRATION_THREAD_LOW_PENDING_ENABLED 1
#define TRACE_MIGRATE_STATE_TOO_BIG_ENABLED 1
#define TRACE_MIGRATE_TRANSFERRED_ENABLED 1
#define TRACE_PROCESS_INCOMING_MIGRATION_CO_END_ENABLED 1
#define TRACE_PROCESS_INCOMING_MIGRATION_CO_POSTCOPY_END_MAIN_ENABLED 1
#define TRACE_MIGRATION_SET_INCOMING_CHANNEL_ENABLED 1
#define TRACE_MIGRATION_SET_OUTGOING_CHANNEL_ENABLED 1
#define TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION_ENABLED 1
#define TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION_ACCEPTED_ENABLED 1
#define TRACE_QEMU_RDMA_ACCEPT_PIN_STATE_ENABLED 1
#define TRACE_QEMU_RDMA_ACCEPT_PIN_VERBSC_ENABLED 1
#define TRACE_QEMU_RDMA_BLOCK_FOR_WRID_MISS_ENABLED 1
#define TRACE_QEMU_RDMA_CLEANUP_DISCONNECT_ENABLED 1
#define TRACE_QEMU_RDMA_CLEANUP_WAITING_FOR_DISCONNECT_ENABLED 1
#define TRACE_QEMU_RDMA_CLOSE_ENABLED 1
#define TRACE_QEMU_RDMA_CONNECT_PIN_ALL_REQUESTED_ENABLED 1
#define TRACE_QEMU_RDMA_CONNECT_PIN_ALL_OUTCOME_ENABLED 1
#define TRACE_QEMU_RDMA_DEST_INIT_TRYING_ENABLED 1
#define TRACE_QEMU_RDMA_DUMP_GID_ENABLED 1
#define TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_START_ENABLED 1
#define TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_NONE_ENABLED 1
#define TRACE_QEMU_RDMA_EXCHANGE_SEND_ISSUE_CALLBACK_ENABLED 1
#define TRACE_QEMU_RDMA_EXCHANGE_SEND_WAITING_ENABLED 1
#define TRACE_QEMU_RDMA_EXCHANGE_SEND_RECEIVED_ENABLED 1
#define TRACE_QEMU_RDMA_FILL_ENABLED 1
#define TRACE_QEMU_RDMA_INIT_RAM_BLOCKS_ENABLED 1
#define TRACE_QEMU_RDMA_POLL_RECV_ENABLED 1
#define TRACE_QEMU_RDMA_POLL_WRITE_ENABLED 1
#define TRACE_QEMU_RDMA_POLL_OTHER_ENABLED 1
#define TRACE_QEMU_RDMA_POST_SEND_CONTROL_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTER_AND_GET_KEYS_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_COMPRESS_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_FINISHED_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS_LOOP_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_LOOP_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_RKEY_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_LOOP_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_SUCCESS_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_WAIT_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_START_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_STOP_ENABLED 1
#define TRACE_QEMU_RDMA_REGISTRATION_STOP_RAM_ENABLED 1
#define TRACE_QEMU_RDMA_RESOLVE_HOST_TRYING_ENABLED 1
#define TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_APPEND_ENABLED 1
#define TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_ALREADY_ENABLED 1
#define TRACE_QEMU_RDMA_UNREGISTER_WAITING_INFLIGHT_ENABLED 1
#define TRACE_QEMU_RDMA_UNREGISTER_WAITING_PROC_ENABLED 1
#define TRACE_QEMU_RDMA_UNREGISTER_WAITING_SEND_ENABLED 1
#define TRACE_QEMU_RDMA_UNREGISTER_WAITING_COMPLETE_ENABLED 1
#define TRACE_QEMU_RDMA_WRITE_FLUSH_ENABLED 1
#define TRACE_QEMU_RDMA_WRITE_ONE_BLOCK_ENABLED 1
#define TRACE_QEMU_RDMA_WRITE_ONE_POST_ENABLED 1
#define TRACE_QEMU_RDMA_WRITE_ONE_QUEUE_FULL_ENABLED 1
#define TRACE_QEMU_RDMA_WRITE_ONE_RECVREGRES_ENABLED 1
#define TRACE_QEMU_RDMA_WRITE_ONE_SENDREG_ENABLED 1
#define TRACE_QEMU_RDMA_WRITE_ONE_TOP_ENABLED 1
#define TRACE_QEMU_RDMA_WRITE_ONE_ZERO_ENABLED 1
#define TRACE_RDMA_ADD_BLOCK_ENABLED 1
#define TRACE_RDMA_BLOCK_NOTIFICATION_HANDLE_ENABLED 1
#define TRACE_RDMA_DELETE_BLOCK_ENABLED 1
#define TRACE_RDMA_START_INCOMING_MIGRATION_ENABLED 1
#define TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_DEST_INIT_ENABLED 1
#define TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_RDMA_LISTEN_ENABLED 1
#define TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_CONNECT_ENABLED 1
#define TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_SOURCE_INIT_ENABLED 1
#define TRACE_POSTCOPY_DISCARD_SEND_FINISH_ENABLED 1
#define TRACE_POSTCOPY_DISCARD_SEND_RANGE_ENABLED 1
#define TRACE_POSTCOPY_CLEANUP_RANGE_ENABLED 1
#define TRACE_POSTCOPY_INIT_RANGE_ENABLED 1
#define TRACE_POSTCOPY_NHP_RANGE_ENABLED 1
#define TRACE_POSTCOPY_PLACE_PAGE_ENABLED 1
#define TRACE_POSTCOPY_PLACE_PAGE_ZERO_ENABLED 1
#define TRACE_POSTCOPY_RAM_ENABLE_NOTIFY_ENABLED 1
#define TRACE_POSTCOPY_RAM_FAULT_THREAD_ENTRY_ENABLED 1
#define TRACE_POSTCOPY_RAM_FAULT_THREAD_EXIT_ENABLED 1
#define TRACE_POSTCOPY_RAM_FAULT_THREAD_QUIT_ENABLED 1
#define TRACE_POSTCOPY_RAM_FAULT_THREAD_REQUEST_ENABLED 1
#define TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_CLOSEUF_ENABLED 1
#define TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_ENTRY_ENABLED 1
#define TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_EXIT_ENABLED 1
#define TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_JOIN_ENABLED 1
#define TRACE_SAVE_XBZRLE_PAGE_SKIPPING_ENABLED 1
#define TRACE_SAVE_XBZRLE_PAGE_OVERFLOW_ENABLED 1
#define TRACE_RAM_SAVE_ITERATE_BIG_WAIT_ENABLED 1
#define TRACE_RAM_LOAD_COMPLETE_ENABLED 1
#define TRACE_MIGRATION_EXEC_OUTGOING_ENABLED 1
#define TRACE_MIGRATION_EXEC_INCOMING_ENABLED 1
#define TRACE_MIGRATION_FD_OUTGOING_ENABLED 1
#define TRACE_MIGRATION_FD_INCOMING_ENABLED 1
#define TRACE_MIGRATION_SOCKET_INCOMING_ACCEPTED_ENABLED 1
#define TRACE_MIGRATION_SOCKET_OUTGOING_CONNECTED_ENABLED 1
#define TRACE_MIGRATION_SOCKET_OUTGOING_ERROR_ENABLED 1
#define TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_START_ENABLED 1
#define TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_ERROR_ENABLED 1
#define TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_COMPLETE_ENABLED 1
#define TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_START_ENABLED 1
#define TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_ERROR_ENABLED 1
#define TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_COMPLETE_ENABLED 1
#define TRACE_COLO_VM_STATE_CHANGE_ENABLED 1
#define TRACE_COLO_SEND_MESSAGE_ENABLED 1
#define TRACE_COLO_RECEIVE_MESSAGE_ENABLED 1
#define TRACE_COLO_FAILOVER_SET_STATE_ENABLED 1
#include "qemu/log.h"


#define TRACE_QEMU_LOADVM_STATE_SECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_LOADVM_STATE_SECTION) || \
    false)

static inline void _nocheck__trace_qemu_loadvm_state_section(unsigned int section_type)
{
    if (trace_event_get_state(TRACE_QEMU_LOADVM_STATE_SECTION)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_loadvm_state_section " "%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , section_type);
    }
}

static inline void trace_qemu_loadvm_state_section(unsigned int section_type)
{
    if (true) {
        _nocheck__trace_qemu_loadvm_state_section(section_type);
    }
}

#define TRACE_QEMU_LOADVM_STATE_SECTION_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_LOADVM_STATE_SECTION_COMMAND) || \
    false)

static inline void _nocheck__trace_qemu_loadvm_state_section_command(int ret)
{
    if (trace_event_get_state(TRACE_QEMU_LOADVM_STATE_SECTION_COMMAND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_loadvm_state_section_command " "%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ret);
    }
}

static inline void trace_qemu_loadvm_state_section_command(int ret)
{
    if (true) {
        _nocheck__trace_qemu_loadvm_state_section_command(ret);
    }
}

#define TRACE_QEMU_LOADVM_STATE_SECTION_PARTEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_LOADVM_STATE_SECTION_PARTEND) || \
    false)

static inline void _nocheck__trace_qemu_loadvm_state_section_partend(uint32_t section_id)
{
    if (trace_event_get_state(TRACE_QEMU_LOADVM_STATE_SECTION_PARTEND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_loadvm_state_section_partend " "%u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , section_id);
    }
}

static inline void trace_qemu_loadvm_state_section_partend(uint32_t section_id)
{
    if (true) {
        _nocheck__trace_qemu_loadvm_state_section_partend(section_id);
    }
}

#define TRACE_QEMU_LOADVM_STATE_POST_MAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_LOADVM_STATE_POST_MAIN) || \
    false)

static inline void _nocheck__trace_qemu_loadvm_state_post_main(int ret)
{
    if (trace_event_get_state(TRACE_QEMU_LOADVM_STATE_POST_MAIN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_loadvm_state_post_main " "%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ret);
    }
}

static inline void trace_qemu_loadvm_state_post_main(int ret)
{
    if (true) {
        _nocheck__trace_qemu_loadvm_state_post_main(ret);
    }
}

#define TRACE_QEMU_LOADVM_STATE_SECTION_STARTFULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_LOADVM_STATE_SECTION_STARTFULL) || \
    false)

static inline void _nocheck__trace_qemu_loadvm_state_section_startfull(uint32_t section_id, const char * idstr, uint32_t instance_id, uint32_t version_id)
{
    if (trace_event_get_state(TRACE_QEMU_LOADVM_STATE_SECTION_STARTFULL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_loadvm_state_section_startfull " "%u(%s) %u %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , section_id, idstr, instance_id, version_id);
    }
}

static inline void trace_qemu_loadvm_state_section_startfull(uint32_t section_id, const char * idstr, uint32_t instance_id, uint32_t version_id)
{
    if (true) {
        _nocheck__trace_qemu_loadvm_state_section_startfull(section_id, idstr, instance_id, version_id);
    }
}

#define TRACE_QEMU_SAVEVM_SEND_PACKAGED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SAVEVM_SEND_PACKAGED) || \
    false)

static inline void _nocheck__trace_qemu_savevm_send_packaged(void)
{
    if (trace_event_get_state(TRACE_QEMU_SAVEVM_SEND_PACKAGED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_savevm_send_packaged " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_savevm_send_packaged(void)
{
    if (true) {
        _nocheck__trace_qemu_savevm_send_packaged();
    }
}

#define TRACE_LOADVM_STATE_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_STATE_SETUP) || \
    false)

static inline void _nocheck__trace_loadvm_state_setup(void)
{
    if (trace_event_get_state(TRACE_LOADVM_STATE_SETUP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_state_setup " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_loadvm_state_setup(void)
{
    if (true) {
        _nocheck__trace_loadvm_state_setup();
    }
}

#define TRACE_LOADVM_STATE_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_STATE_CLEANUP) || \
    false)

static inline void _nocheck__trace_loadvm_state_cleanup(void)
{
    if (trace_event_get_state(TRACE_LOADVM_STATE_CLEANUP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_state_cleanup " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_loadvm_state_cleanup(void)
{
    if (true) {
        _nocheck__trace_loadvm_state_cleanup();
    }
}

#define TRACE_LOADVM_HANDLE_CMD_PACKAGED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_HANDLE_CMD_PACKAGED) || \
    false)

static inline void _nocheck__trace_loadvm_handle_cmd_packaged(unsigned int length)
{
    if (trace_event_get_state(TRACE_LOADVM_HANDLE_CMD_PACKAGED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_handle_cmd_packaged " "%u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , length);
    }
}

static inline void trace_loadvm_handle_cmd_packaged(unsigned int length)
{
    if (true) {
        _nocheck__trace_loadvm_handle_cmd_packaged(length);
    }
}

#define TRACE_LOADVM_HANDLE_CMD_PACKAGED_MAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_HANDLE_CMD_PACKAGED_MAIN) || \
    false)

static inline void _nocheck__trace_loadvm_handle_cmd_packaged_main(int ret)
{
    if (trace_event_get_state(TRACE_LOADVM_HANDLE_CMD_PACKAGED_MAIN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_handle_cmd_packaged_main " "%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ret);
    }
}

static inline void trace_loadvm_handle_cmd_packaged_main(int ret)
{
    if (true) {
        _nocheck__trace_loadvm_handle_cmd_packaged_main(ret);
    }
}

#define TRACE_LOADVM_HANDLE_CMD_PACKAGED_RECEIVED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_HANDLE_CMD_PACKAGED_RECEIVED) || \
    false)

static inline void _nocheck__trace_loadvm_handle_cmd_packaged_received(int ret)
{
    if (trace_event_get_state(TRACE_LOADVM_HANDLE_CMD_PACKAGED_RECEIVED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_handle_cmd_packaged_received " "%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ret);
    }
}

static inline void trace_loadvm_handle_cmd_packaged_received(int ret)
{
    if (true) {
        _nocheck__trace_loadvm_handle_cmd_packaged_received(ret);
    }
}

#define TRACE_LOADVM_POSTCOPY_HANDLE_ADVISE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_POSTCOPY_HANDLE_ADVISE) || \
    false)

static inline void _nocheck__trace_loadvm_postcopy_handle_advise(void)
{
    if (trace_event_get_state(TRACE_LOADVM_POSTCOPY_HANDLE_ADVISE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_postcopy_handle_advise " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_loadvm_postcopy_handle_advise(void)
{
    if (true) {
        _nocheck__trace_loadvm_postcopy_handle_advise();
    }
}

#define TRACE_LOADVM_POSTCOPY_HANDLE_LISTEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_POSTCOPY_HANDLE_LISTEN) || \
    false)

static inline void _nocheck__trace_loadvm_postcopy_handle_listen(void)
{
    if (trace_event_get_state(TRACE_LOADVM_POSTCOPY_HANDLE_LISTEN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_postcopy_handle_listen " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_loadvm_postcopy_handle_listen(void)
{
    if (true) {
        _nocheck__trace_loadvm_postcopy_handle_listen();
    }
}

#define TRACE_LOADVM_POSTCOPY_HANDLE_RUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_POSTCOPY_HANDLE_RUN) || \
    false)

static inline void _nocheck__trace_loadvm_postcopy_handle_run(void)
{
    if (trace_event_get_state(TRACE_LOADVM_POSTCOPY_HANDLE_RUN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_postcopy_handle_run " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_loadvm_postcopy_handle_run(void)
{
    if (true) {
        _nocheck__trace_loadvm_postcopy_handle_run();
    }
}

#define TRACE_LOADVM_POSTCOPY_HANDLE_RUN_CPU_SYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_POSTCOPY_HANDLE_RUN_CPU_SYNC) || \
    false)

static inline void _nocheck__trace_loadvm_postcopy_handle_run_cpu_sync(void)
{
    if (trace_event_get_state(TRACE_LOADVM_POSTCOPY_HANDLE_RUN_CPU_SYNC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_postcopy_handle_run_cpu_sync " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_loadvm_postcopy_handle_run_cpu_sync(void)
{
    if (true) {
        _nocheck__trace_loadvm_postcopy_handle_run_cpu_sync();
    }
}

#define TRACE_LOADVM_POSTCOPY_HANDLE_RUN_VMSTART_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_POSTCOPY_HANDLE_RUN_VMSTART) || \
    false)

static inline void _nocheck__trace_loadvm_postcopy_handle_run_vmstart(void)
{
    if (trace_event_get_state(TRACE_LOADVM_POSTCOPY_HANDLE_RUN_VMSTART)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_postcopy_handle_run_vmstart " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_loadvm_postcopy_handle_run_vmstart(void)
{
    if (true) {
        _nocheck__trace_loadvm_postcopy_handle_run_vmstart();
    }
}

#define TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD) || \
    false)

static inline void _nocheck__trace_loadvm_postcopy_ram_handle_discard(void)
{
    if (trace_event_get_state(TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_postcopy_ram_handle_discard " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_loadvm_postcopy_ram_handle_discard(void)
{
    if (true) {
        _nocheck__trace_loadvm_postcopy_ram_handle_discard();
    }
}

#define TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_END) || \
    false)

static inline void _nocheck__trace_loadvm_postcopy_ram_handle_discard_end(void)
{
    if (trace_event_get_state(TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_END)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_postcopy_ram_handle_discard_end " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_loadvm_postcopy_ram_handle_discard_end(void)
{
    if (true) {
        _nocheck__trace_loadvm_postcopy_ram_handle_discard_end();
    }
}

#define TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_HEADER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_HEADER) || \
    false)

static inline void _nocheck__trace_loadvm_postcopy_ram_handle_discard_header(const char * ramid, uint16_t len)
{
    if (trace_event_get_state(TRACE_LOADVM_POSTCOPY_RAM_HANDLE_DISCARD_HEADER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_postcopy_ram_handle_discard_header " "%s: %ud" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ramid, len);
    }
}

static inline void trace_loadvm_postcopy_ram_handle_discard_header(const char * ramid, uint16_t len)
{
    if (true) {
        _nocheck__trace_loadvm_postcopy_ram_handle_discard_header(ramid, len);
    }
}

#define TRACE_LOADVM_PROCESS_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_PROCESS_COMMAND) || \
    false)

static inline void _nocheck__trace_loadvm_process_command(uint16_t com, uint16_t len)
{
    if (trace_event_get_state(TRACE_LOADVM_PROCESS_COMMAND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_process_command " "com=0x%x len=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , com, len);
    }
}

static inline void trace_loadvm_process_command(uint16_t com, uint16_t len)
{
    if (true) {
        _nocheck__trace_loadvm_process_command(com, len);
    }
}

#define TRACE_LOADVM_PROCESS_COMMAND_PING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOADVM_PROCESS_COMMAND_PING) || \
    false)

static inline void _nocheck__trace_loadvm_process_command_ping(uint32_t val)
{
    if (trace_event_get_state(TRACE_LOADVM_PROCESS_COMMAND_PING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:loadvm_process_command_ping " "0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , val);
    }
}

static inline void trace_loadvm_process_command_ping(uint32_t val)
{
    if (true) {
        _nocheck__trace_loadvm_process_command_ping(val);
    }
}

#define TRACE_POSTCOPY_RAM_LISTEN_THREAD_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_LISTEN_THREAD_EXIT) || \
    false)

static inline void _nocheck__trace_postcopy_ram_listen_thread_exit(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_LISTEN_THREAD_EXIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_listen_thread_exit " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_ram_listen_thread_exit(void)
{
    if (true) {
        _nocheck__trace_postcopy_ram_listen_thread_exit();
    }
}

#define TRACE_POSTCOPY_RAM_LISTEN_THREAD_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_LISTEN_THREAD_START) || \
    false)

static inline void _nocheck__trace_postcopy_ram_listen_thread_start(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_LISTEN_THREAD_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_listen_thread_start " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_ram_listen_thread_start(void)
{
    if (true) {
        _nocheck__trace_postcopy_ram_listen_thread_start();
    }
}

#define TRACE_QEMU_SAVEVM_SEND_POSTCOPY_ADVISE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SAVEVM_SEND_POSTCOPY_ADVISE) || \
    false)

static inline void _nocheck__trace_qemu_savevm_send_postcopy_advise(void)
{
    if (trace_event_get_state(TRACE_QEMU_SAVEVM_SEND_POSTCOPY_ADVISE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_savevm_send_postcopy_advise " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_savevm_send_postcopy_advise(void)
{
    if (true) {
        _nocheck__trace_qemu_savevm_send_postcopy_advise();
    }
}

#define TRACE_QEMU_SAVEVM_SEND_POSTCOPY_RAM_DISCARD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SAVEVM_SEND_POSTCOPY_RAM_DISCARD) || \
    false)

static inline void _nocheck__trace_qemu_savevm_send_postcopy_ram_discard(const char * id, uint16_t len)
{
    if (trace_event_get_state(TRACE_QEMU_SAVEVM_SEND_POSTCOPY_RAM_DISCARD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_savevm_send_postcopy_ram_discard " "%s: %ud" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , id, len);
    }
}

static inline void trace_qemu_savevm_send_postcopy_ram_discard(const char * id, uint16_t len)
{
    if (true) {
        _nocheck__trace_qemu_savevm_send_postcopy_ram_discard(id, len);
    }
}

#define TRACE_SAVEVM_COMMAND_SEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_COMMAND_SEND) || \
    false)

static inline void _nocheck__trace_savevm_command_send(uint16_t command, uint16_t len)
{
    if (trace_event_get_state(TRACE_SAVEVM_COMMAND_SEND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_command_send " "com=0x%x len=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , command, len);
    }
}

static inline void trace_savevm_command_send(uint16_t command, uint16_t len)
{
    if (true) {
        _nocheck__trace_savevm_command_send(command, len);
    }
}

#define TRACE_SAVEVM_SECTION_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_SECTION_START) || \
    false)

static inline void _nocheck__trace_savevm_section_start(const char * id, unsigned int section_id)
{
    if (trace_event_get_state(TRACE_SAVEVM_SECTION_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_section_start " "%s, section_id %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , id, section_id);
    }
}

static inline void trace_savevm_section_start(const char * id, unsigned int section_id)
{
    if (true) {
        _nocheck__trace_savevm_section_start(id, section_id);
    }
}

#define TRACE_SAVEVM_SECTION_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_SECTION_END) || \
    false)

static inline void _nocheck__trace_savevm_section_end(const char * id, unsigned int section_id, int ret)
{
    if (trace_event_get_state(TRACE_SAVEVM_SECTION_END)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_section_end " "%s, section_id %u -> %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , id, section_id, ret);
    }
}

static inline void trace_savevm_section_end(const char * id, unsigned int section_id, int ret)
{
    if (true) {
        _nocheck__trace_savevm_section_end(id, section_id, ret);
    }
}

#define TRACE_SAVEVM_SECTION_SKIP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_SECTION_SKIP) || \
    false)

static inline void _nocheck__trace_savevm_section_skip(const char * id, unsigned int section_id)
{
    if (trace_event_get_state(TRACE_SAVEVM_SECTION_SKIP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_section_skip " "%s, section_id %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , id, section_id);
    }
}

static inline void trace_savevm_section_skip(const char * id, unsigned int section_id)
{
    if (true) {
        _nocheck__trace_savevm_section_skip(id, section_id);
    }
}

#define TRACE_SAVEVM_SEND_OPEN_RETURN_PATH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_SEND_OPEN_RETURN_PATH) || \
    false)

static inline void _nocheck__trace_savevm_send_open_return_path(void)
{
    if (trace_event_get_state(TRACE_SAVEVM_SEND_OPEN_RETURN_PATH)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_send_open_return_path " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_savevm_send_open_return_path(void)
{
    if (true) {
        _nocheck__trace_savevm_send_open_return_path();
    }
}

#define TRACE_SAVEVM_SEND_PING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_SEND_PING) || \
    false)

static inline void _nocheck__trace_savevm_send_ping(uint32_t val)
{
    if (trace_event_get_state(TRACE_SAVEVM_SEND_PING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_send_ping " "0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , val);
    }
}

static inline void trace_savevm_send_ping(uint32_t val)
{
    if (true) {
        _nocheck__trace_savevm_send_ping(val);
    }
}

#define TRACE_SAVEVM_SEND_POSTCOPY_LISTEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_SEND_POSTCOPY_LISTEN) || \
    false)

static inline void _nocheck__trace_savevm_send_postcopy_listen(void)
{
    if (trace_event_get_state(TRACE_SAVEVM_SEND_POSTCOPY_LISTEN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_send_postcopy_listen " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_savevm_send_postcopy_listen(void)
{
    if (true) {
        _nocheck__trace_savevm_send_postcopy_listen();
    }
}

#define TRACE_SAVEVM_SEND_POSTCOPY_RUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_SEND_POSTCOPY_RUN) || \
    false)

static inline void _nocheck__trace_savevm_send_postcopy_run(void)
{
    if (trace_event_get_state(TRACE_SAVEVM_SEND_POSTCOPY_RUN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_send_postcopy_run " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_savevm_send_postcopy_run(void)
{
    if (true) {
        _nocheck__trace_savevm_send_postcopy_run();
    }
}

#define TRACE_SAVEVM_STATE_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_STATE_SETUP) || \
    false)

static inline void _nocheck__trace_savevm_state_setup(void)
{
    if (trace_event_get_state(TRACE_SAVEVM_STATE_SETUP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_state_setup " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_savevm_state_setup(void)
{
    if (true) {
        _nocheck__trace_savevm_state_setup();
    }
}

#define TRACE_SAVEVM_STATE_HEADER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_STATE_HEADER) || \
    false)

static inline void _nocheck__trace_savevm_state_header(void)
{
    if (trace_event_get_state(TRACE_SAVEVM_STATE_HEADER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_state_header " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_savevm_state_header(void)
{
    if (true) {
        _nocheck__trace_savevm_state_header();
    }
}

#define TRACE_SAVEVM_STATE_ITERATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_STATE_ITERATE) || \
    false)

static inline void _nocheck__trace_savevm_state_iterate(void)
{
    if (trace_event_get_state(TRACE_SAVEVM_STATE_ITERATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_state_iterate " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_savevm_state_iterate(void)
{
    if (true) {
        _nocheck__trace_savevm_state_iterate();
    }
}

#define TRACE_SAVEVM_STATE_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_STATE_CLEANUP) || \
    false)

static inline void _nocheck__trace_savevm_state_cleanup(void)
{
    if (trace_event_get_state(TRACE_SAVEVM_STATE_CLEANUP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_state_cleanup " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_savevm_state_cleanup(void)
{
    if (true) {
        _nocheck__trace_savevm_state_cleanup();
    }
}

#define TRACE_SAVEVM_STATE_COMPLETE_PRECOPY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVEVM_STATE_COMPLETE_PRECOPY) || \
    false)

static inline void _nocheck__trace_savevm_state_complete_precopy(void)
{
    if (trace_event_get_state(TRACE_SAVEVM_STATE_COMPLETE_PRECOPY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:savevm_state_complete_precopy " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_savevm_state_complete_precopy(void)
{
    if (true) {
        _nocheck__trace_savevm_state_complete_precopy();
    }
}

#define TRACE_VMSTATE_SAVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_SAVE) || \
    false)

static inline void _nocheck__trace_vmstate_save(const char * idstr, const char * vmsd_name)
{
    if (trace_event_get_state(TRACE_VMSTATE_SAVE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_save " "%s, %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , idstr, vmsd_name);
    }
}

static inline void trace_vmstate_save(const char * idstr, const char * vmsd_name)
{
    if (true) {
        _nocheck__trace_vmstate_save(idstr, vmsd_name);
    }
}

#define TRACE_VMSTATE_SAVE_STATE_PRE_SAVE_RES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_SAVE_STATE_PRE_SAVE_RES) || \
    false)

static inline void _nocheck__trace_vmstate_save_state_pre_save_res(const char * name, int res)
{
    if (trace_event_get_state(TRACE_VMSTATE_SAVE_STATE_PRE_SAVE_RES)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_save_state_pre_save_res " "%s/%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, res);
    }
}

static inline void trace_vmstate_save_state_pre_save_res(const char * name, int res)
{
    if (true) {
        _nocheck__trace_vmstate_save_state_pre_save_res(name, res);
    }
}

#define TRACE_VMSTATE_SAVE_STATE_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_SAVE_STATE_LOOP) || \
    false)

static inline void _nocheck__trace_vmstate_save_state_loop(const char * name, const char * field, int n_elems)
{
    if (trace_event_get_state(TRACE_VMSTATE_SAVE_STATE_LOOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_save_state_loop " "%s/%s[%d]" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, field, n_elems);
    }
}

static inline void trace_vmstate_save_state_loop(const char * name, const char * field, int n_elems)
{
    if (true) {
        _nocheck__trace_vmstate_save_state_loop(name, field, n_elems);
    }
}

#define TRACE_VMSTATE_SAVE_STATE_TOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_SAVE_STATE_TOP) || \
    false)

static inline void _nocheck__trace_vmstate_save_state_top(const char * idstr)
{
    if (trace_event_get_state(TRACE_VMSTATE_SAVE_STATE_TOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_save_state_top " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , idstr);
    }
}

static inline void trace_vmstate_save_state_top(const char * idstr)
{
    if (true) {
        _nocheck__trace_vmstate_save_state_top(idstr);
    }
}

#define TRACE_VMSTATE_SUBSECTION_SAVE_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_SUBSECTION_SAVE_LOOP) || \
    false)

static inline void _nocheck__trace_vmstate_subsection_save_loop(const char * name, const char * sub)
{
    if (trace_event_get_state(TRACE_VMSTATE_SUBSECTION_SAVE_LOOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_subsection_save_loop " "%s/%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, sub);
    }
}

static inline void trace_vmstate_subsection_save_loop(const char * name, const char * sub)
{
    if (true) {
        _nocheck__trace_vmstate_subsection_save_loop(name, sub);
    }
}

#define TRACE_VMSTATE_SUBSECTION_SAVE_TOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_SUBSECTION_SAVE_TOP) || \
    false)

static inline void _nocheck__trace_vmstate_subsection_save_top(const char * idstr)
{
    if (trace_event_get_state(TRACE_VMSTATE_SUBSECTION_SAVE_TOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_subsection_save_top " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , idstr);
    }
}

static inline void trace_vmstate_subsection_save_top(const char * idstr)
{
    if (true) {
        _nocheck__trace_vmstate_subsection_save_top(idstr);
    }
}

#define TRACE_VMSTATE_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_LOAD) || \
    false)

static inline void _nocheck__trace_vmstate_load(const char * idstr, const char * vmsd_name)
{
    if (trace_event_get_state(TRACE_VMSTATE_LOAD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_load " "%s, %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , idstr, vmsd_name);
    }
}

static inline void trace_vmstate_load(const char * idstr, const char * vmsd_name)
{
    if (true) {
        _nocheck__trace_vmstate_load(idstr, vmsd_name);
    }
}

#define TRACE_QEMU_ANNOUNCE_SELF_ITER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_ANNOUNCE_SELF_ITER) || \
    false)

static inline void _nocheck__trace_qemu_announce_self_iter(const char * mac)
{
    if (trace_event_get_state(TRACE_QEMU_ANNOUNCE_SELF_ITER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_announce_self_iter " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , mac);
    }
}

static inline void trace_qemu_announce_self_iter(const char * mac)
{
    if (true) {
        _nocheck__trace_qemu_announce_self_iter(mac);
    }
}

#define TRACE_VMSTATE_LOAD_FIELD_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_LOAD_FIELD_ERROR) || \
    false)

static inline void _nocheck__trace_vmstate_load_field_error(const char * field, int ret)
{
    if (trace_event_get_state(TRACE_VMSTATE_LOAD_FIELD_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_load_field_error " "field \"%s\" load failed, ret = %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , field, ret);
    }
}

static inline void trace_vmstate_load_field_error(const char * field, int ret)
{
    if (true) {
        _nocheck__trace_vmstate_load_field_error(field, ret);
    }
}

#define TRACE_VMSTATE_LOAD_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_LOAD_STATE) || \
    false)

static inline void _nocheck__trace_vmstate_load_state(const char * name, int version_id)
{
    if (trace_event_get_state(TRACE_VMSTATE_LOAD_STATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_load_state " "%s v%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, version_id);
    }
}

static inline void trace_vmstate_load_state(const char * name, int version_id)
{
    if (true) {
        _nocheck__trace_vmstate_load_state(name, version_id);
    }
}

#define TRACE_VMSTATE_LOAD_STATE_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_LOAD_STATE_END) || \
    false)

static inline void _nocheck__trace_vmstate_load_state_end(const char * name, const char * reason, int val)
{
    if (trace_event_get_state(TRACE_VMSTATE_LOAD_STATE_END)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_load_state_end " "%s %s/%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, reason, val);
    }
}

static inline void trace_vmstate_load_state_end(const char * name, const char * reason, int val)
{
    if (true) {
        _nocheck__trace_vmstate_load_state_end(name, reason, val);
    }
}

#define TRACE_VMSTATE_LOAD_STATE_FIELD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_LOAD_STATE_FIELD) || \
    false)

static inline void _nocheck__trace_vmstate_load_state_field(const char * name, const char * field)
{
    if (trace_event_get_state(TRACE_VMSTATE_LOAD_STATE_FIELD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_load_state_field " "%s:%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, field);
    }
}

static inline void trace_vmstate_load_state_field(const char * name, const char * field)
{
    if (true) {
        _nocheck__trace_vmstate_load_state_field(name, field);
    }
}

#define TRACE_VMSTATE_N_ELEMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_N_ELEMS) || \
    false)

static inline void _nocheck__trace_vmstate_n_elems(const char * name, int n_elems)
{
    if (trace_event_get_state(TRACE_VMSTATE_N_ELEMS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_n_elems " "%s: %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, n_elems);
    }
}

static inline void trace_vmstate_n_elems(const char * name, int n_elems)
{
    if (true) {
        _nocheck__trace_vmstate_n_elems(name, n_elems);
    }
}

#define TRACE_VMSTATE_SUBSECTION_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_SUBSECTION_LOAD) || \
    false)

static inline void _nocheck__trace_vmstate_subsection_load(const char * parent)
{
    if (trace_event_get_state(TRACE_VMSTATE_SUBSECTION_LOAD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_subsection_load " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , parent);
    }
}

static inline void trace_vmstate_subsection_load(const char * parent)
{
    if (true) {
        _nocheck__trace_vmstate_subsection_load(parent);
    }
}

#define TRACE_VMSTATE_SUBSECTION_LOAD_BAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_SUBSECTION_LOAD_BAD) || \
    false)

static inline void _nocheck__trace_vmstate_subsection_load_bad(const char * parent, const char * sub, const char * sub2)
{
    if (trace_event_get_state(TRACE_VMSTATE_SUBSECTION_LOAD_BAD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_subsection_load_bad " "%s: %s/%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , parent, sub, sub2);
    }
}

static inline void trace_vmstate_subsection_load_bad(const char * parent, const char * sub, const char * sub2)
{
    if (true) {
        _nocheck__trace_vmstate_subsection_load_bad(parent, sub, sub2);
    }
}

#define TRACE_VMSTATE_SUBSECTION_LOAD_GOOD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMSTATE_SUBSECTION_LOAD_GOOD) || \
    false)

static inline void _nocheck__trace_vmstate_subsection_load_good(const char * parent)
{
    if (trace_event_get_state(TRACE_VMSTATE_SUBSECTION_LOAD_GOOD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vmstate_subsection_load_good " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , parent);
    }
}

static inline void trace_vmstate_subsection_load_good(const char * parent)
{
    if (true) {
        _nocheck__trace_vmstate_subsection_load_good(parent);
    }
}

#define TRACE_GET_QTAILQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GET_QTAILQ) || \
    false)

static inline void _nocheck__trace_get_qtailq(const char * name, int version_id)
{
    if (trace_event_get_state(TRACE_GET_QTAILQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:get_qtailq " "%s v%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, version_id);
    }
}

static inline void trace_get_qtailq(const char * name, int version_id)
{
    if (true) {
        _nocheck__trace_get_qtailq(name, version_id);
    }
}

#define TRACE_GET_QTAILQ_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GET_QTAILQ_END) || \
    false)

static inline void _nocheck__trace_get_qtailq_end(const char * name, const char * reason, int val)
{
    if (trace_event_get_state(TRACE_GET_QTAILQ_END)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:get_qtailq_end " "%s %s/%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, reason, val);
    }
}

static inline void trace_get_qtailq_end(const char * name, const char * reason, int val)
{
    if (true) {
        _nocheck__trace_get_qtailq_end(name, reason, val);
    }
}

#define TRACE_PUT_QTAILQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PUT_QTAILQ) || \
    false)

static inline void _nocheck__trace_put_qtailq(const char * name, int version_id)
{
    if (trace_event_get_state(TRACE_PUT_QTAILQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:put_qtailq " "%s v%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, version_id);
    }
}

static inline void trace_put_qtailq(const char * name, int version_id)
{
    if (true) {
        _nocheck__trace_put_qtailq(name, version_id);
    }
}

#define TRACE_PUT_QTAILQ_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PUT_QTAILQ_END) || \
    false)

static inline void _nocheck__trace_put_qtailq_end(const char * name, const char * reason)
{
    if (trace_event_get_state(TRACE_PUT_QTAILQ_END)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:put_qtailq_end " "%s %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, reason);
    }
}

static inline void trace_put_qtailq_end(const char * name, const char * reason)
{
    if (true) {
        _nocheck__trace_put_qtailq_end(name, reason);
    }
}

#define TRACE_QEMU_FILE_FCLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_FILE_FCLOSE) || \
    false)

static inline void _nocheck__trace_qemu_file_fclose(void)
{
    if (trace_event_get_state(TRACE_QEMU_FILE_FCLOSE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_file_fclose " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_file_fclose(void)
{
    if (true) {
        _nocheck__trace_qemu_file_fclose();
    }
}

#define TRACE_GET_QUEUED_PAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GET_QUEUED_PAGE) || \
    false)

static inline void _nocheck__trace_get_queued_page(const char * block_name, uint64_t tmp_offset, unsigned long page_abs)
{
    if (trace_event_get_state(TRACE_GET_QUEUED_PAGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:get_queued_page " "%s/0x%" PRIx64 " page_abs=0x%lx" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , block_name, tmp_offset, page_abs);
    }
}

static inline void trace_get_queued_page(const char * block_name, uint64_t tmp_offset, unsigned long page_abs)
{
    if (true) {
        _nocheck__trace_get_queued_page(block_name, tmp_offset, page_abs);
    }
}

#define TRACE_GET_QUEUED_PAGE_NOT_DIRTY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GET_QUEUED_PAGE_NOT_DIRTY) || \
    false)

static inline void _nocheck__trace_get_queued_page_not_dirty(const char * block_name, uint64_t tmp_offset, unsigned long page_abs, int sent)
{
    if (trace_event_get_state(TRACE_GET_QUEUED_PAGE_NOT_DIRTY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:get_queued_page_not_dirty " "%s/0x%" PRIx64 " page_abs=0x%lx (sent=%d)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , block_name, tmp_offset, page_abs, sent);
    }
}

static inline void trace_get_queued_page_not_dirty(const char * block_name, uint64_t tmp_offset, unsigned long page_abs, int sent)
{
    if (true) {
        _nocheck__trace_get_queued_page_not_dirty(block_name, tmp_offset, page_abs, sent);
    }
}

#define TRACE_MIGRATION_BITMAP_SYNC_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_BITMAP_SYNC_START) || \
    false)

static inline void _nocheck__trace_migration_bitmap_sync_start(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_BITMAP_SYNC_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_bitmap_sync_start " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_bitmap_sync_start(void)
{
    if (true) {
        _nocheck__trace_migration_bitmap_sync_start();
    }
}

#define TRACE_MIGRATION_BITMAP_SYNC_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_BITMAP_SYNC_END) || \
    false)

static inline void _nocheck__trace_migration_bitmap_sync_end(uint64_t dirty_pages)
{
    if (trace_event_get_state(TRACE_MIGRATION_BITMAP_SYNC_END)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_bitmap_sync_end " "dirty_pages %" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , dirty_pages);
    }
}

static inline void trace_migration_bitmap_sync_end(uint64_t dirty_pages)
{
    if (true) {
        _nocheck__trace_migration_bitmap_sync_end(dirty_pages);
    }
}

#define TRACE_MIGRATION_THROTTLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_THROTTLE) || \
    false)

static inline void _nocheck__trace_migration_throttle(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_THROTTLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_throttle " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_throttle(void)
{
    if (true) {
        _nocheck__trace_migration_throttle();
    }
}

#define TRACE_RAM_DISCARD_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RAM_DISCARD_RANGE) || \
    false)

static inline void _nocheck__trace_ram_discard_range(const char * rbname, uint64_t start, size_t len)
{
    if (trace_event_get_state(TRACE_RAM_DISCARD_RANGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:ram_discard_range " "%s: start: %" PRIx64 " %zx" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , rbname, start, len);
    }
}

static inline void trace_ram_discard_range(const char * rbname, uint64_t start, size_t len)
{
    if (true) {
        _nocheck__trace_ram_discard_range(rbname, start, len);
    }
}

#define TRACE_RAM_LOAD_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RAM_LOAD_LOOP) || \
    false)

static inline void _nocheck__trace_ram_load_loop(const char * rbname, uint64_t addr, int flags, void * host)
{
    if (trace_event_get_state(TRACE_RAM_LOAD_LOOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:ram_load_loop " "%s: addr: 0x%" PRIx64 " flags: 0x%x host: %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , rbname, addr, flags, host);
    }
}

static inline void trace_ram_load_loop(const char * rbname, uint64_t addr, int flags, void * host)
{
    if (true) {
        _nocheck__trace_ram_load_loop(rbname, addr, flags, host);
    }
}

#define TRACE_RAM_LOAD_POSTCOPY_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RAM_LOAD_POSTCOPY_LOOP) || \
    false)

static inline void _nocheck__trace_ram_load_postcopy_loop(uint64_t addr, int flags)
{
    if (trace_event_get_state(TRACE_RAM_LOAD_POSTCOPY_LOOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:ram_load_postcopy_loop " "@%" PRIx64 " %x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, flags);
    }
}

static inline void trace_ram_load_postcopy_loop(uint64_t addr, int flags)
{
    if (true) {
        _nocheck__trace_ram_load_postcopy_loop(addr, flags);
    }
}

#define TRACE_RAM_POSTCOPY_SEND_DISCARD_BITMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RAM_POSTCOPY_SEND_DISCARD_BITMAP) || \
    false)

static inline void _nocheck__trace_ram_postcopy_send_discard_bitmap(void)
{
    if (trace_event_get_state(TRACE_RAM_POSTCOPY_SEND_DISCARD_BITMAP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:ram_postcopy_send_discard_bitmap " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_ram_postcopy_send_discard_bitmap(void)
{
    if (true) {
        _nocheck__trace_ram_postcopy_send_discard_bitmap();
    }
}

#define TRACE_RAM_SAVE_PAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RAM_SAVE_PAGE) || \
    false)

static inline void _nocheck__trace_ram_save_page(const char * rbname, uint64_t offset, void * host)
{
    if (trace_event_get_state(TRACE_RAM_SAVE_PAGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:ram_save_page " "%s: offset: 0x%" PRIx64 " host: %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , rbname, offset, host);
    }
}

static inline void trace_ram_save_page(const char * rbname, uint64_t offset, void * host)
{
    if (true) {
        _nocheck__trace_ram_save_page(rbname, offset, host);
    }
}

#define TRACE_RAM_SAVE_QUEUE_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RAM_SAVE_QUEUE_PAGES) || \
    false)

static inline void _nocheck__trace_ram_save_queue_pages(const char * rbname, size_t start, size_t len)
{
    if (trace_event_get_state(TRACE_RAM_SAVE_QUEUE_PAGES)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:ram_save_queue_pages " "%s: start: 0x%zx len: 0x%zx" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , rbname, start, len);
    }
}

static inline void trace_ram_save_queue_pages(const char * rbname, size_t start, size_t len)
{
    if (true) {
        _nocheck__trace_ram_save_queue_pages(rbname, start, len);
    }
}

#define TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_CLOSE) || \
    false)

static inline void _nocheck__trace_await_return_path_close_on_source_close(void)
{
    if (trace_event_get_state(TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_CLOSE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:await_return_path_close_on_source_close " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_await_return_path_close_on_source_close(void)
{
    if (true) {
        _nocheck__trace_await_return_path_close_on_source_close();
    }
}

#define TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_JOINING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_JOINING) || \
    false)

static inline void _nocheck__trace_await_return_path_close_on_source_joining(void)
{
    if (trace_event_get_state(TRACE_AWAIT_RETURN_PATH_CLOSE_ON_SOURCE_JOINING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:await_return_path_close_on_source_joining " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_await_return_path_close_on_source_joining(void)
{
    if (true) {
        _nocheck__trace_await_return_path_close_on_source_joining();
    }
}

#define TRACE_MIGRATE_SET_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_SET_STATE) || \
    false)

static inline void _nocheck__trace_migrate_set_state(const char * new_state)
{
    if (trace_event_get_state(TRACE_MIGRATE_SET_STATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_set_state " "new state %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , new_state);
    }
}

static inline void trace_migrate_set_state(const char * new_state)
{
    if (true) {
        _nocheck__trace_migrate_set_state(new_state);
    }
}

#define TRACE_MIGRATE_FD_CLEANUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_FD_CLEANUP) || \
    false)

static inline void _nocheck__trace_migrate_fd_cleanup(void)
{
    if (trace_event_get_state(TRACE_MIGRATE_FD_CLEANUP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_fd_cleanup " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migrate_fd_cleanup(void)
{
    if (true) {
        _nocheck__trace_migrate_fd_cleanup();
    }
}

#define TRACE_MIGRATE_FD_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_FD_ERROR) || \
    false)

static inline void _nocheck__trace_migrate_fd_error(const char * error_desc)
{
    if (trace_event_get_state(TRACE_MIGRATE_FD_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_fd_error " "error=%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , error_desc);
    }
}

static inline void trace_migrate_fd_error(const char * error_desc)
{
    if (true) {
        _nocheck__trace_migrate_fd_error(error_desc);
    }
}

#define TRACE_MIGRATE_FD_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_FD_CANCEL) || \
    false)

static inline void _nocheck__trace_migrate_fd_cancel(void)
{
    if (trace_event_get_state(TRACE_MIGRATE_FD_CANCEL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_fd_cancel " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migrate_fd_cancel(void)
{
    if (true) {
        _nocheck__trace_migrate_fd_cancel();
    }
}

#define TRACE_MIGRATE_HANDLE_RP_REQ_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_HANDLE_RP_REQ_PAGES) || \
    false)

static inline void _nocheck__trace_migrate_handle_rp_req_pages(const char * rbname, size_t start, size_t len)
{
    if (trace_event_get_state(TRACE_MIGRATE_HANDLE_RP_REQ_PAGES)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_handle_rp_req_pages " "in %s at 0x%zx len 0x%zx" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , rbname, start, len);
    }
}

static inline void trace_migrate_handle_rp_req_pages(const char * rbname, size_t start, size_t len)
{
    if (true) {
        _nocheck__trace_migrate_handle_rp_req_pages(rbname, start, len);
    }
}

#define TRACE_MIGRATE_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_PENDING) || \
    false)

static inline void _nocheck__trace_migrate_pending(uint64_t size, uint64_t max, uint64_t post, uint64_t nonpost)
{
    if (trace_event_get_state(TRACE_MIGRATE_PENDING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_pending " "pending size %" PRIu64 " max %" PRIu64 " (post=%" PRIu64 " nonpost=%" PRIu64 ")" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , size, max, post, nonpost);
    }
}

static inline void trace_migrate_pending(uint64_t size, uint64_t max, uint64_t post, uint64_t nonpost)
{
    if (true) {
        _nocheck__trace_migrate_pending(size, max, post, nonpost);
    }
}

#define TRACE_MIGRATE_SEND_RP_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_SEND_RP_MESSAGE) || \
    false)

static inline void _nocheck__trace_migrate_send_rp_message(int msg_type, uint16_t len)
{
    if (trace_event_get_state(TRACE_MIGRATE_SEND_RP_MESSAGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_send_rp_message " "%d: len %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , msg_type, len);
    }
}

static inline void trace_migrate_send_rp_message(int msg_type, uint16_t len)
{
    if (true) {
        _nocheck__trace_migrate_send_rp_message(msg_type, len);
    }
}

#define TRACE_MIGRATION_COMPLETION_FILE_ERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_COMPLETION_FILE_ERR) || \
    false)

static inline void _nocheck__trace_migration_completion_file_err(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_COMPLETION_FILE_ERR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_completion_file_err " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_completion_file_err(void)
{
    if (true) {
        _nocheck__trace_migration_completion_file_err();
    }
}

#define TRACE_MIGRATION_COMPLETION_POSTCOPY_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_COMPLETION_POSTCOPY_END) || \
    false)

static inline void _nocheck__trace_migration_completion_postcopy_end(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_COMPLETION_POSTCOPY_END)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_completion_postcopy_end " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_completion_postcopy_end(void)
{
    if (true) {
        _nocheck__trace_migration_completion_postcopy_end();
    }
}

#define TRACE_MIGRATION_COMPLETION_POSTCOPY_END_AFTER_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_COMPLETION_POSTCOPY_END_AFTER_COMPLETE) || \
    false)

static inline void _nocheck__trace_migration_completion_postcopy_end_after_complete(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_COMPLETION_POSTCOPY_END_AFTER_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_completion_postcopy_end_after_complete " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_completion_postcopy_end_after_complete(void)
{
    if (true) {
        _nocheck__trace_migration_completion_postcopy_end_after_complete();
    }
}

#define TRACE_MIGRATION_RETURN_PATH_END_BEFORE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_RETURN_PATH_END_BEFORE) || \
    false)

static inline void _nocheck__trace_migration_return_path_end_before(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_RETURN_PATH_END_BEFORE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_return_path_end_before " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_return_path_end_before(void)
{
    if (true) {
        _nocheck__trace_migration_return_path_end_before();
    }
}

#define TRACE_MIGRATION_RETURN_PATH_END_AFTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_RETURN_PATH_END_AFTER) || \
    false)

static inline void _nocheck__trace_migration_return_path_end_after(int rp_error)
{
    if (trace_event_get_state(TRACE_MIGRATION_RETURN_PATH_END_AFTER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_return_path_end_after " "%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , rp_error);
    }
}

static inline void trace_migration_return_path_end_after(int rp_error)
{
    if (true) {
        _nocheck__trace_migration_return_path_end_after(rp_error);
    }
}

#define TRACE_MIGRATION_THREAD_AFTER_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_THREAD_AFTER_LOOP) || \
    false)

static inline void _nocheck__trace_migration_thread_after_loop(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_THREAD_AFTER_LOOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_thread_after_loop " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_thread_after_loop(void)
{
    if (true) {
        _nocheck__trace_migration_thread_after_loop();
    }
}

#define TRACE_MIGRATION_THREAD_FILE_ERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_THREAD_FILE_ERR) || \
    false)

static inline void _nocheck__trace_migration_thread_file_err(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_THREAD_FILE_ERR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_thread_file_err " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_thread_file_err(void)
{
    if (true) {
        _nocheck__trace_migration_thread_file_err();
    }
}

#define TRACE_MIGRATION_THREAD_SETUP_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_THREAD_SETUP_COMPLETE) || \
    false)

static inline void _nocheck__trace_migration_thread_setup_complete(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_THREAD_SETUP_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_thread_setup_complete " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_thread_setup_complete(void)
{
    if (true) {
        _nocheck__trace_migration_thread_setup_complete();
    }
}

#define TRACE_OPEN_RETURN_PATH_ON_SOURCE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_OPEN_RETURN_PATH_ON_SOURCE) || \
    false)

static inline void _nocheck__trace_open_return_path_on_source(void)
{
    if (trace_event_get_state(TRACE_OPEN_RETURN_PATH_ON_SOURCE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:open_return_path_on_source " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_open_return_path_on_source(void)
{
    if (true) {
        _nocheck__trace_open_return_path_on_source();
    }
}

#define TRACE_OPEN_RETURN_PATH_ON_SOURCE_CONTINUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_OPEN_RETURN_PATH_ON_SOURCE_CONTINUE) || \
    false)

static inline void _nocheck__trace_open_return_path_on_source_continue(void)
{
    if (trace_event_get_state(TRACE_OPEN_RETURN_PATH_ON_SOURCE_CONTINUE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:open_return_path_on_source_continue " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_open_return_path_on_source_continue(void)
{
    if (true) {
        _nocheck__trace_open_return_path_on_source_continue();
    }
}

#define TRACE_POSTCOPY_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_START) || \
    false)

static inline void _nocheck__trace_postcopy_start(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_start " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_start(void)
{
    if (true) {
        _nocheck__trace_postcopy_start();
    }
}

#define TRACE_POSTCOPY_START_SET_RUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_START_SET_RUN) || \
    false)

static inline void _nocheck__trace_postcopy_start_set_run(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_START_SET_RUN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_start_set_run " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_start_set_run(void)
{
    if (true) {
        _nocheck__trace_postcopy_start_set_run();
    }
}

#define TRACE_SOURCE_RETURN_PATH_THREAD_BAD_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SOURCE_RETURN_PATH_THREAD_BAD_END) || \
    false)

static inline void _nocheck__trace_source_return_path_thread_bad_end(void)
{
    if (trace_event_get_state(TRACE_SOURCE_RETURN_PATH_THREAD_BAD_END)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:source_return_path_thread_bad_end " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_source_return_path_thread_bad_end(void)
{
    if (true) {
        _nocheck__trace_source_return_path_thread_bad_end();
    }
}

#define TRACE_SOURCE_RETURN_PATH_THREAD_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SOURCE_RETURN_PATH_THREAD_END) || \
    false)

static inline void _nocheck__trace_source_return_path_thread_end(void)
{
    if (trace_event_get_state(TRACE_SOURCE_RETURN_PATH_THREAD_END)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:source_return_path_thread_end " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_source_return_path_thread_end(void)
{
    if (true) {
        _nocheck__trace_source_return_path_thread_end();
    }
}

#define TRACE_SOURCE_RETURN_PATH_THREAD_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SOURCE_RETURN_PATH_THREAD_ENTRY) || \
    false)

static inline void _nocheck__trace_source_return_path_thread_entry(void)
{
    if (trace_event_get_state(TRACE_SOURCE_RETURN_PATH_THREAD_ENTRY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:source_return_path_thread_entry " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_source_return_path_thread_entry(void)
{
    if (true) {
        _nocheck__trace_source_return_path_thread_entry();
    }
}

#define TRACE_SOURCE_RETURN_PATH_THREAD_LOOP_TOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SOURCE_RETURN_PATH_THREAD_LOOP_TOP) || \
    false)

static inline void _nocheck__trace_source_return_path_thread_loop_top(void)
{
    if (trace_event_get_state(TRACE_SOURCE_RETURN_PATH_THREAD_LOOP_TOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:source_return_path_thread_loop_top " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_source_return_path_thread_loop_top(void)
{
    if (true) {
        _nocheck__trace_source_return_path_thread_loop_top();
    }
}

#define TRACE_SOURCE_RETURN_PATH_THREAD_PONG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SOURCE_RETURN_PATH_THREAD_PONG) || \
    false)

static inline void _nocheck__trace_source_return_path_thread_pong(uint32_t val)
{
    if (trace_event_get_state(TRACE_SOURCE_RETURN_PATH_THREAD_PONG)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:source_return_path_thread_pong " "0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , val);
    }
}

static inline void trace_source_return_path_thread_pong(uint32_t val)
{
    if (true) {
        _nocheck__trace_source_return_path_thread_pong(val);
    }
}

#define TRACE_SOURCE_RETURN_PATH_THREAD_SHUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SOURCE_RETURN_PATH_THREAD_SHUT) || \
    false)

static inline void _nocheck__trace_source_return_path_thread_shut(uint32_t val)
{
    if (trace_event_get_state(TRACE_SOURCE_RETURN_PATH_THREAD_SHUT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:source_return_path_thread_shut " "0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , val);
    }
}

static inline void trace_source_return_path_thread_shut(uint32_t val)
{
    if (true) {
        _nocheck__trace_source_return_path_thread_shut(val);
    }
}

#define TRACE_MIGRATE_GLOBAL_STATE_POST_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_GLOBAL_STATE_POST_LOAD) || \
    false)

static inline void _nocheck__trace_migrate_global_state_post_load(const char * state)
{
    if (trace_event_get_state(TRACE_MIGRATE_GLOBAL_STATE_POST_LOAD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_global_state_post_load " "loaded state: %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , state);
    }
}

static inline void trace_migrate_global_state_post_load(const char * state)
{
    if (true) {
        _nocheck__trace_migrate_global_state_post_load(state);
    }
}

#define TRACE_MIGRATE_GLOBAL_STATE_PRE_SAVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_GLOBAL_STATE_PRE_SAVE) || \
    false)

static inline void _nocheck__trace_migrate_global_state_pre_save(const char * state)
{
    if (trace_event_get_state(TRACE_MIGRATE_GLOBAL_STATE_PRE_SAVE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_global_state_pre_save " "saved state: %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , state);
    }
}

static inline void trace_migrate_global_state_pre_save(const char * state)
{
    if (true) {
        _nocheck__trace_migrate_global_state_pre_save(state);
    }
}

#define TRACE_MIGRATION_THREAD_LOW_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_THREAD_LOW_PENDING) || \
    false)

static inline void _nocheck__trace_migration_thread_low_pending(uint64_t pending)
{
    if (trace_event_get_state(TRACE_MIGRATION_THREAD_LOW_PENDING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_thread_low_pending " "%" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , pending);
    }
}

static inline void trace_migration_thread_low_pending(uint64_t pending)
{
    if (true) {
        _nocheck__trace_migration_thread_low_pending(pending);
    }
}

#define TRACE_MIGRATE_STATE_TOO_BIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_STATE_TOO_BIG) || \
    false)

static inline void _nocheck__trace_migrate_state_too_big(void)
{
    if (trace_event_get_state(TRACE_MIGRATE_STATE_TOO_BIG)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_state_too_big " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migrate_state_too_big(void)
{
    if (true) {
        _nocheck__trace_migrate_state_too_big();
    }
}

#define TRACE_MIGRATE_TRANSFERRED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATE_TRANSFERRED) || \
    false)

static inline void _nocheck__trace_migrate_transferred(uint64_t tranferred, uint64_t time_spent, double bandwidth, uint64_t size)
{
    if (trace_event_get_state(TRACE_MIGRATE_TRANSFERRED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migrate_transferred " "transferred %" PRIu64 " time_spent %" PRIu64 " bandwidth %g max_size %" PRId64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , tranferred, time_spent, bandwidth, size);
    }
}

static inline void trace_migrate_transferred(uint64_t tranferred, uint64_t time_spent, double bandwidth, uint64_t size)
{
    if (true) {
        _nocheck__trace_migrate_transferred(tranferred, time_spent, bandwidth, size);
    }
}

#define TRACE_PROCESS_INCOMING_MIGRATION_CO_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_INCOMING_MIGRATION_CO_END) || \
    false)

static inline void _nocheck__trace_process_incoming_migration_co_end(int ret, int ps)
{
    if (trace_event_get_state(TRACE_PROCESS_INCOMING_MIGRATION_CO_END)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:process_incoming_migration_co_end " "ret=%d postcopy-state=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ret, ps);
    }
}

static inline void trace_process_incoming_migration_co_end(int ret, int ps)
{
    if (true) {
        _nocheck__trace_process_incoming_migration_co_end(ret, ps);
    }
}

#define TRACE_PROCESS_INCOMING_MIGRATION_CO_POSTCOPY_END_MAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_INCOMING_MIGRATION_CO_POSTCOPY_END_MAIN) || \
    false)

static inline void _nocheck__trace_process_incoming_migration_co_postcopy_end_main(void)
{
    if (trace_event_get_state(TRACE_PROCESS_INCOMING_MIGRATION_CO_POSTCOPY_END_MAIN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:process_incoming_migration_co_postcopy_end_main " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_process_incoming_migration_co_postcopy_end_main(void)
{
    if (true) {
        _nocheck__trace_process_incoming_migration_co_postcopy_end_main();
    }
}

#define TRACE_MIGRATION_SET_INCOMING_CHANNEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_SET_INCOMING_CHANNEL) || \
    false)

static inline void _nocheck__trace_migration_set_incoming_channel(void * ioc, const char * ioctype)
{
    if (trace_event_get_state(TRACE_MIGRATION_SET_INCOMING_CHANNEL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_set_incoming_channel " "ioc=%p ioctype=%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ioc, ioctype);
    }
}

static inline void trace_migration_set_incoming_channel(void * ioc, const char * ioctype)
{
    if (true) {
        _nocheck__trace_migration_set_incoming_channel(ioc, ioctype);
    }
}

#define TRACE_MIGRATION_SET_OUTGOING_CHANNEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_SET_OUTGOING_CHANNEL) || \
    false)

static inline void _nocheck__trace_migration_set_outgoing_channel(void * ioc, const char * ioctype, const char * hostname, void * err)
{
    if (trace_event_get_state(TRACE_MIGRATION_SET_OUTGOING_CHANNEL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_set_outgoing_channel " "ioc=%p ioctype=%s hostname=%s err=%p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ioc, ioctype, hostname, err);
    }
}

static inline void trace_migration_set_outgoing_channel(void * ioc, const char * ioctype, const char * hostname, void * err)
{
    if (true) {
        _nocheck__trace_migration_set_outgoing_channel(ioc, ioctype, hostname, err);
    }
}

#define TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION) || \
    false)

static inline void _nocheck__trace_qemu_rdma_accept_incoming_migration(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_accept_incoming_migration " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_accept_incoming_migration(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_accept_incoming_migration();
    }
}

#define TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION_ACCEPTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION_ACCEPTED) || \
    false)

static inline void _nocheck__trace_qemu_rdma_accept_incoming_migration_accepted(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_ACCEPT_INCOMING_MIGRATION_ACCEPTED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_accept_incoming_migration_accepted " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_accept_incoming_migration_accepted(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_accept_incoming_migration_accepted();
    }
}

#define TRACE_QEMU_RDMA_ACCEPT_PIN_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_ACCEPT_PIN_STATE) || \
    false)

static inline void _nocheck__trace_qemu_rdma_accept_pin_state(bool pin)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_ACCEPT_PIN_STATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_accept_pin_state " "%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , pin);
    }
}

static inline void trace_qemu_rdma_accept_pin_state(bool pin)
{
    if (true) {
        _nocheck__trace_qemu_rdma_accept_pin_state(pin);
    }
}

#define TRACE_QEMU_RDMA_ACCEPT_PIN_VERBSC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_ACCEPT_PIN_VERBSC) || \
    false)

static inline void _nocheck__trace_qemu_rdma_accept_pin_verbsc(void * verbs)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_ACCEPT_PIN_VERBSC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_accept_pin_verbsc " "Verbs context after listen: %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , verbs);
    }
}

static inline void trace_qemu_rdma_accept_pin_verbsc(void * verbs)
{
    if (true) {
        _nocheck__trace_qemu_rdma_accept_pin_verbsc(verbs);
    }
}

#define TRACE_QEMU_RDMA_BLOCK_FOR_WRID_MISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_BLOCK_FOR_WRID_MISS) || \
    false)

static inline void _nocheck__trace_qemu_rdma_block_for_wrid_miss(const char * wcompstr, int wcomp, const char * gcompstr, uint64_t req)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_BLOCK_FOR_WRID_MISS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_block_for_wrid_miss " "A Wanted wrid %s (%d) but got %s (%" PRIu64 ")" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , wcompstr, wcomp, gcompstr, req);
    }
}

static inline void trace_qemu_rdma_block_for_wrid_miss(const char * wcompstr, int wcomp, const char * gcompstr, uint64_t req)
{
    if (true) {
        _nocheck__trace_qemu_rdma_block_for_wrid_miss(wcompstr, wcomp, gcompstr, req);
    }
}

#define TRACE_QEMU_RDMA_CLEANUP_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_CLEANUP_DISCONNECT) || \
    false)

static inline void _nocheck__trace_qemu_rdma_cleanup_disconnect(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_CLEANUP_DISCONNECT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_cleanup_disconnect " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_cleanup_disconnect(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_cleanup_disconnect();
    }
}

#define TRACE_QEMU_RDMA_CLEANUP_WAITING_FOR_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_CLEANUP_WAITING_FOR_DISCONNECT) || \
    false)

static inline void _nocheck__trace_qemu_rdma_cleanup_waiting_for_disconnect(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_CLEANUP_WAITING_FOR_DISCONNECT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_cleanup_waiting_for_disconnect " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_cleanup_waiting_for_disconnect(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_cleanup_waiting_for_disconnect();
    }
}

#define TRACE_QEMU_RDMA_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_CLOSE) || \
    false)

static inline void _nocheck__trace_qemu_rdma_close(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_CLOSE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_close " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_close(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_close();
    }
}

#define TRACE_QEMU_RDMA_CONNECT_PIN_ALL_REQUESTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_CONNECT_PIN_ALL_REQUESTED) || \
    false)

static inline void _nocheck__trace_qemu_rdma_connect_pin_all_requested(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_CONNECT_PIN_ALL_REQUESTED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_connect_pin_all_requested " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_connect_pin_all_requested(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_connect_pin_all_requested();
    }
}

#define TRACE_QEMU_RDMA_CONNECT_PIN_ALL_OUTCOME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_CONNECT_PIN_ALL_OUTCOME) || \
    false)

static inline void _nocheck__trace_qemu_rdma_connect_pin_all_outcome(bool pin)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_CONNECT_PIN_ALL_OUTCOME)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_connect_pin_all_outcome " "%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , pin);
    }
}

static inline void trace_qemu_rdma_connect_pin_all_outcome(bool pin)
{
    if (true) {
        _nocheck__trace_qemu_rdma_connect_pin_all_outcome(pin);
    }
}

#define TRACE_QEMU_RDMA_DEST_INIT_TRYING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_DEST_INIT_TRYING) || \
    false)

static inline void _nocheck__trace_qemu_rdma_dest_init_trying(const char * host, const char * ip)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_DEST_INIT_TRYING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_dest_init_trying " "%s => %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , host, ip);
    }
}

static inline void trace_qemu_rdma_dest_init_trying(const char * host, const char * ip)
{
    if (true) {
        _nocheck__trace_qemu_rdma_dest_init_trying(host, ip);
    }
}

#define TRACE_QEMU_RDMA_DUMP_GID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_DUMP_GID) || \
    false)

static inline void _nocheck__trace_qemu_rdma_dump_gid(const char * who, const char * src, const char * dst)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_DUMP_GID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_dump_gid " "%s Source GID: %s, Dest GID: %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , who, src, dst);
    }
}

static inline void trace_qemu_rdma_dump_gid(const char * who, const char * src, const char * dst)
{
    if (true) {
        _nocheck__trace_qemu_rdma_dump_gid(who, src, dst);
    }
}

#define TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_START) || \
    false)

static inline void _nocheck__trace_qemu_rdma_exchange_get_response_start(const char * desc)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_exchange_get_response_start " "CONTROL: %s receiving..." "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , desc);
    }
}

static inline void trace_qemu_rdma_exchange_get_response_start(const char * desc)
{
    if (true) {
        _nocheck__trace_qemu_rdma_exchange_get_response_start(desc);
    }
}

#define TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_NONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_NONE) || \
    false)

static inline void _nocheck__trace_qemu_rdma_exchange_get_response_none(const char * desc, int type)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_EXCHANGE_GET_RESPONSE_NONE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_exchange_get_response_none " "Surprise: got %s (%d)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , desc, type);
    }
}

static inline void trace_qemu_rdma_exchange_get_response_none(const char * desc, int type)
{
    if (true) {
        _nocheck__trace_qemu_rdma_exchange_get_response_none(desc, type);
    }
}

#define TRACE_QEMU_RDMA_EXCHANGE_SEND_ISSUE_CALLBACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_EXCHANGE_SEND_ISSUE_CALLBACK) || \
    false)

static inline void _nocheck__trace_qemu_rdma_exchange_send_issue_callback(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_EXCHANGE_SEND_ISSUE_CALLBACK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_exchange_send_issue_callback " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_exchange_send_issue_callback(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_exchange_send_issue_callback();
    }
}

#define TRACE_QEMU_RDMA_EXCHANGE_SEND_WAITING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_EXCHANGE_SEND_WAITING) || \
    false)

static inline void _nocheck__trace_qemu_rdma_exchange_send_waiting(const char * desc)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_EXCHANGE_SEND_WAITING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_exchange_send_waiting " "Waiting for response %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , desc);
    }
}

static inline void trace_qemu_rdma_exchange_send_waiting(const char * desc)
{
    if (true) {
        _nocheck__trace_qemu_rdma_exchange_send_waiting(desc);
    }
}

#define TRACE_QEMU_RDMA_EXCHANGE_SEND_RECEIVED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_EXCHANGE_SEND_RECEIVED) || \
    false)

static inline void _nocheck__trace_qemu_rdma_exchange_send_received(const char * desc)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_EXCHANGE_SEND_RECEIVED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_exchange_send_received " "Response %s received." "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , desc);
    }
}

static inline void trace_qemu_rdma_exchange_send_received(const char * desc)
{
    if (true) {
        _nocheck__trace_qemu_rdma_exchange_send_received(desc);
    }
}

#define TRACE_QEMU_RDMA_FILL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_FILL) || \
    false)

static inline void _nocheck__trace_qemu_rdma_fill(size_t control_len, size_t size)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_FILL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_fill " "RDMA %zd of %zd bytes already in buffer" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , control_len, size);
    }
}

static inline void trace_qemu_rdma_fill(size_t control_len, size_t size)
{
    if (true) {
        _nocheck__trace_qemu_rdma_fill(control_len, size);
    }
}

#define TRACE_QEMU_RDMA_INIT_RAM_BLOCKS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_INIT_RAM_BLOCKS) || \
    false)

static inline void _nocheck__trace_qemu_rdma_init_ram_blocks(int blocks)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_INIT_RAM_BLOCKS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_init_ram_blocks " "Allocated %d local ram block structures" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , blocks);
    }
}

static inline void trace_qemu_rdma_init_ram_blocks(int blocks)
{
    if (true) {
        _nocheck__trace_qemu_rdma_init_ram_blocks(blocks);
    }
}

#define TRACE_QEMU_RDMA_POLL_RECV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_POLL_RECV) || \
    false)

static inline void _nocheck__trace_qemu_rdma_poll_recv(const char * compstr, int64_t comp, int64_t id, int sent)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_POLL_RECV)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_poll_recv " "completion %s #%" PRId64 " received (%" PRId64 ") left %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , compstr, comp, id, sent);
    }
}

static inline void trace_qemu_rdma_poll_recv(const char * compstr, int64_t comp, int64_t id, int sent)
{
    if (true) {
        _nocheck__trace_qemu_rdma_poll_recv(compstr, comp, id, sent);
    }
}

#define TRACE_QEMU_RDMA_POLL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_POLL_WRITE) || \
    false)

static inline void _nocheck__trace_qemu_rdma_poll_write(const char * compstr, int64_t comp, int left, uint64_t block, uint64_t chunk, void * local, void * remote)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_POLL_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_poll_write " "completions %s (%" PRId64 ") left %d, block %" PRIu64 ", chunk: %" PRIu64 " %p %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , compstr, comp, left, block, chunk, local, remote);
    }
}

static inline void trace_qemu_rdma_poll_write(const char * compstr, int64_t comp, int left, uint64_t block, uint64_t chunk, void * local, void * remote)
{
    if (true) {
        _nocheck__trace_qemu_rdma_poll_write(compstr, comp, left, block, chunk, local, remote);
    }
}

#define TRACE_QEMU_RDMA_POLL_OTHER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_POLL_OTHER) || \
    false)

static inline void _nocheck__trace_qemu_rdma_poll_other(const char * compstr, int64_t comp, int left)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_POLL_OTHER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_poll_other " "other completion %s (%" PRId64 ") received left %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , compstr, comp, left);
    }
}

static inline void trace_qemu_rdma_poll_other(const char * compstr, int64_t comp, int left)
{
    if (true) {
        _nocheck__trace_qemu_rdma_poll_other(compstr, comp, left);
    }
}

#define TRACE_QEMU_RDMA_POST_SEND_CONTROL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_POST_SEND_CONTROL) || \
    false)

static inline void _nocheck__trace_qemu_rdma_post_send_control(const char * desc)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_POST_SEND_CONTROL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_post_send_control " "CONTROL: sending %s.." "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , desc);
    }
}

static inline void trace_qemu_rdma_post_send_control(const char * desc)
{
    if (true) {
        _nocheck__trace_qemu_rdma_post_send_control(desc);
    }
}

#define TRACE_QEMU_RDMA_REGISTER_AND_GET_KEYS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTER_AND_GET_KEYS) || \
    false)

static inline void _nocheck__trace_qemu_rdma_register_and_get_keys(uint64_t len, void * start)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTER_AND_GET_KEYS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_register_and_get_keys " "Registering %" PRIu64 " bytes @ %p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , len, start);
    }
}

static inline void trace_qemu_rdma_register_and_get_keys(uint64_t len, void * start)
{
    if (true) {
        _nocheck__trace_qemu_rdma_register_and_get_keys(len, start);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_COMPRESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_COMPRESS) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_compress(int64_t length, int index, int64_t offset)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_COMPRESS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_compress " "Zapping zero chunk: %" PRId64 " bytes, index %d, offset %" PRId64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , length, index, offset);
    }
}

static inline void trace_qemu_rdma_registration_handle_compress(int64_t length, int index, int64_t offset)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_compress(length, index, offset);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_FINISHED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_FINISHED) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_finished(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_FINISHED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_finished " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_registration_handle_finished(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_finished();
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_ram_blocks(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_ram_blocks " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_registration_handle_ram_blocks(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_ram_blocks();
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS_LOOP) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_ram_blocks_loop(const char * name, uint64_t offset, uint64_t length, void * local_host_addr, unsigned int src_index)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_RAM_BLOCKS_LOOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_ram_blocks_loop " "%s: @0x%" PRIx64 "/%" PRIu64 " host:@%p src_index: %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, offset, length, local_host_addr, src_index);
    }
}

static inline void trace_qemu_rdma_registration_handle_ram_blocks_loop(const char * name, uint64_t offset, uint64_t length, void * local_host_addr, unsigned int src_index)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_ram_blocks_loop(name, offset, length, local_host_addr, src_index);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_register(int requests)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_register " "%d requests" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , requests);
    }
}

static inline void trace_qemu_rdma_registration_handle_register(int requests)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_register(requests);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_LOOP) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_register_loop(int req, int index, uint64_t addr, uint64_t chunks)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_LOOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_register_loop " "Registration request (%d): index %d, current_addr %" PRIu64 " chunks: %" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , req, index, addr, chunks);
    }
}

static inline void trace_qemu_rdma_registration_handle_register_loop(int req, int index, uint64_t addr, uint64_t chunks)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_register_loop(req, index, addr, chunks);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_RKEY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_RKEY) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_register_rkey(int rkey)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_REGISTER_RKEY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_register_rkey " "0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , rkey);
    }
}

static inline void trace_qemu_rdma_registration_handle_register_rkey(int rkey)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_register_rkey(rkey);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_unregister(int requests)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_unregister " "%d requests" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , requests);
    }
}

static inline void trace_qemu_rdma_registration_handle_unregister(int requests)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_unregister(requests);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_LOOP) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_unregister_loop(int count, int index, uint64_t chunk)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_LOOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_unregister_loop " "Unregistration request (%d): index %d, chunk %" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , count, index, chunk);
    }
}

static inline void trace_qemu_rdma_registration_handle_unregister_loop(int count, int index, uint64_t chunk)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_unregister_loop(count, index, chunk);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_SUCCESS) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_unregister_success(uint64_t chunk)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_UNREGISTER_SUCCESS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_unregister_success " "%" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunk);
    }
}

static inline void trace_qemu_rdma_registration_handle_unregister_success(uint64_t chunk)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_unregister_success(chunk);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_HANDLE_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_WAIT) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_handle_wait(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_HANDLE_WAIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_handle_wait " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_registration_handle_wait(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_handle_wait();
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_START) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_start(uint64_t flags)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_start " "%" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , flags);
    }
}

static inline void trace_qemu_rdma_registration_start(uint64_t flags)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_start(flags);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_STOP) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_stop(uint64_t flags)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_STOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_stop " "%" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , flags);
    }
}

static inline void trace_qemu_rdma_registration_stop(uint64_t flags)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_stop(flags);
    }
}

#define TRACE_QEMU_RDMA_REGISTRATION_STOP_RAM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_REGISTRATION_STOP_RAM) || \
    false)

static inline void _nocheck__trace_qemu_rdma_registration_stop_ram(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_REGISTRATION_STOP_RAM)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_registration_stop_ram " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_registration_stop_ram(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_registration_stop_ram();
    }
}

#define TRACE_QEMU_RDMA_RESOLVE_HOST_TRYING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_RESOLVE_HOST_TRYING) || \
    false)

static inline void _nocheck__trace_qemu_rdma_resolve_host_trying(const char * host, const char * ip)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_RESOLVE_HOST_TRYING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_resolve_host_trying " "Trying %s => %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , host, ip);
    }
}

static inline void trace_qemu_rdma_resolve_host_trying(const char * host, const char * ip)
{
    if (true) {
        _nocheck__trace_qemu_rdma_resolve_host_trying(host, ip);
    }
}

#define TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_APPEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_APPEND) || \
    false)

static inline void _nocheck__trace_qemu_rdma_signal_unregister_append(uint64_t chunk, int pos)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_APPEND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_signal_unregister_append " "Appending unregister chunk %" PRIu64 " at position %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunk, pos);
    }
}

static inline void trace_qemu_rdma_signal_unregister_append(uint64_t chunk, int pos)
{
    if (true) {
        _nocheck__trace_qemu_rdma_signal_unregister_append(chunk, pos);
    }
}

#define TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_ALREADY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_ALREADY) || \
    false)

static inline void _nocheck__trace_qemu_rdma_signal_unregister_already(uint64_t chunk)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_SIGNAL_UNREGISTER_ALREADY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_signal_unregister_already " "Unregister chunk %" PRIu64 " already in queue" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunk);
    }
}

static inline void trace_qemu_rdma_signal_unregister_already(uint64_t chunk)
{
    if (true) {
        _nocheck__trace_qemu_rdma_signal_unregister_already(chunk);
    }
}

#define TRACE_QEMU_RDMA_UNREGISTER_WAITING_INFLIGHT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_UNREGISTER_WAITING_INFLIGHT) || \
    false)

static inline void _nocheck__trace_qemu_rdma_unregister_waiting_inflight(uint64_t chunk)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_UNREGISTER_WAITING_INFLIGHT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_unregister_waiting_inflight " "Cannot unregister inflight chunk: %" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunk);
    }
}

static inline void trace_qemu_rdma_unregister_waiting_inflight(uint64_t chunk)
{
    if (true) {
        _nocheck__trace_qemu_rdma_unregister_waiting_inflight(chunk);
    }
}

#define TRACE_QEMU_RDMA_UNREGISTER_WAITING_PROC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_UNREGISTER_WAITING_PROC) || \
    false)

static inline void _nocheck__trace_qemu_rdma_unregister_waiting_proc(uint64_t chunk, int pos)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_UNREGISTER_WAITING_PROC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_unregister_waiting_proc " "Processing unregister for chunk: %" PRIu64 " at position %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunk, pos);
    }
}

static inline void trace_qemu_rdma_unregister_waiting_proc(uint64_t chunk, int pos)
{
    if (true) {
        _nocheck__trace_qemu_rdma_unregister_waiting_proc(chunk, pos);
    }
}

#define TRACE_QEMU_RDMA_UNREGISTER_WAITING_SEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_UNREGISTER_WAITING_SEND) || \
    false)

static inline void _nocheck__trace_qemu_rdma_unregister_waiting_send(uint64_t chunk)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_UNREGISTER_WAITING_SEND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_unregister_waiting_send " "Sending unregister for chunk: %" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunk);
    }
}

static inline void trace_qemu_rdma_unregister_waiting_send(uint64_t chunk)
{
    if (true) {
        _nocheck__trace_qemu_rdma_unregister_waiting_send(chunk);
    }
}

#define TRACE_QEMU_RDMA_UNREGISTER_WAITING_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_UNREGISTER_WAITING_COMPLETE) || \
    false)

static inline void _nocheck__trace_qemu_rdma_unregister_waiting_complete(uint64_t chunk)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_UNREGISTER_WAITING_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_unregister_waiting_complete " "Unregister for chunk: %" PRIu64 " complete." "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunk);
    }
}

static inline void trace_qemu_rdma_unregister_waiting_complete(uint64_t chunk)
{
    if (true) {
        _nocheck__trace_qemu_rdma_unregister_waiting_complete(chunk);
    }
}

#define TRACE_QEMU_RDMA_WRITE_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_WRITE_FLUSH) || \
    false)

static inline void _nocheck__trace_qemu_rdma_write_flush(int sent)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_WRITE_FLUSH)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_write_flush " "sent total: %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sent);
    }
}

static inline void trace_qemu_rdma_write_flush(int sent)
{
    if (true) {
        _nocheck__trace_qemu_rdma_write_flush(sent);
    }
}

#define TRACE_QEMU_RDMA_WRITE_ONE_BLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_WRITE_ONE_BLOCK) || \
    false)

static inline void _nocheck__trace_qemu_rdma_write_one_block(int count, int block, uint64_t chunk, uint64_t current, uint64_t len, int nb_sent, int nb_chunks)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_WRITE_ONE_BLOCK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_write_one_block " "(%d) Not clobbering: block: %d chunk %" PRIu64 " current %" PRIu64 " len %" PRIu64 " %d %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , count, block, chunk, current, len, nb_sent, nb_chunks);
    }
}

static inline void trace_qemu_rdma_write_one_block(int count, int block, uint64_t chunk, uint64_t current, uint64_t len, int nb_sent, int nb_chunks)
{
    if (true) {
        _nocheck__trace_qemu_rdma_write_one_block(count, block, chunk, current, len, nb_sent, nb_chunks);
    }
}

#define TRACE_QEMU_RDMA_WRITE_ONE_POST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_WRITE_ONE_POST) || \
    false)

static inline void _nocheck__trace_qemu_rdma_write_one_post(uint64_t chunk, long addr, long remote, uint32_t len)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_WRITE_ONE_POST)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_write_one_post " "Posting chunk: %" PRIu64 ", addr: 0x%lx remote: 0x%lx, bytes %" PRIu32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunk, addr, remote, len);
    }
}

static inline void trace_qemu_rdma_write_one_post(uint64_t chunk, long addr, long remote, uint32_t len)
{
    if (true) {
        _nocheck__trace_qemu_rdma_write_one_post(chunk, addr, remote, len);
    }
}

#define TRACE_QEMU_RDMA_WRITE_ONE_QUEUE_FULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_WRITE_ONE_QUEUE_FULL) || \
    false)

static inline void _nocheck__trace_qemu_rdma_write_one_queue_full(void)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_WRITE_ONE_QUEUE_FULL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_write_one_queue_full " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_rdma_write_one_queue_full(void)
{
    if (true) {
        _nocheck__trace_qemu_rdma_write_one_queue_full();
    }
}

#define TRACE_QEMU_RDMA_WRITE_ONE_RECVREGRES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_WRITE_ONE_RECVREGRES) || \
    false)

static inline void _nocheck__trace_qemu_rdma_write_one_recvregres(int mykey, int theirkey, uint64_t chunk)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_WRITE_ONE_RECVREGRES)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_write_one_recvregres " "Received registration result: my key: 0x%x their key 0x%x, chunk %" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , mykey, theirkey, chunk);
    }
}

static inline void trace_qemu_rdma_write_one_recvregres(int mykey, int theirkey, uint64_t chunk)
{
    if (true) {
        _nocheck__trace_qemu_rdma_write_one_recvregres(mykey, theirkey, chunk);
    }
}

#define TRACE_QEMU_RDMA_WRITE_ONE_SENDREG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_WRITE_ONE_SENDREG) || \
    false)

static inline void _nocheck__trace_qemu_rdma_write_one_sendreg(uint64_t chunk, int len, int index, int64_t offset)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_WRITE_ONE_SENDREG)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_write_one_sendreg " "Sending registration request chunk %" PRIu64 " for %d bytes, index: %d, offset: %" PRId64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunk, len, index, offset);
    }
}

static inline void trace_qemu_rdma_write_one_sendreg(uint64_t chunk, int len, int index, int64_t offset)
{
    if (true) {
        _nocheck__trace_qemu_rdma_write_one_sendreg(chunk, len, index, offset);
    }
}

#define TRACE_QEMU_RDMA_WRITE_ONE_TOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_WRITE_ONE_TOP) || \
    false)

static inline void _nocheck__trace_qemu_rdma_write_one_top(uint64_t chunks, uint64_t size)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_WRITE_ONE_TOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_write_one_top " "Writing %" PRIu64 " chunks, (%" PRIu64 " MB)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunks, size);
    }
}

static inline void trace_qemu_rdma_write_one_top(uint64_t chunks, uint64_t size)
{
    if (true) {
        _nocheck__trace_qemu_rdma_write_one_top(chunks, size);
    }
}

#define TRACE_QEMU_RDMA_WRITE_ONE_ZERO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_RDMA_WRITE_ONE_ZERO) || \
    false)

static inline void _nocheck__trace_qemu_rdma_write_one_zero(uint64_t chunk, int len, int index, int64_t offset)
{
    if (trace_event_get_state(TRACE_QEMU_RDMA_WRITE_ONE_ZERO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_rdma_write_one_zero " "Entire chunk is zero, sending compress: %" PRIu64 " for %d bytes, index: %d, offset: %" PRId64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , chunk, len, index, offset);
    }
}

static inline void trace_qemu_rdma_write_one_zero(uint64_t chunk, int len, int index, int64_t offset)
{
    if (true) {
        _nocheck__trace_qemu_rdma_write_one_zero(chunk, len, index, offset);
    }
}

#define TRACE_RDMA_ADD_BLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RDMA_ADD_BLOCK) || \
    false)

static inline void _nocheck__trace_rdma_add_block(const char * block_name, int block, uint64_t addr, uint64_t offset, uint64_t len, uint64_t end, uint64_t bits, int chunks)
{
    if (trace_event_get_state(TRACE_RDMA_ADD_BLOCK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:rdma_add_block " "Added Block: '%s':%d, addr: %" PRIu64 ", offset: %" PRIu64 " length: %" PRIu64 " end: %" PRIu64 " bits %" PRIu64 " chunks %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , block_name, block, addr, offset, len, end, bits, chunks);
    }
}

static inline void trace_rdma_add_block(const char * block_name, int block, uint64_t addr, uint64_t offset, uint64_t len, uint64_t end, uint64_t bits, int chunks)
{
    if (true) {
        _nocheck__trace_rdma_add_block(block_name, block, addr, offset, len, end, bits, chunks);
    }
}

#define TRACE_RDMA_BLOCK_NOTIFICATION_HANDLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RDMA_BLOCK_NOTIFICATION_HANDLE) || \
    false)

static inline void _nocheck__trace_rdma_block_notification_handle(const char * name, int index)
{
    if (trace_event_get_state(TRACE_RDMA_BLOCK_NOTIFICATION_HANDLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:rdma_block_notification_handle " "%s at %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, index);
    }
}

static inline void trace_rdma_block_notification_handle(const char * name, int index)
{
    if (true) {
        _nocheck__trace_rdma_block_notification_handle(name, index);
    }
}

#define TRACE_RDMA_DELETE_BLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RDMA_DELETE_BLOCK) || \
    false)

static inline void _nocheck__trace_rdma_delete_block(void * block, uint64_t addr, uint64_t offset, uint64_t len, uint64_t end, uint64_t bits, int chunks)
{
    if (trace_event_get_state(TRACE_RDMA_DELETE_BLOCK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:rdma_delete_block " "Deleted Block: %p, addr: %" PRIu64 ", offset: %" PRIu64 " length: %" PRIu64 " end: %" PRIu64 " bits %" PRIu64 " chunks %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , block, addr, offset, len, end, bits, chunks);
    }
}

static inline void trace_rdma_delete_block(void * block, uint64_t addr, uint64_t offset, uint64_t len, uint64_t end, uint64_t bits, int chunks)
{
    if (true) {
        _nocheck__trace_rdma_delete_block(block, addr, offset, len, end, bits, chunks);
    }
}

#define TRACE_RDMA_START_INCOMING_MIGRATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RDMA_START_INCOMING_MIGRATION) || \
    false)

static inline void _nocheck__trace_rdma_start_incoming_migration(void)
{
    if (trace_event_get_state(TRACE_RDMA_START_INCOMING_MIGRATION)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:rdma_start_incoming_migration " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_rdma_start_incoming_migration(void)
{
    if (true) {
        _nocheck__trace_rdma_start_incoming_migration();
    }
}

#define TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_DEST_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_DEST_INIT) || \
    false)

static inline void _nocheck__trace_rdma_start_incoming_migration_after_dest_init(void)
{
    if (trace_event_get_state(TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_DEST_INIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:rdma_start_incoming_migration_after_dest_init " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_rdma_start_incoming_migration_after_dest_init(void)
{
    if (true) {
        _nocheck__trace_rdma_start_incoming_migration_after_dest_init();
    }
}

#define TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_RDMA_LISTEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_RDMA_LISTEN) || \
    false)

static inline void _nocheck__trace_rdma_start_incoming_migration_after_rdma_listen(void)
{
    if (trace_event_get_state(TRACE_RDMA_START_INCOMING_MIGRATION_AFTER_RDMA_LISTEN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:rdma_start_incoming_migration_after_rdma_listen " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_rdma_start_incoming_migration_after_rdma_listen(void)
{
    if (true) {
        _nocheck__trace_rdma_start_incoming_migration_after_rdma_listen();
    }
}

#define TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_CONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_CONNECT) || \
    false)

static inline void _nocheck__trace_rdma_start_outgoing_migration_after_rdma_connect(void)
{
    if (trace_event_get_state(TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_CONNECT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:rdma_start_outgoing_migration_after_rdma_connect " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_rdma_start_outgoing_migration_after_rdma_connect(void)
{
    if (true) {
        _nocheck__trace_rdma_start_outgoing_migration_after_rdma_connect();
    }
}

#define TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_SOURCE_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_SOURCE_INIT) || \
    false)

static inline void _nocheck__trace_rdma_start_outgoing_migration_after_rdma_source_init(void)
{
    if (trace_event_get_state(TRACE_RDMA_START_OUTGOING_MIGRATION_AFTER_RDMA_SOURCE_INIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:rdma_start_outgoing_migration_after_rdma_source_init " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_rdma_start_outgoing_migration_after_rdma_source_init(void)
{
    if (true) {
        _nocheck__trace_rdma_start_outgoing_migration_after_rdma_source_init();
    }
}

#define TRACE_POSTCOPY_DISCARD_SEND_FINISH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_DISCARD_SEND_FINISH) || \
    false)

static inline void _nocheck__trace_postcopy_discard_send_finish(const char * ramblock, int nwords, int ncmds)
{
    if (trace_event_get_state(TRACE_POSTCOPY_DISCARD_SEND_FINISH)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_discard_send_finish " "%s mask words sent=%d in %d commands" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ramblock, nwords, ncmds);
    }
}

static inline void trace_postcopy_discard_send_finish(const char * ramblock, int nwords, int ncmds)
{
    if (true) {
        _nocheck__trace_postcopy_discard_send_finish(ramblock, nwords, ncmds);
    }
}

#define TRACE_POSTCOPY_DISCARD_SEND_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_DISCARD_SEND_RANGE) || \
    false)

static inline void _nocheck__trace_postcopy_discard_send_range(const char * ramblock, unsigned long start, unsigned long length)
{
    if (trace_event_get_state(TRACE_POSTCOPY_DISCARD_SEND_RANGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_discard_send_range " "%s:%lx/%lx" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ramblock, start, length);
    }
}

static inline void trace_postcopy_discard_send_range(const char * ramblock, unsigned long start, unsigned long length)
{
    if (true) {
        _nocheck__trace_postcopy_discard_send_range(ramblock, start, length);
    }
}

#define TRACE_POSTCOPY_CLEANUP_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_CLEANUP_RANGE) || \
    false)

static inline void _nocheck__trace_postcopy_cleanup_range(const char * ramblock, void * host_addr, size_t offset, size_t length)
{
    if (trace_event_get_state(TRACE_POSTCOPY_CLEANUP_RANGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_cleanup_range " "%s: %p offset=0x%zx length=0x%zx" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ramblock, host_addr, offset, length);
    }
}

static inline void trace_postcopy_cleanup_range(const char * ramblock, void * host_addr, size_t offset, size_t length)
{
    if (true) {
        _nocheck__trace_postcopy_cleanup_range(ramblock, host_addr, offset, length);
    }
}

#define TRACE_POSTCOPY_INIT_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_INIT_RANGE) || \
    false)

static inline void _nocheck__trace_postcopy_init_range(const char * ramblock, void * host_addr, size_t offset, size_t length)
{
    if (trace_event_get_state(TRACE_POSTCOPY_INIT_RANGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_init_range " "%s: %p offset=0x%zx length=0x%zx" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ramblock, host_addr, offset, length);
    }
}

static inline void trace_postcopy_init_range(const char * ramblock, void * host_addr, size_t offset, size_t length)
{
    if (true) {
        _nocheck__trace_postcopy_init_range(ramblock, host_addr, offset, length);
    }
}

#define TRACE_POSTCOPY_NHP_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_NHP_RANGE) || \
    false)

static inline void _nocheck__trace_postcopy_nhp_range(const char * ramblock, void * host_addr, size_t offset, size_t length)
{
    if (trace_event_get_state(TRACE_POSTCOPY_NHP_RANGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_nhp_range " "%s: %p offset=0x%zx length=0x%zx" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ramblock, host_addr, offset, length);
    }
}

static inline void trace_postcopy_nhp_range(const char * ramblock, void * host_addr, size_t offset, size_t length)
{
    if (true) {
        _nocheck__trace_postcopy_nhp_range(ramblock, host_addr, offset, length);
    }
}

#define TRACE_POSTCOPY_PLACE_PAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_PLACE_PAGE) || \
    false)

static inline void _nocheck__trace_postcopy_place_page(void * host_addr)
{
    if (trace_event_get_state(TRACE_POSTCOPY_PLACE_PAGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_place_page " "host=%p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , host_addr);
    }
}

static inline void trace_postcopy_place_page(void * host_addr)
{
    if (true) {
        _nocheck__trace_postcopy_place_page(host_addr);
    }
}

#define TRACE_POSTCOPY_PLACE_PAGE_ZERO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_PLACE_PAGE_ZERO) || \
    false)

static inline void _nocheck__trace_postcopy_place_page_zero(void * host_addr)
{
    if (trace_event_get_state(TRACE_POSTCOPY_PLACE_PAGE_ZERO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_place_page_zero " "host=%p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , host_addr);
    }
}

static inline void trace_postcopy_place_page_zero(void * host_addr)
{
    if (true) {
        _nocheck__trace_postcopy_place_page_zero(host_addr);
    }
}

#define TRACE_POSTCOPY_RAM_ENABLE_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_ENABLE_NOTIFY) || \
    false)

static inline void _nocheck__trace_postcopy_ram_enable_notify(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_ENABLE_NOTIFY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_enable_notify " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_ram_enable_notify(void)
{
    if (true) {
        _nocheck__trace_postcopy_ram_enable_notify();
    }
}

#define TRACE_POSTCOPY_RAM_FAULT_THREAD_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_FAULT_THREAD_ENTRY) || \
    false)

static inline void _nocheck__trace_postcopy_ram_fault_thread_entry(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_FAULT_THREAD_ENTRY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_fault_thread_entry " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_ram_fault_thread_entry(void)
{
    if (true) {
        _nocheck__trace_postcopy_ram_fault_thread_entry();
    }
}

#define TRACE_POSTCOPY_RAM_FAULT_THREAD_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_FAULT_THREAD_EXIT) || \
    false)

static inline void _nocheck__trace_postcopy_ram_fault_thread_exit(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_FAULT_THREAD_EXIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_fault_thread_exit " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_ram_fault_thread_exit(void)
{
    if (true) {
        _nocheck__trace_postcopy_ram_fault_thread_exit();
    }
}

#define TRACE_POSTCOPY_RAM_FAULT_THREAD_QUIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_FAULT_THREAD_QUIT) || \
    false)

static inline void _nocheck__trace_postcopy_ram_fault_thread_quit(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_FAULT_THREAD_QUIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_fault_thread_quit " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_ram_fault_thread_quit(void)
{
    if (true) {
        _nocheck__trace_postcopy_ram_fault_thread_quit();
    }
}

#define TRACE_POSTCOPY_RAM_FAULT_THREAD_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_FAULT_THREAD_REQUEST) || \
    false)

static inline void _nocheck__trace_postcopy_ram_fault_thread_request(uint64_t hostaddr, const char * ramblock, size_t offset)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_FAULT_THREAD_REQUEST)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_fault_thread_request " "Request for HVA=0x%" PRIx64 " rb=%s offset=0x%zx" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , hostaddr, ramblock, offset);
    }
}

static inline void trace_postcopy_ram_fault_thread_request(uint64_t hostaddr, const char * ramblock, size_t offset)
{
    if (true) {
        _nocheck__trace_postcopy_ram_fault_thread_request(hostaddr, ramblock, offset);
    }
}

#define TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_CLOSEUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_CLOSEUF) || \
    false)

static inline void _nocheck__trace_postcopy_ram_incoming_cleanup_closeuf(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_CLOSEUF)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_incoming_cleanup_closeuf " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_ram_incoming_cleanup_closeuf(void)
{
    if (true) {
        _nocheck__trace_postcopy_ram_incoming_cleanup_closeuf();
    }
}

#define TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_ENTRY) || \
    false)

static inline void _nocheck__trace_postcopy_ram_incoming_cleanup_entry(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_ENTRY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_incoming_cleanup_entry " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_ram_incoming_cleanup_entry(void)
{
    if (true) {
        _nocheck__trace_postcopy_ram_incoming_cleanup_entry();
    }
}

#define TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_EXIT) || \
    false)

static inline void _nocheck__trace_postcopy_ram_incoming_cleanup_exit(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_EXIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_incoming_cleanup_exit " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_ram_incoming_cleanup_exit(void)
{
    if (true) {
        _nocheck__trace_postcopy_ram_incoming_cleanup_exit();
    }
}

#define TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_JOIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_JOIN) || \
    false)

static inline void _nocheck__trace_postcopy_ram_incoming_cleanup_join(void)
{
    if (trace_event_get_state(TRACE_POSTCOPY_RAM_INCOMING_CLEANUP_JOIN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:postcopy_ram_incoming_cleanup_join " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_postcopy_ram_incoming_cleanup_join(void)
{
    if (true) {
        _nocheck__trace_postcopy_ram_incoming_cleanup_join();
    }
}

#define TRACE_SAVE_XBZRLE_PAGE_SKIPPING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVE_XBZRLE_PAGE_SKIPPING) || \
    false)

static inline void _nocheck__trace_save_xbzrle_page_skipping(void)
{
    if (trace_event_get_state(TRACE_SAVE_XBZRLE_PAGE_SKIPPING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:save_xbzrle_page_skipping " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_save_xbzrle_page_skipping(void)
{
    if (true) {
        _nocheck__trace_save_xbzrle_page_skipping();
    }
}

#define TRACE_SAVE_XBZRLE_PAGE_OVERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SAVE_XBZRLE_PAGE_OVERFLOW) || \
    false)

static inline void _nocheck__trace_save_xbzrle_page_overflow(void)
{
    if (trace_event_get_state(TRACE_SAVE_XBZRLE_PAGE_OVERFLOW)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:save_xbzrle_page_overflow " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_save_xbzrle_page_overflow(void)
{
    if (true) {
        _nocheck__trace_save_xbzrle_page_overflow();
    }
}

#define TRACE_RAM_SAVE_ITERATE_BIG_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RAM_SAVE_ITERATE_BIG_WAIT) || \
    false)

static inline void _nocheck__trace_ram_save_iterate_big_wait(uint64_t milliconds, int iterations)
{
    if (trace_event_get_state(TRACE_RAM_SAVE_ITERATE_BIG_WAIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:ram_save_iterate_big_wait " "big wait: %" PRIu64 " milliseconds, %d iterations" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , milliconds, iterations);
    }
}

static inline void trace_ram_save_iterate_big_wait(uint64_t milliconds, int iterations)
{
    if (true) {
        _nocheck__trace_ram_save_iterate_big_wait(milliconds, iterations);
    }
}

#define TRACE_RAM_LOAD_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RAM_LOAD_COMPLETE) || \
    false)

static inline void _nocheck__trace_ram_load_complete(int ret, uint64_t seq_iter)
{
    if (trace_event_get_state(TRACE_RAM_LOAD_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:ram_load_complete " "exit_code %d seq iteration %" PRIu64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ret, seq_iter);
    }
}

static inline void trace_ram_load_complete(int ret, uint64_t seq_iter)
{
    if (true) {
        _nocheck__trace_ram_load_complete(ret, seq_iter);
    }
}

#define TRACE_MIGRATION_EXEC_OUTGOING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_EXEC_OUTGOING) || \
    false)

static inline void _nocheck__trace_migration_exec_outgoing(const char * cmd)
{
    if (trace_event_get_state(TRACE_MIGRATION_EXEC_OUTGOING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_exec_outgoing " "cmd=%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cmd);
    }
}

static inline void trace_migration_exec_outgoing(const char * cmd)
{
    if (true) {
        _nocheck__trace_migration_exec_outgoing(cmd);
    }
}

#define TRACE_MIGRATION_EXEC_INCOMING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_EXEC_INCOMING) || \
    false)

static inline void _nocheck__trace_migration_exec_incoming(const char * cmd)
{
    if (trace_event_get_state(TRACE_MIGRATION_EXEC_INCOMING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_exec_incoming " "cmd=%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cmd);
    }
}

static inline void trace_migration_exec_incoming(const char * cmd)
{
    if (true) {
        _nocheck__trace_migration_exec_incoming(cmd);
    }
}

#define TRACE_MIGRATION_FD_OUTGOING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_FD_OUTGOING) || \
    false)

static inline void _nocheck__trace_migration_fd_outgoing(int fd)
{
    if (trace_event_get_state(TRACE_MIGRATION_FD_OUTGOING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_fd_outgoing " "fd=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , fd);
    }
}

static inline void trace_migration_fd_outgoing(int fd)
{
    if (true) {
        _nocheck__trace_migration_fd_outgoing(fd);
    }
}

#define TRACE_MIGRATION_FD_INCOMING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_FD_INCOMING) || \
    false)

static inline void _nocheck__trace_migration_fd_incoming(int fd)
{
    if (trace_event_get_state(TRACE_MIGRATION_FD_INCOMING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_fd_incoming " "fd=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , fd);
    }
}

static inline void trace_migration_fd_incoming(int fd)
{
    if (true) {
        _nocheck__trace_migration_fd_incoming(fd);
    }
}

#define TRACE_MIGRATION_SOCKET_INCOMING_ACCEPTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_SOCKET_INCOMING_ACCEPTED) || \
    false)

static inline void _nocheck__trace_migration_socket_incoming_accepted(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_SOCKET_INCOMING_ACCEPTED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_socket_incoming_accepted " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_socket_incoming_accepted(void)
{
    if (true) {
        _nocheck__trace_migration_socket_incoming_accepted();
    }
}

#define TRACE_MIGRATION_SOCKET_OUTGOING_CONNECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_SOCKET_OUTGOING_CONNECTED) || \
    false)

static inline void _nocheck__trace_migration_socket_outgoing_connected(const char * hostname)
{
    if (trace_event_get_state(TRACE_MIGRATION_SOCKET_OUTGOING_CONNECTED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_socket_outgoing_connected " "hostname=%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , hostname);
    }
}

static inline void trace_migration_socket_outgoing_connected(const char * hostname)
{
    if (true) {
        _nocheck__trace_migration_socket_outgoing_connected(hostname);
    }
}

#define TRACE_MIGRATION_SOCKET_OUTGOING_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_SOCKET_OUTGOING_ERROR) || \
    false)

static inline void _nocheck__trace_migration_socket_outgoing_error(const char * err)
{
    if (trace_event_get_state(TRACE_MIGRATION_SOCKET_OUTGOING_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_socket_outgoing_error " "error=%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , err);
    }
}

static inline void trace_migration_socket_outgoing_error(const char * err)
{
    if (true) {
        _nocheck__trace_migration_socket_outgoing_error(err);
    }
}

#define TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_START) || \
    false)

static inline void _nocheck__trace_migration_tls_outgoing_handshake_start(const char * hostname)
{
    if (trace_event_get_state(TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_tls_outgoing_handshake_start " "hostname=%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , hostname);
    }
}

static inline void trace_migration_tls_outgoing_handshake_start(const char * hostname)
{
    if (true) {
        _nocheck__trace_migration_tls_outgoing_handshake_start(hostname);
    }
}

#define TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_ERROR) || \
    false)

static inline void _nocheck__trace_migration_tls_outgoing_handshake_error(const char * err)
{
    if (trace_event_get_state(TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_tls_outgoing_handshake_error " "err=%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , err);
    }
}

static inline void trace_migration_tls_outgoing_handshake_error(const char * err)
{
    if (true) {
        _nocheck__trace_migration_tls_outgoing_handshake_error(err);
    }
}

#define TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_COMPLETE) || \
    false)

static inline void _nocheck__trace_migration_tls_outgoing_handshake_complete(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_TLS_OUTGOING_HANDSHAKE_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_tls_outgoing_handshake_complete " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_tls_outgoing_handshake_complete(void)
{
    if (true) {
        _nocheck__trace_migration_tls_outgoing_handshake_complete();
    }
}

#define TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_START) || \
    false)

static inline void _nocheck__trace_migration_tls_incoming_handshake_start(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_tls_incoming_handshake_start " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_tls_incoming_handshake_start(void)
{
    if (true) {
        _nocheck__trace_migration_tls_incoming_handshake_start();
    }
}

#define TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_ERROR) || \
    false)

static inline void _nocheck__trace_migration_tls_incoming_handshake_error(const char * err)
{
    if (trace_event_get_state(TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_tls_incoming_handshake_error " "err=%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , err);
    }
}

static inline void trace_migration_tls_incoming_handshake_error(const char * err)
{
    if (true) {
        _nocheck__trace_migration_tls_incoming_handshake_error(err);
    }
}

#define TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_COMPLETE) || \
    false)

static inline void _nocheck__trace_migration_tls_incoming_handshake_complete(void)
{
    if (trace_event_get_state(TRACE_MIGRATION_TLS_INCOMING_HANDSHAKE_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:migration_tls_incoming_handshake_complete " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_migration_tls_incoming_handshake_complete(void)
{
    if (true) {
        _nocheck__trace_migration_tls_incoming_handshake_complete();
    }
}

#define TRACE_COLO_VM_STATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_COLO_VM_STATE_CHANGE) || \
    false)

static inline void _nocheck__trace_colo_vm_state_change(const char * old, const char * new)
{
    if (trace_event_get_state(TRACE_COLO_VM_STATE_CHANGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:colo_vm_state_change " "Change '%s' => '%s'" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , old, new);
    }
}

static inline void trace_colo_vm_state_change(const char * old, const char * new)
{
    if (true) {
        _nocheck__trace_colo_vm_state_change(old, new);
    }
}

#define TRACE_COLO_SEND_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_COLO_SEND_MESSAGE) || \
    false)

static inline void _nocheck__trace_colo_send_message(const char * msg)
{
    if (trace_event_get_state(TRACE_COLO_SEND_MESSAGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:colo_send_message " "Send '%s' message" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , msg);
    }
}

static inline void trace_colo_send_message(const char * msg)
{
    if (true) {
        _nocheck__trace_colo_send_message(msg);
    }
}

#define TRACE_COLO_RECEIVE_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_COLO_RECEIVE_MESSAGE) || \
    false)

static inline void _nocheck__trace_colo_receive_message(const char * msg)
{
    if (trace_event_get_state(TRACE_COLO_RECEIVE_MESSAGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:colo_receive_message " "Receive '%s' message" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , msg);
    }
}

static inline void trace_colo_receive_message(const char * msg)
{
    if (true) {
        _nocheck__trace_colo_receive_message(msg);
    }
}

#define TRACE_COLO_FAILOVER_SET_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_COLO_FAILOVER_SET_STATE) || \
    false)

static inline void _nocheck__trace_colo_failover_set_state(const char * new_state)
{
    if (trace_event_get_state(TRACE_COLO_FAILOVER_SET_STATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:colo_failover_set_state " "new state %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , new_state);
    }
}

static inline void trace_colo_failover_set_state(const char * new_state)
{
    if (true) {
        _nocheck__trace_colo_failover_set_state(new_state);
    }
}
#endif /* TRACE_MIGRATION_GENERATED_TRACERS_H */
