/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_ROOT_GENERATED_TRACERS_H
#define TRACE_ROOT_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_CPU_IN_EVENT;
extern TraceEvent _TRACE_CPU_OUT_EVENT;
extern TraceEvent _TRACE_BALLOON_EVENT_EVENT;
extern TraceEvent _TRACE_VM_STATE_NOTIFY_EVENT;
extern TraceEvent _TRACE_LOAD_FILE_EVENT;
extern TraceEvent _TRACE_RUNSTATE_SET_EVENT;
extern TraceEvent _TRACE_SYSTEM_WAKEUP_REQUEST_EVENT;
extern TraceEvent _TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST_EVENT;
extern TraceEvent _TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST_EVENT;
extern TraceEvent _TRACE_MONITOR_PROTOCOL_EVENT_HANDLER_EVENT;
extern TraceEvent _TRACE_MONITOR_PROTOCOL_EVENT_EMIT_EVENT;
extern TraceEvent _TRACE_MONITOR_PROTOCOL_EVENT_QUEUE_EVENT;
extern TraceEvent _TRACE_HANDLE_HMP_COMMAND_EVENT;
extern TraceEvent _TRACE_HANDLE_QMP_COMMAND_EVENT;
extern TraceEvent _TRACE_DMA_BLK_IO_EVENT;
extern TraceEvent _TRACE_DMA_AIO_CANCEL_EVENT;
extern TraceEvent _TRACE_DMA_COMPLETE_EVENT;
extern TraceEvent _TRACE_DMA_BLK_CB_EVENT;
extern TraceEvent _TRACE_DMA_MAP_WAIT_EVENT;
extern TraceEvent _TRACE_FIND_RAM_OFFSET_EVENT;
extern TraceEvent _TRACE_FIND_RAM_OFFSET_LOOP_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_OPS_READ_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_OPS_WRITE_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_SUBPAGE_READ_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_SUBPAGE_WRITE_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_TB_READ_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_TB_WRITE_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_RAM_DEVICE_READ_EVENT;
extern TraceEvent _TRACE_MEMORY_REGION_RAM_DEVICE_WRITE_EVENT;
extern TraceEvent _TRACE_FLATVIEW_NEW_EVENT;
extern TraceEvent _TRACE_FLATVIEW_DESTROY_EVENT;
extern TraceEvent _TRACE_FLATVIEW_DESTROY_RCU_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_START_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_EXITING_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_CONTINUE_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_CONTINUE_CPU_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_STEPPING_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_EXTRA_INFO_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_WATCHPOINT_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_INTERNAL_ERROR_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_BREAK_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_PAUSED_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_SHUTDOWN_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_IO_ERROR_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_WATCHDOG_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_UNKNOWN_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_REPLY_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_BINARYREPLY_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_COMMAND_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_GOT_ACK_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_GOT_UNEXPECTED_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_GOT_NACK_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_GARBAGE_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_OVERRUN_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_INVALID_REPEAT_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_INVALID_RLE_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_EVENT;
extern TraceEvent _TRACE_GUEST_CPU_ENTER_EVENT;
extern TraceEvent _TRACE_GUEST_CPU_EXIT_EVENT;
extern TraceEvent _TRACE_GUEST_CPU_RESET_EVENT;
extern TraceEvent _TRACE_GUEST_MEM_BEFORE_TRANS_EVENT;
extern TraceEvent _TRACE_GUEST_MEM_BEFORE_EXEC_EVENT;
extern TraceEvent _TRACE_GUEST_USER_SYSCALL_EVENT;
extern TraceEvent _TRACE_GUEST_USER_SYSCALL_RET_EVENT;
extern uint16_t _TRACE_CPU_IN_DSTATE;
extern uint16_t _TRACE_CPU_OUT_DSTATE;
extern uint16_t _TRACE_BALLOON_EVENT_DSTATE;
extern uint16_t _TRACE_VM_STATE_NOTIFY_DSTATE;
extern uint16_t _TRACE_LOAD_FILE_DSTATE;
extern uint16_t _TRACE_RUNSTATE_SET_DSTATE;
extern uint16_t _TRACE_SYSTEM_WAKEUP_REQUEST_DSTATE;
extern uint16_t _TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST_DSTATE;
extern uint16_t _TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST_DSTATE;
extern uint16_t _TRACE_MONITOR_PROTOCOL_EVENT_HANDLER_DSTATE;
extern uint16_t _TRACE_MONITOR_PROTOCOL_EVENT_EMIT_DSTATE;
extern uint16_t _TRACE_MONITOR_PROTOCOL_EVENT_QUEUE_DSTATE;
extern uint16_t _TRACE_HANDLE_HMP_COMMAND_DSTATE;
extern uint16_t _TRACE_HANDLE_QMP_COMMAND_DSTATE;
extern uint16_t _TRACE_DMA_BLK_IO_DSTATE;
extern uint16_t _TRACE_DMA_AIO_CANCEL_DSTATE;
extern uint16_t _TRACE_DMA_COMPLETE_DSTATE;
extern uint16_t _TRACE_DMA_BLK_CB_DSTATE;
extern uint16_t _TRACE_DMA_MAP_WAIT_DSTATE;
extern uint16_t _TRACE_FIND_RAM_OFFSET_DSTATE;
extern uint16_t _TRACE_FIND_RAM_OFFSET_LOOP_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_OPS_READ_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_OPS_WRITE_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_SUBPAGE_READ_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_SUBPAGE_WRITE_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_TB_READ_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_TB_WRITE_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_RAM_DEVICE_READ_DSTATE;
extern uint16_t _TRACE_MEMORY_REGION_RAM_DEVICE_WRITE_DSTATE;
extern uint16_t _TRACE_FLATVIEW_NEW_DSTATE;
extern uint16_t _TRACE_FLATVIEW_DESTROY_DSTATE;
extern uint16_t _TRACE_FLATVIEW_DESTROY_RCU_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_START_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_EXITING_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_CONTINUE_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_CONTINUE_CPU_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_STEPPING_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_EXTRA_INFO_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_WATCHPOINT_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_INTERNAL_ERROR_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_BREAK_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_PAUSED_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_SHUTDOWN_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_IO_ERROR_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_WATCHDOG_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_UNKNOWN_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_REPLY_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_BINARYREPLY_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_COMMAND_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_GOT_ACK_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_GOT_UNEXPECTED_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_GOT_NACK_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_GARBAGE_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_OVERRUN_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_INVALID_REPEAT_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_INVALID_RLE_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_DSTATE;
extern uint16_t _TRACE_GUEST_CPU_ENTER_DSTATE;
extern uint16_t _TRACE_GUEST_CPU_EXIT_DSTATE;
extern uint16_t _TRACE_GUEST_CPU_RESET_DSTATE;
extern uint16_t _TRACE_GUEST_MEM_BEFORE_TRANS_DSTATE;
extern uint16_t _TRACE_GUEST_MEM_BEFORE_EXEC_DSTATE;
extern uint16_t _TRACE_GUEST_USER_SYSCALL_DSTATE;
extern uint16_t _TRACE_GUEST_USER_SYSCALL_RET_DSTATE;
#define TRACE_CPU_IN_ENABLED 1
#define TRACE_CPU_OUT_ENABLED 1
#define TRACE_BALLOON_EVENT_ENABLED 1
#define TRACE_VM_STATE_NOTIFY_ENABLED 1
#define TRACE_LOAD_FILE_ENABLED 1
#define TRACE_RUNSTATE_SET_ENABLED 1
#define TRACE_SYSTEM_WAKEUP_REQUEST_ENABLED 1
#define TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST_ENABLED 1
#define TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST_ENABLED 1
#define TRACE_MONITOR_PROTOCOL_EVENT_HANDLER_ENABLED 1
#define TRACE_MONITOR_PROTOCOL_EVENT_EMIT_ENABLED 1
#define TRACE_MONITOR_PROTOCOL_EVENT_QUEUE_ENABLED 1
#define TRACE_HANDLE_HMP_COMMAND_ENABLED 1
#define TRACE_HANDLE_QMP_COMMAND_ENABLED 1
#define TRACE_DMA_BLK_IO_ENABLED 1
#define TRACE_DMA_AIO_CANCEL_ENABLED 1
#define TRACE_DMA_COMPLETE_ENABLED 1
#define TRACE_DMA_BLK_CB_ENABLED 1
#define TRACE_DMA_MAP_WAIT_ENABLED 1
#define TRACE_FIND_RAM_OFFSET_ENABLED 1
#define TRACE_FIND_RAM_OFFSET_LOOP_ENABLED 1
#define TRACE_MEMORY_REGION_OPS_READ_ENABLED 1
#define TRACE_MEMORY_REGION_OPS_WRITE_ENABLED 1
#define TRACE_MEMORY_REGION_SUBPAGE_READ_ENABLED 1
#define TRACE_MEMORY_REGION_SUBPAGE_WRITE_ENABLED 1
#define TRACE_MEMORY_REGION_TB_READ_ENABLED 1
#define TRACE_MEMORY_REGION_TB_WRITE_ENABLED 1
#define TRACE_MEMORY_REGION_RAM_DEVICE_READ_ENABLED 1
#define TRACE_MEMORY_REGION_RAM_DEVICE_WRITE_ENABLED 1
#define TRACE_FLATVIEW_NEW_ENABLED 1
#define TRACE_FLATVIEW_DESTROY_ENABLED 1
#define TRACE_FLATVIEW_DESTROY_RCU_ENABLED 1
#define TRACE_GDBSTUB_OP_START_ENABLED 1
#define TRACE_GDBSTUB_OP_EXITING_ENABLED 1
#define TRACE_GDBSTUB_OP_CONTINUE_ENABLED 1
#define TRACE_GDBSTUB_OP_CONTINUE_CPU_ENABLED 1
#define TRACE_GDBSTUB_OP_STEPPING_ENABLED 1
#define TRACE_GDBSTUB_OP_EXTRA_INFO_ENABLED 1
#define TRACE_GDBSTUB_HIT_WATCHPOINT_ENABLED 1
#define TRACE_GDBSTUB_HIT_INTERNAL_ERROR_ENABLED 1
#define TRACE_GDBSTUB_HIT_BREAK_ENABLED 1
#define TRACE_GDBSTUB_HIT_PAUSED_ENABLED 1
#define TRACE_GDBSTUB_HIT_SHUTDOWN_ENABLED 1
#define TRACE_GDBSTUB_HIT_IO_ERROR_ENABLED 1
#define TRACE_GDBSTUB_HIT_WATCHDOG_ENABLED 1
#define TRACE_GDBSTUB_HIT_UNKNOWN_ENABLED 1
#define TRACE_GDBSTUB_IO_REPLY_ENABLED 1
#define TRACE_GDBSTUB_IO_BINARYREPLY_ENABLED 1
#define TRACE_GDBSTUB_IO_COMMAND_ENABLED 1
#define TRACE_GDBSTUB_IO_GOT_ACK_ENABLED 1
#define TRACE_GDBSTUB_IO_GOT_UNEXPECTED_ENABLED 1
#define TRACE_GDBSTUB_ERR_GOT_NACK_ENABLED 1
#define TRACE_GDBSTUB_ERR_GARBAGE_ENABLED 1
#define TRACE_GDBSTUB_ERR_OVERRUN_ENABLED 1
#define TRACE_GDBSTUB_ERR_INVALID_REPEAT_ENABLED 1
#define TRACE_GDBSTUB_ERR_INVALID_RLE_ENABLED 1
#define TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_ENABLED 1
#define TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_ENABLED 1
#define TRACE_GUEST_CPU_ENTER_ENABLED 1
#define TRACE_GUEST_CPU_EXIT_ENABLED 1
#define TRACE_GUEST_CPU_RESET_ENABLED 1
#define TRACE_GUEST_MEM_BEFORE_TRANS_ENABLED 1
#define TRACE_GUEST_MEM_BEFORE_ENABLED 1
#define TRACE_GUEST_MEM_BEFORE_EXEC_ENABLED 1
#define TRACE_GUEST_USER_SYSCALL_ENABLED 1
#define TRACE_GUEST_USER_SYSCALL_RET_ENABLED 1
#include "qemu/log.h"


#define TRACE_CPU_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_IN) || \
    false)

static inline void _nocheck__trace_cpu_in(unsigned int addr, char size, unsigned int val)
{
    if (trace_event_get_state(TRACE_CPU_IN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cpu_in " "addr 0x%x(%c) value %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, size, val);
    }
}

static inline void trace_cpu_in(unsigned int addr, char size, unsigned int val)
{
    if (true) {
        _nocheck__trace_cpu_in(addr, size, val);
    }
}

#define TRACE_CPU_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPU_OUT) || \
    false)

static inline void _nocheck__trace_cpu_out(unsigned int addr, char size, unsigned int val)
{
    if (trace_event_get_state(TRACE_CPU_OUT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:cpu_out " "addr 0x%x(%c) value %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, size, val);
    }
}

static inline void trace_cpu_out(unsigned int addr, char size, unsigned int val)
{
    if (true) {
        _nocheck__trace_cpu_out(addr, size, val);
    }
}

#define TRACE_BALLOON_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BALLOON_EVENT) || \
    false)

static inline void _nocheck__trace_balloon_event(void * opaque, unsigned long addr)
{
    if (trace_event_get_state(TRACE_BALLOON_EVENT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:balloon_event " "opaque %p addr %lu" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , opaque, addr);
    }
}

static inline void trace_balloon_event(void * opaque, unsigned long addr)
{
    if (true) {
        _nocheck__trace_balloon_event(opaque, addr);
    }
}

#define TRACE_VM_STATE_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VM_STATE_NOTIFY) || \
    false)

static inline void _nocheck__trace_vm_state_notify(int running, int reason)
{
    if (trace_event_get_state(TRACE_VM_STATE_NOTIFY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vm_state_notify " "running %d reason %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , running, reason);
    }
}

static inline void trace_vm_state_notify(int running, int reason)
{
    if (true) {
        _nocheck__trace_vm_state_notify(running, reason);
    }
}

#define TRACE_LOAD_FILE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LOAD_FILE) || \
    false)

static inline void _nocheck__trace_load_file(const char * name, const char * path)
{
    if (trace_event_get_state(TRACE_LOAD_FILE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:load_file " "name %s location %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , name, path);
    }
}

static inline void trace_load_file(const char * name, const char * path)
{
    if (true) {
        _nocheck__trace_load_file(name, path);
    }
}

#define TRACE_RUNSTATE_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RUNSTATE_SET) || \
    false)

static inline void _nocheck__trace_runstate_set(int new_state)
{
    if (trace_event_get_state(TRACE_RUNSTATE_SET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:runstate_set " "new state %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , new_state);
    }
}

static inline void trace_runstate_set(int new_state)
{
    if (true) {
        _nocheck__trace_runstate_set(new_state);
    }
}

#define TRACE_SYSTEM_WAKEUP_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SYSTEM_WAKEUP_REQUEST) || \
    false)

static inline void _nocheck__trace_system_wakeup_request(int reason)
{
    if (trace_event_get_state(TRACE_SYSTEM_WAKEUP_REQUEST)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:system_wakeup_request " "reason=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , reason);
    }
}

static inline void trace_system_wakeup_request(int reason)
{
    if (true) {
        _nocheck__trace_system_wakeup_request(reason);
    }
}

#define TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST) || \
    false)

static inline void _nocheck__trace_qemu_system_shutdown_request(int reason)
{
    if (trace_event_get_state(TRACE_QEMU_SYSTEM_SHUTDOWN_REQUEST)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_system_shutdown_request " "reason=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , reason);
    }
}

static inline void trace_qemu_system_shutdown_request(int reason)
{
    if (true) {
        _nocheck__trace_qemu_system_shutdown_request(reason);
    }
}

#define TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST) || \
    false)

static inline void _nocheck__trace_qemu_system_powerdown_request(void)
{
    if (trace_event_get_state(TRACE_QEMU_SYSTEM_POWERDOWN_REQUEST)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:qemu_system_powerdown_request " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_qemu_system_powerdown_request(void)
{
    if (true) {
        _nocheck__trace_qemu_system_powerdown_request();
    }
}

#define TRACE_MONITOR_PROTOCOL_EVENT_HANDLER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MONITOR_PROTOCOL_EVENT_HANDLER) || \
    false)

static inline void _nocheck__trace_monitor_protocol_event_handler(uint32_t event, void * qdict)
{
    if (trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT_HANDLER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:monitor_protocol_event_handler " "event=%d data=%p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , event, qdict);
    }
}

static inline void trace_monitor_protocol_event_handler(uint32_t event, void * qdict)
{
    if (true) {
        _nocheck__trace_monitor_protocol_event_handler(event, qdict);
    }
}

#define TRACE_MONITOR_PROTOCOL_EVENT_EMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MONITOR_PROTOCOL_EVENT_EMIT) || \
    false)

static inline void _nocheck__trace_monitor_protocol_event_emit(uint32_t event, void * data)
{
    if (trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT_EMIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:monitor_protocol_event_emit " "event=%d data=%p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , event, data);
    }
}

static inline void trace_monitor_protocol_event_emit(uint32_t event, void * data)
{
    if (true) {
        _nocheck__trace_monitor_protocol_event_emit(event, data);
    }
}

#define TRACE_MONITOR_PROTOCOL_EVENT_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MONITOR_PROTOCOL_EVENT_QUEUE) || \
    false)

static inline void _nocheck__trace_monitor_protocol_event_queue(uint32_t event, void * qdict, uint64_t rate)
{
    if (trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT_QUEUE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:monitor_protocol_event_queue " "event=%d data=%p rate=%" PRId64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , event, qdict, rate);
    }
}

static inline void trace_monitor_protocol_event_queue(uint32_t event, void * qdict, uint64_t rate)
{
    if (true) {
        _nocheck__trace_monitor_protocol_event_queue(event, qdict, rate);
    }
}

#define TRACE_HANDLE_HMP_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_HMP_COMMAND) || \
    false)

static inline void _nocheck__trace_handle_hmp_command(void * mon, const char * cmdline)
{
    if (trace_event_get_state(TRACE_HANDLE_HMP_COMMAND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:handle_hmp_command " "mon %p cmdline: %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , mon, cmdline);
    }
}

static inline void trace_handle_hmp_command(void * mon, const char * cmdline)
{
    if (true) {
        _nocheck__trace_handle_hmp_command(mon, cmdline);
    }
}

#define TRACE_HANDLE_QMP_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_QMP_COMMAND) || \
    false)

static inline void _nocheck__trace_handle_qmp_command(void * mon, const char * req)
{
    if (trace_event_get_state(TRACE_HANDLE_QMP_COMMAND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:handle_qmp_command " "mon %p req: %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , mon, req);
    }
}

static inline void trace_handle_qmp_command(void * mon, const char * req)
{
    if (true) {
        _nocheck__trace_handle_qmp_command(mon, req);
    }
}

#define TRACE_DMA_BLK_IO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DMA_BLK_IO) || \
    false)

static inline void _nocheck__trace_dma_blk_io(void * dbs, void * bs, int64_t offset, bool to_dev)
{
    if (trace_event_get_state(TRACE_DMA_BLK_IO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:dma_blk_io " "dbs=%p bs=%p offset=%" PRId64 " to_dev=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , dbs, bs, offset, to_dev);
    }
}

static inline void trace_dma_blk_io(void * dbs, void * bs, int64_t offset, bool to_dev)
{
    if (true) {
        _nocheck__trace_dma_blk_io(dbs, bs, offset, to_dev);
    }
}

#define TRACE_DMA_AIO_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DMA_AIO_CANCEL) || \
    false)

static inline void _nocheck__trace_dma_aio_cancel(void * dbs)
{
    if (trace_event_get_state(TRACE_DMA_AIO_CANCEL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:dma_aio_cancel " "dbs=%p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , dbs);
    }
}

static inline void trace_dma_aio_cancel(void * dbs)
{
    if (true) {
        _nocheck__trace_dma_aio_cancel(dbs);
    }
}

#define TRACE_DMA_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DMA_COMPLETE) || \
    false)

static inline void _nocheck__trace_dma_complete(void * dbs, int ret, void * cb)
{
    if (trace_event_get_state(TRACE_DMA_COMPLETE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:dma_complete " "dbs=%p ret=%d cb=%p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , dbs, ret, cb);
    }
}

static inline void trace_dma_complete(void * dbs, int ret, void * cb)
{
    if (true) {
        _nocheck__trace_dma_complete(dbs, ret, cb);
    }
}

#define TRACE_DMA_BLK_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DMA_BLK_CB) || \
    false)

static inline void _nocheck__trace_dma_blk_cb(void * dbs, int ret)
{
    if (trace_event_get_state(TRACE_DMA_BLK_CB)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:dma_blk_cb " "dbs=%p ret=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , dbs, ret);
    }
}

static inline void trace_dma_blk_cb(void * dbs, int ret)
{
    if (true) {
        _nocheck__trace_dma_blk_cb(dbs, ret);
    }
}

#define TRACE_DMA_MAP_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DMA_MAP_WAIT) || \
    false)

static inline void _nocheck__trace_dma_map_wait(void * dbs)
{
    if (trace_event_get_state(TRACE_DMA_MAP_WAIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:dma_map_wait " "dbs=%p" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , dbs);
    }
}

static inline void trace_dma_map_wait(void * dbs)
{
    if (true) {
        _nocheck__trace_dma_map_wait(dbs);
    }
}

#define TRACE_FIND_RAM_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FIND_RAM_OFFSET) || \
    false)

static inline void _nocheck__trace_find_ram_offset(uint64_t size, uint64_t offset)
{
    if (trace_event_get_state(TRACE_FIND_RAM_OFFSET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:find_ram_offset " "size: 0x%" PRIx64 " @ 0x%" PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , size, offset);
    }
}

static inline void trace_find_ram_offset(uint64_t size, uint64_t offset)
{
    if (true) {
        _nocheck__trace_find_ram_offset(size, offset);
    }
}

#define TRACE_FIND_RAM_OFFSET_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FIND_RAM_OFFSET_LOOP) || \
    false)

static inline void _nocheck__trace_find_ram_offset_loop(uint64_t size, uint64_t candidate, uint64_t offset, uint64_t next, uint64_t mingap)
{
    if (trace_event_get_state(TRACE_FIND_RAM_OFFSET_LOOP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:find_ram_offset_loop " "trying size: 0x%" PRIx64 " @ 0x%" PRIx64 ", offset: 0x%" PRIx64" next: 0x%" PRIx64 " mingap: 0x%" PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , size, candidate, offset, next, mingap);
    }
}

static inline void trace_find_ram_offset_loop(uint64_t size, uint64_t candidate, uint64_t offset, uint64_t next, uint64_t mingap)
{
    if (true) {
        _nocheck__trace_find_ram_offset_loop(size, candidate, offset, next, mingap);
    }
}

#define TRACE_MEMORY_REGION_OPS_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_OPS_READ) || \
    false)

static inline void _nocheck__trace_memory_region_ops_read(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_OPS_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:memory_region_ops_read " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cpu_index, mr, addr, value, size);
    }
}

static inline void trace_memory_region_ops_read(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_ops_read(cpu_index, mr, addr, value, size);
    }
}

#define TRACE_MEMORY_REGION_OPS_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_OPS_WRITE) || \
    false)

static inline void _nocheck__trace_memory_region_ops_write(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_OPS_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:memory_region_ops_write " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cpu_index, mr, addr, value, size);
    }
}

static inline void trace_memory_region_ops_write(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_ops_write(cpu_index, mr, addr, value, size);
    }
}

#define TRACE_MEMORY_REGION_SUBPAGE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_SUBPAGE_READ) || \
    false)

static inline void _nocheck__trace_memory_region_subpage_read(int cpu_index, void * mr, uint64_t offset, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_SUBPAGE_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:memory_region_subpage_read " "cpu %d mr %p offset 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cpu_index, mr, offset, value, size);
    }
}

static inline void trace_memory_region_subpage_read(int cpu_index, void * mr, uint64_t offset, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_subpage_read(cpu_index, mr, offset, value, size);
    }
}

#define TRACE_MEMORY_REGION_SUBPAGE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_SUBPAGE_WRITE) || \
    false)

static inline void _nocheck__trace_memory_region_subpage_write(int cpu_index, void * mr, uint64_t offset, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_SUBPAGE_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:memory_region_subpage_write " "cpu %d mr %p offset 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cpu_index, mr, offset, value, size);
    }
}

static inline void trace_memory_region_subpage_write(int cpu_index, void * mr, uint64_t offset, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_subpage_write(cpu_index, mr, offset, value, size);
    }
}

#define TRACE_MEMORY_REGION_TB_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_TB_READ) || \
    false)

static inline void _nocheck__trace_memory_region_tb_read(int cpu_index, uint64_t addr, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_TB_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:memory_region_tb_read " "cpu %d addr 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cpu_index, addr, value, size);
    }
}

static inline void trace_memory_region_tb_read(int cpu_index, uint64_t addr, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_tb_read(cpu_index, addr, value, size);
    }
}

#define TRACE_MEMORY_REGION_TB_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_TB_WRITE) || \
    false)

static inline void _nocheck__trace_memory_region_tb_write(int cpu_index, uint64_t addr, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_TB_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:memory_region_tb_write " "cpu %d addr 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cpu_index, addr, value, size);
    }
}

static inline void trace_memory_region_tb_write(int cpu_index, uint64_t addr, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_tb_write(cpu_index, addr, value, size);
    }
}

#define TRACE_MEMORY_REGION_RAM_DEVICE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_RAM_DEVICE_READ) || \
    false)

static inline void _nocheck__trace_memory_region_ram_device_read(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_RAM_DEVICE_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:memory_region_ram_device_read " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cpu_index, mr, addr, value, size);
    }
}

static inline void trace_memory_region_ram_device_read(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_ram_device_read(cpu_index, mr, addr, value, size);
    }
}

#define TRACE_MEMORY_REGION_RAM_DEVICE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEMORY_REGION_RAM_DEVICE_WRITE) || \
    false)

static inline void _nocheck__trace_memory_region_ram_device_write(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (trace_event_get_state(TRACE_MEMORY_REGION_RAM_DEVICE_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:memory_region_ram_device_write " "cpu %d mr %p addr 0x%"PRIx64" value 0x%"PRIx64" size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cpu_index, mr, addr, value, size);
    }
}

static inline void trace_memory_region_ram_device_write(int cpu_index, void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    if (true) {
        _nocheck__trace_memory_region_ram_device_write(cpu_index, mr, addr, value, size);
    }
}

#define TRACE_FLATVIEW_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FLATVIEW_NEW) || \
    false)

static inline void _nocheck__trace_flatview_new(FlatView * view, MemoryRegion * root)
{
    if (trace_event_get_state(TRACE_FLATVIEW_NEW)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:flatview_new " "%p (root %p)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , view, root);
    }
}

static inline void trace_flatview_new(FlatView * view, MemoryRegion * root)
{
    if (true) {
        _nocheck__trace_flatview_new(view, root);
    }
}

#define TRACE_FLATVIEW_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FLATVIEW_DESTROY) || \
    false)

static inline void _nocheck__trace_flatview_destroy(FlatView * view, MemoryRegion * root)
{
    if (trace_event_get_state(TRACE_FLATVIEW_DESTROY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:flatview_destroy " "%p (root %p)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , view, root);
    }
}

static inline void trace_flatview_destroy(FlatView * view, MemoryRegion * root)
{
    if (true) {
        _nocheck__trace_flatview_destroy(view, root);
    }
}

#define TRACE_FLATVIEW_DESTROY_RCU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FLATVIEW_DESTROY_RCU) || \
    false)

static inline void _nocheck__trace_flatview_destroy_rcu(FlatView * view, MemoryRegion * root)
{
    if (trace_event_get_state(TRACE_FLATVIEW_DESTROY_RCU)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:flatview_destroy_rcu " "%p (root %p)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , view, root);
    }
}

static inline void trace_flatview_destroy_rcu(FlatView * view, MemoryRegion * root)
{
    if (true) {
        _nocheck__trace_flatview_destroy_rcu(view, root);
    }
}

#define TRACE_GDBSTUB_OP_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_START) || \
    false)

static inline void _nocheck__trace_gdbstub_op_start(const char * device)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_START)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_op_start " "Starting gdbstub using device %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , device);
    }
}

static inline void trace_gdbstub_op_start(const char * device)
{
    if (true) {
        _nocheck__trace_gdbstub_op_start(device);
    }
}

#define TRACE_GDBSTUB_OP_EXITING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_EXITING) || \
    false)

static inline void _nocheck__trace_gdbstub_op_exiting(uint8_t code)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_EXITING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_op_exiting " "notifying exit with code=0x%02x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , code);
    }
}

static inline void trace_gdbstub_op_exiting(uint8_t code)
{
    if (true) {
        _nocheck__trace_gdbstub_op_exiting(code);
    }
}

#define TRACE_GDBSTUB_OP_CONTINUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_CONTINUE) || \
    false)

static inline void _nocheck__trace_gdbstub_op_continue(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_CONTINUE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_op_continue " "Continuing all CPUs" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_op_continue(void)
{
    if (true) {
        _nocheck__trace_gdbstub_op_continue();
    }
}

#define TRACE_GDBSTUB_OP_CONTINUE_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_CONTINUE_CPU) || \
    false)

static inline void _nocheck__trace_gdbstub_op_continue_cpu(int cpu_index)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_CONTINUE_CPU)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_op_continue_cpu " "Continuing CPU %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cpu_index);
    }
}

static inline void trace_gdbstub_op_continue_cpu(int cpu_index)
{
    if (true) {
        _nocheck__trace_gdbstub_op_continue_cpu(cpu_index);
    }
}

#define TRACE_GDBSTUB_OP_STEPPING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_STEPPING) || \
    false)

static inline void _nocheck__trace_gdbstub_op_stepping(int cpu_index)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_STEPPING)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_op_stepping " "Stepping CPU %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , cpu_index);
    }
}

static inline void trace_gdbstub_op_stepping(int cpu_index)
{
    if (true) {
        _nocheck__trace_gdbstub_op_stepping(cpu_index);
    }
}

#define TRACE_GDBSTUB_OP_EXTRA_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_EXTRA_INFO) || \
    false)

static inline void _nocheck__trace_gdbstub_op_extra_info(const char * info)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_EXTRA_INFO)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_op_extra_info " "Thread extra info: %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , info);
    }
}

static inline void trace_gdbstub_op_extra_info(const char * info)
{
    if (true) {
        _nocheck__trace_gdbstub_op_extra_info(info);
    }
}

#define TRACE_GDBSTUB_HIT_WATCHPOINT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_WATCHPOINT) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_watchpoint(const char * type, int cpu_gdb_index, uint64_t vaddr)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_WATCHPOINT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_hit_watchpoint " "Watchpoint hit, type=\"%s\" cpu=%d, vaddr=0x%" PRIx64 "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , type, cpu_gdb_index, vaddr);
    }
}

static inline void trace_gdbstub_hit_watchpoint(const char * type, int cpu_gdb_index, uint64_t vaddr)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_watchpoint(type, cpu_gdb_index, vaddr);
    }
}

#define TRACE_GDBSTUB_HIT_INTERNAL_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_INTERNAL_ERROR) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_internal_error(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_INTERNAL_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_hit_internal_error " "RUN_STATE_INTERNAL_ERROR" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_hit_internal_error(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_internal_error();
    }
}

#define TRACE_GDBSTUB_HIT_BREAK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_BREAK) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_break(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_BREAK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_hit_break " "RUN_STATE_DEBUG" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_hit_break(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_break();
    }
}

#define TRACE_GDBSTUB_HIT_PAUSED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_PAUSED) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_paused(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_PAUSED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_hit_paused " "RUN_STATE_PAUSED" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_hit_paused(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_paused();
    }
}

#define TRACE_GDBSTUB_HIT_SHUTDOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_SHUTDOWN) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_shutdown(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_SHUTDOWN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_hit_shutdown " "RUN_STATE_SHUTDOWN" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_hit_shutdown(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_shutdown();
    }
}

#define TRACE_GDBSTUB_HIT_IO_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_IO_ERROR) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_io_error(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_IO_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_hit_io_error " "RUN_STATE_IO_ERROR" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_hit_io_error(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_io_error();
    }
}

#define TRACE_GDBSTUB_HIT_WATCHDOG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_WATCHDOG) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_watchdog(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_WATCHDOG)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_hit_watchdog " "RUN_STATE_WATCHDOG" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_hit_watchdog(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_watchdog();
    }
}

#define TRACE_GDBSTUB_HIT_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_UNKNOWN) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_unknown(int state)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_UNKNOWN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_hit_unknown " "Unknown run state=0x%x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , state);
    }
}

static inline void trace_gdbstub_hit_unknown(int state)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_unknown(state);
    }
}

#define TRACE_GDBSTUB_IO_REPLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_REPLY) || \
    false)

static inline void _nocheck__trace_gdbstub_io_reply(const char * message)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_REPLY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_io_reply " "Sent: %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , message);
    }
}

static inline void trace_gdbstub_io_reply(const char * message)
{
    if (true) {
        _nocheck__trace_gdbstub_io_reply(message);
    }
}

#define TRACE_GDBSTUB_IO_BINARYREPLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_BINARYREPLY) || \
    false)

static inline void _nocheck__trace_gdbstub_io_binaryreply(size_t ofs, const char * line)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_BINARYREPLY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_io_binaryreply " "0x%04zx: %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ofs, line);
    }
}

static inline void trace_gdbstub_io_binaryreply(size_t ofs, const char * line)
{
    if (true) {
        _nocheck__trace_gdbstub_io_binaryreply(ofs, line);
    }
}

#define TRACE_GDBSTUB_IO_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_COMMAND) || \
    false)

static inline void _nocheck__trace_gdbstub_io_command(const char * command)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_COMMAND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_io_command " "Received: %s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , command);
    }
}

static inline void trace_gdbstub_io_command(const char * command)
{
    if (true) {
        _nocheck__trace_gdbstub_io_command(command);
    }
}

#define TRACE_GDBSTUB_IO_GOT_ACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_GOT_ACK) || \
    false)

static inline void _nocheck__trace_gdbstub_io_got_ack(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_GOT_ACK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_io_got_ack " "Got ACK" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_io_got_ack(void)
{
    if (true) {
        _nocheck__trace_gdbstub_io_got_ack();
    }
}

#define TRACE_GDBSTUB_IO_GOT_UNEXPECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_GOT_UNEXPECTED) || \
    false)

static inline void _nocheck__trace_gdbstub_io_got_unexpected(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_GOT_UNEXPECTED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_io_got_unexpected " "Got 0x%02x when expecting ACK/NACK" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ch);
    }
}

static inline void trace_gdbstub_io_got_unexpected(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_io_got_unexpected(ch);
    }
}

#define TRACE_GDBSTUB_ERR_GOT_NACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_GOT_NACK) || \
    false)

static inline void _nocheck__trace_gdbstub_err_got_nack(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_GOT_NACK)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_err_got_nack " "Got NACK, retransmitting" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_err_got_nack(void)
{
    if (true) {
        _nocheck__trace_gdbstub_err_got_nack();
    }
}

#define TRACE_GDBSTUB_ERR_GARBAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_GARBAGE) || \
    false)

static inline void _nocheck__trace_gdbstub_err_garbage(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_GARBAGE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_err_garbage " "received garbage between packets: 0x%02x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ch);
    }
}

static inline void trace_gdbstub_err_garbage(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_err_garbage(ch);
    }
}

#define TRACE_GDBSTUB_ERR_OVERRUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_OVERRUN) || \
    false)

static inline void _nocheck__trace_gdbstub_err_overrun(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_OVERRUN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_err_overrun " "command buffer overrun, dropping command" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_err_overrun(void)
{
    if (true) {
        _nocheck__trace_gdbstub_err_overrun();
    }
}

#define TRACE_GDBSTUB_ERR_INVALID_REPEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_INVALID_REPEAT) || \
    false)

static inline void _nocheck__trace_gdbstub_err_invalid_repeat(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_INVALID_REPEAT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_err_invalid_repeat " "got invalid RLE count: 0x%02x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ch);
    }
}

static inline void trace_gdbstub_err_invalid_repeat(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_err_invalid_repeat(ch);
    }
}

#define TRACE_GDBSTUB_ERR_INVALID_RLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_INVALID_RLE) || \
    false)

static inline void _nocheck__trace_gdbstub_err_invalid_rle(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_INVALID_RLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_err_invalid_rle " "got invalid RLE sequence" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_gdbstub_err_invalid_rle(void)
{
    if (true) {
        _nocheck__trace_gdbstub_err_invalid_rle();
    }
}

#define TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_CHECKSUM_INVALID) || \
    false)

static inline void _nocheck__trace_gdbstub_err_checksum_invalid(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_CHECKSUM_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_err_checksum_invalid " "got invalid command checksum digit: 0x%02x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , ch);
    }
}

static inline void trace_gdbstub_err_checksum_invalid(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_err_checksum_invalid(ch);
    }
}

#define TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT) || \
    false)

static inline void _nocheck__trace_gdbstub_err_checksum_incorrect(uint8_t expected, uint8_t got)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:gdbstub_err_checksum_incorrect " "got command packet with incorrect checksum, expected=0x%02x, received=0x%02x" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , expected, got);
    }
}

static inline void trace_gdbstub_err_checksum_incorrect(uint8_t expected, uint8_t got)
{
    if (true) {
        _nocheck__trace_gdbstub_err_checksum_incorrect(expected, got);
    }
}

#define TRACE_GUEST_CPU_ENTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GUEST_CPU_ENTER) || \
    false)

static inline void _nocheck__trace_guest_cpu_enter(CPUState * __cpu)
{
    if (true) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:guest_cpu_enter " "cpu=%p " "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , __cpu);
    }
}

static inline void trace_guest_cpu_enter(CPUState * __cpu)
{
    if (trace_event_get_vcpu_state(__cpu, TRACE_GUEST_CPU_ENTER)) {
        _nocheck__trace_guest_cpu_enter(__cpu);
    }
}

#define TRACE_GUEST_CPU_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GUEST_CPU_EXIT) || \
    false)

static inline void _nocheck__trace_guest_cpu_exit(CPUState * __cpu)
{
    if (true) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:guest_cpu_exit " "cpu=%p " "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , __cpu);
    }
}

static inline void trace_guest_cpu_exit(CPUState * __cpu)
{
    if (trace_event_get_vcpu_state(__cpu, TRACE_GUEST_CPU_EXIT)) {
        _nocheck__trace_guest_cpu_exit(__cpu);
    }
}

#define TRACE_GUEST_CPU_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GUEST_CPU_RESET) || \
    false)

static inline void _nocheck__trace_guest_cpu_reset(CPUState * __cpu)
{
    if (true) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:guest_cpu_reset " "cpu=%p " "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , __cpu);
    }
}

static inline void trace_guest_cpu_reset(CPUState * __cpu)
{
    if (trace_event_get_vcpu_state(__cpu, TRACE_GUEST_CPU_RESET)) {
        _nocheck__trace_guest_cpu_reset(__cpu);
    }
}

#define TRACE_GUEST_MEM_BEFORE_TRANS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GUEST_MEM_BEFORE_TRANS) || \
    false)

static inline void _nocheck__trace_guest_mem_before_trans(CPUState * __cpu, uint8_t info)
{
    if (true) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:guest_mem_before_trans " "cpu=%p ""info=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , __cpu, info);
    }
}

static inline void trace_guest_mem_before_trans(CPUState * __cpu, uint8_t info)
{
    if (trace_event_get_vcpu_state(__cpu, TRACE_GUEST_MEM_BEFORE_TRANS)) {
        _nocheck__trace_guest_mem_before_trans(__cpu, info);
    }
}

#define TRACE_GUEST_MEM_BEFORE_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GUEST_MEM_BEFORE_EXEC) || \
    false)

static inline void _nocheck__trace_guest_mem_before_exec(CPUState * __cpu, uint64_t vaddr, uint8_t info)
{
    if (true) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:guest_mem_before_exec " "cpu=%p ""vaddr=0x%016"PRIx64" info=%d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , __cpu, vaddr, info);
    }
}

static inline void trace_guest_mem_before_exec(CPUState * __cpu, uint64_t vaddr, uint8_t info)
{
    if (trace_event_get_vcpu_state(__cpu, TRACE_GUEST_MEM_BEFORE_EXEC)) {
        _nocheck__trace_guest_mem_before_exec(__cpu, vaddr, info);
    }
}

#define TRACE_GUEST_USER_SYSCALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GUEST_USER_SYSCALL) || \
    false)

static inline void _nocheck__trace_guest_user_syscall(CPUState * __cpu, uint64_t num, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6, uint64_t arg7, uint64_t arg8)
{
    if (true) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:guest_user_syscall " "cpu=%p ""num=0x%016"PRIx64" arg1=0x%016"PRIx64" arg2=0x%016"PRIx64" arg3=0x%016"PRIx64" arg4=0x%016"PRIx64" arg5=0x%016"PRIx64" arg6=0x%016"PRIx64" arg7=0x%016"PRIx64" arg8=0x%016"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , __cpu, num, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    }
}

static inline void trace_guest_user_syscall(CPUState * __cpu, uint64_t num, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6, uint64_t arg7, uint64_t arg8)
{
    if (trace_event_get_vcpu_state(__cpu, TRACE_GUEST_USER_SYSCALL)) {
        _nocheck__trace_guest_user_syscall(__cpu, num, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    }
}

#define TRACE_GUEST_USER_SYSCALL_RET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GUEST_USER_SYSCALL_RET) || \
    false)

static inline void _nocheck__trace_guest_user_syscall_ret(CPUState * __cpu, uint64_t num, uint64_t ret)
{
    if (true) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:guest_user_syscall_ret " "cpu=%p ""num=0x%016"PRIx64" ret=0x%016"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , __cpu, num, ret);
    }
}

static inline void trace_guest_user_syscall_ret(CPUState * __cpu, uint64_t num, uint64_t ret)
{
    if (trace_event_get_vcpu_state(__cpu, TRACE_GUEST_USER_SYSCALL_RET)) {
        _nocheck__trace_guest_user_syscall_ret(__cpu, num, ret);
    }
}
#endif /* TRACE_ROOT_GENERATED_TRACERS_H */
